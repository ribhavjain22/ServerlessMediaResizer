{"version":3,"mappings":"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FACF,EACFhD,EACI,CAAkF+G,EAClF,kFACF,EACA0e,GAAA,qBACF,EAEA,IAAIC,GAAkBN,EAAA,aACtBA,EAAQ,wBACR,OAAAplB,EACIgD,EACA,kFACF,EACFhD,EACI,CAAkF+G,EAClF,kFACF,EACA2e,GAAA,qBACF,EAEA,IAAIC,GAAaP,EAAA,QACjBA,EAAQ,mBACR,OAAAplB,EACIgD,EACA,kFACF,EACFhD,EACI,CAAkF+G,EAClF,kFACF,EACA4e,GAAA,qBACF,EAEA,IAAIC,GAAWR,EAAA,MACfA,EAAQ,iBACR,OAAAplB,EACIgD,EACA,kFACF,EACFhD,EACI,CAAkF+G,EAClF,kFACF,EACA6e,GAAA,qBACF,EAEA,IAAIC,GAAqBT,EAAA,gBACzBA,EAAQ,2BACR,OAAAplB,EACIgD,EACA,kFACF,EACFhD,EACI,CAAkF+G,EAClF,kFACF,EACA8e,GAAA,qBACF,EAEA,IAAIC,GAAqBV,EAAA,gBACzBA,EAAQ,2BACR,OAAAplB,EACIgD,EACA,kFACF,EACFhD,EACI,CAAkF+G,EAClF,kFACF,EACA+e,GAAA,qBACF,EAEA,IAAIC,GAAWX,EAAA,MACfA,EAAQ,iBACR,OAAAplB,EACIgD,EACA,kFACF,EACFhD,EACI,CAAkF+G,EAClF,kFACF,EACAgf,GAAA,qBACF,EAEA,IAAIC,GAAaZ,EAAA,QACjBA,EAAQ,mBACR,OAAAplB,EACIgD,EACA,kFACF,EACFhD,EACI,CAAkF+G,EAClF,kFACF,EACAif,GAAA,qBACF,EAEA,IAAIC,GAAcb,EAAA,SAClBA,EAAQ,oBACR,OAAAplB,EACIgD,EACA,kFACF,EACFhD,EACI,CAAkF+G,EAClF,kFACF,EACAkf,GAAA,qBACF,EAEA,IAAIC,GAAyBd,EAAA,oBAC7BA,EAAQ,+BACR,OAAAplB,EACIgD,EACA,kFACF,EACFhD,EACI,CAAkF+G,EAClF,kFACF,EACAmf,GAAA,qBACF,EAEA,IAAIC,GAA2Bf,EAAA,sBAC/BA,EAAQ,iCACR,OAAAplB,EACIgD,EACA,kFACF,EACFhD,EACI,CAAkF+G,EAClF,kFACF,EACAof,GAAA,qBACF,EAEA,IAAIC,GAAchB,EAAA,SAClBA,EAAQ,oBACR,OAAAplB,EACIgD,EACA,kFACF,EACFhD,EACI,CAAkF+G,EAClF,kFACF,EACAqf,GAAA,qBACF,EAEA,IAAIC,GAAYjB,EAAA,OAChBA,EAAQ,kBACR,OAAAplB,EACIgD,EACA,kFACF,EACFhD,EACI,CAAkF+G,EAClF,kFACF,EACAsf,GAAA,qBACF,EAEA,IAAIC,GAAiBlB,EAAA,YACrBA,EAAQ,uBACR,OAAAplB,EACIgD,EACA,kFACF,EACFhD,EACI,CAAkF+G,EAClF,kFACF,EACAuf,GAAA,qBACF,EAEA,IAAIC,GAAWnB,EAAA,MACfA,EAAQ,iBACR,OAAAplB,EACIgD,EACA,kFACF,EACFhD,EACI,CAAkF+G,EAClF,kFACF,EACAwf,GAAA,qBACF,EAEA,IAAIC,GAAepB,EAAA,UACnBA,EAAQ,qBACR,OAAAplB,EACIgD,EACA,kFACF,EACFhD,EACI,CAAkF+G,EAClF,kFACF,EACAyf,GAAA,qBACF,EAEA,IAAIC,GAAiBrB,EAAA,YACrBA,EAAQ,uBACR,OAAAplB,EACIgD,EACA,kFACF,EACFhD,EACI,CAAkF+G,EAClF,kFACF,EACA0f,GAAA,qBACF,EAEA,IAAIC,GAAyBtB,EAAA,oBAC7BA,EAAQ,+BACR,OAAAplB,EACIgD,EACA,kFACF,EACFhD,EACI,CAAkF+G,EAClF,kFACF,EACA2f,GAAA,qBACF,EAEA,IAAIC,GAAgBvB,EAAA,WACpBA,EAAQ,sBACR,OAAAplB,EACIgD,EACA,kFACF,EACFhD,EACI,CAAkF+G,EAClF,kFACF,EACA4f,GAAA,qBACF,EAEA,IAAIC,GAAkBxB,EAAA,aACtBA,EAAQ,wBACR,OAAAplB,EACIgD,EACA,kFACF,EACFhD,EACI,CAAkF+G,EAClF,kFACF,EACA6f,GAAA,qBACF,EAEA,IAAIC,GAAezB,EAAA,UACnBA,EAAQ,qBACR,OAAAplB,EACIgD,EACA,kFACF,EACFhD,EACI,CAAkF+G,EAClF,kFACF,EACA8f,GAAA,qBACF,EACA5nB,QACA,IAAqC0K,GAAA1K,oCAE7B,WACR,OAAAe,EACIgD,EACA,kFACF,EACFhD,EACI,CAAkF+G,EAClF,kFACF,EACM9H,EAAA,4CACJ,KACA,SACF,CACsB,EACxBA,EAAQ,6BACR,OAAAe,EACIgD,EACA,kFACF,EACFhD,EACI,CAAkF+G,EAClF,kFACF,EACC9H,EAAA,2CACH,EACA,IAAQ6nB,GAAA7nB,EAAA,0BACR,OAAAe,EACIgD,EACA,kFACF,EACFhD,EACI,CAAkF+G,EAClF,kFACF,EACC9H,EAAA,wCACiB,EACpBA,EAAQ,yBACR,OAAAe,EACIgD,EACA,kFACF,EACFhD,EACI,CAAkF+G,EAClF,kFACF,EACC9H,EAAA,uCACH,EACA,IAAQyd,GAAAzd,EAAA,0BACR,OAAAe,EACIgD,EACA,kFACF,EACFhD,EACI,CAAkF+G,EAClF,kFACF,EACC9H,EAAA,wCACH,EACQke,GAAAle,EAAA,wBACR,OAAAe,EACIgD,EACA,kFACF,EACFhD,EACI,CAAkF+G,EAClF,kFACF,EACC9H,EAAA,sCAC8B,EACjCA,EAAc,2BACd,UAAU,CACV,OAAAe,EACMgD,EACA,kFACF,EACJhD,EACM,CAAkF+G,EAClF,kFACF,EACC9H,EAAA,oDACgB,EACrBA,EAAQ,mBACR,OAAAe,EACIgD,EACA,kFACF,EACFhD,EACI,CAAkF+G,EAClF,kFACF,EACC9H,EAAA,iCACH,EACA,IAAQ0b,GAAA1b,EAAA,iBACR,OAAAe,EACIgD,EACA,kFACF,EACFhD,EACI,CAAkF+G,EAClF,kFACF,EACC9H,EAAA,+BACmB,EACtBA,EAAQ,2BACR,OAAAe,EACIgD,EACA,kFACF,EACFhD,EACI,CAAkF+G,EAClF,kFACF,EACC9H,EAAA,yCACH,EACA,IAAQsd,GAAAtd,EAAA,2BACR,OAAAe,EACIgD,EACA,kFACF,EACFhD,EACI,CAAkF+G,EAClF,kFACF,EACC9H,EAAA,yCACS,EACZA,EAAQ,iBACR,OAAAe,EACIgD,EACA,kFACF,EACFhD,EACI,CAAkF+G,EAClF,kFACF,EACC9H,EAAA,+BACH,EACA,IAAQ0D,GAAA1D,EAAA,mBACR,OAAAe,EACIgD,EACA,kFACF,EACFhD,EACI,CAAkF+G,EAClF,kFACF,EACC9H,EAAA,iCACW,EACdA,EAAQ,mBACR,OAAAe,EACIgD,EACA,kFACF,EACFhD,EACI,CAAkF+G,EAClF,kFACF,EACC9H,EAAA,iCACY,EACfA,EAAQ,oBACR,OAAAe,EACIgD,EACA,kFACF,EACFhD,EACI,CAAkF+G,EAClF,kFACF,EACC9H,EAAA,kCACH,EACA,IAAQmf,GAAAnf,EAAA,mBACR,OAAAe,EACIgD,EACA,kFACF,EACFhD,EACI,CAAkF+G,EAClF,kFACF,EACC9H,EAAA,iCACuB,EAC1BA,EAAQ,+BACR,OAAAe,EACIgD,EACA,kFACF,EACFhD,EACI,CAAkF+G,EAClF,kFACF,EACC9H,EAAA,6CACyB,EAC5BA,EAAQ,iCACR,OAAAe,EACIgD,EACA,kFACF,EACFhD,EACI,CAAkF+G,EAClF,kFACF,EACC9H,EAAA,+CACY,EACfA,EAAQ,oBACR,OAAAe,EACIgD,EACA,kFACF,EACFhD,EACI,CAAkF+G,EAClF,kFACF,EACC9H,EAAA,kCACU,EACbA,EAAQ,kBACR,OAAAe,EACIgD,EACA,kFACF,EACFhD,EACI,CAAkF+G,EAClF,kFACF,EACC9H,EAAA,gCACe,EAClBA,EAAQ,uBACR,OAAAe,EACIgD,EACA,kFACF,EACFhD,EACI,CAAkF+G,EAClF,kFACF,EACC9H,EAAA,qCACS,EACZA,EAAQ,iBACR,OAAAe,EACIgD,EACA,kFACF,EACFhD,EACI,CAAkF+G,EAClF,kFACF,EACC9H,EAAA,+BACH,EACA,IAAQgc,EAAAhc,EAAA,qBACR,OAAAe,EACIgD,EACA,kFACF,EACFhD,EACI,CAAkF+G,EAClF,kFACF,EACC9H,EAAA,mCACe,EAClBA,EAAQ,uBACR,OAAAe,EACIgD,EACA,kFACF,EACFhD,EACI,CAAkF+G,EAClF,kFACF,EACC9H,EAAA,qCACuB,EAC1BA,EAAQ,+BACR,OAAAe,EACIgD,EACA,kFACF,EACFhD,EACI,CAAkF+G,EAClF,kFACF,EACC9H,EAAA,6CACH,EACA,IAAQ8B,GAAA9B,EAAA,sBACR,OAAAe,EACIgD,EACA,kFACF,EACFhD,EACI,CAAkF+G,EAClF,kFACF,EACC9H,EAAA,oCACH,EACQ6B,EAAA7B,EAAA,wBACR,OAAAe,EACIgD,EACA,kFACF,EACFhD,EACI,CAAkF+G,EAClF,kFACF,EACC9H,EAAA,sCACH,EACQ4B,EAAA5B,EAAA,qBACR,OAAAe,EACIgD,EACA,kFACF,EACFhD,EACI,CAAkF+G,EAClF,kFACF,EACC9H,EAAA,mCACc,EACjBA,EAAQ,sBACR,OAAAe,EACIgD,EACA,kFACF,EACFhD,EACI,CAAkF+G,EAClF,kFACF,EACC9H,EAAA,oCACe,EAClBA,EAAQ,uBACR,OAAAe,EACIgD,EACA,kFACF,EACFhD,EACI,CAAkF+G,EAClF,kFACF,EACC9H,EAAA,qCACiB,EACpBA,EAAQ,yBACR,OAAAe,EACIgD,EACA,kFACF,EACFhD,EACI,CAAkF+G,EAClF,kFACF,EACC9H,EAAA,uCACe,EAClBA,EAAQ,uBACR,OAAAe,EACIgD,EACA,kFACF,EACFhD,EACI,CAAkF+G,EAClF,kFACF,EACC9H,EAAA,qCACe,EAClBA,EAAQ,uBACR,OAAAe,EACIgD,EACA,kFACF,EACFhD,EACI,CAAkF+G,EAClF,kFACF,EACC9H,EAAA,qCACgB,EACnBA,EAAQ,wBACR,OAAAe,EACIgD,EACA,kFACF,EACFhD,EACI,CAAkF+G,EAClF,kFACF,EACC9H,EAAA,sCACgB,EACnBA,EAAQ,wBACR,OAAAe,EACIgD,EACA,kFACF,EACFhD,EACI,CAAkF+G,EAClF,kFACF,EACC9H,EAAA,sCACa,EAChBA,EAAQ,qBACR,OAAAe,EACIgD,EACA,kFACF,EACFhD,EACI,CAAkF+G,EAClF,kFACF,EACC9H,EAAA,mCACc,EACjBA,EAAQ,sBACR,OAAAe,EACIgD,EACA,kFACF,EACFhD,EACI,CAAkF+G,EAClF,kFACF,EACC9H,EAAA,oCACgB,EACnBA,EAAQ,wBACR,OAAAe,EACIgD,EACA,kFACF,EACFhD,EACI,CAAkF+G,EAClF,kFACF,EACC9H,EAAA,sCACH,EACA,IAAQ0jB,GAAA1jB,EAAA,sBACR,OAAAe,EACIgD,EACA,kFACF,EACFhD,EACI,CAAkF+G,EAClF,kFACF,EACC9H,EAAA,oCACe,EAClBA,EAAQ,uBACR,OAAAe,EACIgD,EACA,kFACF,EACFhD,EACI,CAAkF+G,EAClF,kFACF,EACC9H,EAAA,qCACuB,EAC1BA,EAAQ,+BACR,OAAAe,EACIgD,EACA,kFACF,EACFhD,EACI,CAAkF+G,EAClF,kFACF,EACC9H,EAAA,6CACmB,EACtBA,EAAQ,2BACR,OAAAe,EACIgD,EACA,kFACF,EACFhD,EACI,CAAkF+G,EAClF,kFACF,EACC9H,EAAA,yCACgB,EACnBA,EAAQ,wBACR,OAAAe,EACIgD,EACA,kFACF,EACFhD,EACI,CAAkF+G,EAClF,kFACF,EACC9H,EAAA,sCACkB,EACrBA,EAAQ,0BACR,OAAAe,EACIgD,EACA,kFACF,EACFhD,EACI,CAAkF+G,EAClF,kFACF,EACC9H,EAAA,wCACH,EACA,IAAQ6jB,GAAA7jB,EAAA,uBACR,OAAAe,EACIgD,EACA,kFACF,EACFhD,EACI,CAAkF+G,EAClF,kFACF,EACC9H,EAAA,qCACH,EACQgkB,GAAAhkB,EAAA,wBACR,OAAAe,EACIgD,EACA,kFACF,EACFhD,EACI,CAAkF+G,EAClF,kFACF,EACC9H,EAAA,sCACiB,EACpBA,EAAQ,yBACR,OAAAe,EACIgD,EACA,kFACF,EACFhD,EACI,CAAkF+G,EAClF,kFACF,EACC9H,EAAA,uCACH,EACA,IAAQmkB,GAAAnkB,EAAA,yBACR,OAAAe,EACIgD,EACA,kFACF,EACFhD,EACI,CAAkF+G,EAClF,kFACF,EACC9H,EAAA,uCACkB,EACrBA,EAAQ,0BACR,OAAAe,EACIgD,EACA,kFACF,EACFhD,EACI,CAAkF+G,EAClF,kFACF,EACC9H,EAAA,wCACmB,EACtBA,EAAQ,2BACR,OAAAe,EACIgD,EACA,kFACF,EACFhD,EACI,CAAkF+G,EAClF,kFACF,EACC9H,EAAA,yCACoB,EACvBA,EAAQ,4BACR,OAAAe,EACIgD,EACA,kFACF,EACFhD,EACI,CAAkF+G,EAClF,kFACF,EACC9H,EAAA,0CACsB,EACzBA,EAAQ,8BACR,OAAAe,EACIgD,EACA,kFACF,EACFhD,EACI,CAAkF+G,EAClF,kFACF,EACC9H,EAAA,4CACqB,EACxBA,EAAQ,6BACR,OAAAe,EACIgD,EACA,kFACF,EACFhD,EACI,CAAkF+G,EAClF,kFACF,EACC9H,EAAA,2CACsB,EACzBA,EAAQ,8BACR,OAAAe,EACIgD,EACA,kFACF,EACFhD,EACI,CAAkF+G,EAClF,kFACF,EACC9H,EAAA,4CACuB,EAC1BA,EAAQ,+BACR,OAAAe,EACIgD,EACA,kFACF,EACFhD,EACI,CAAkF+G,EAClF,kFACF,EACC9H,EAAA,6CACwB,EAC3BA,EAAQ,gCACR,OAAAe,EACIgD,EACA,kFACF,EACFhD,EACI,CAAkF+G,EAClF,kFACF,EACC9H,EAAA,8CACyB,EAC5BA,EAAQ,iCACR,OAAAe,EACIgD,EACA,kFACF,EACFhD,EACI,CAAkF+G,EAClF,kFACF,EACC9H,EAAA,+CAC0B,EAC7BA,EAAQ,kCACR,OAAAe,EACIgD,EACA,kFACF,EACFhD,EACI,CAAkF+G,EAClF,kFACF,EACC9H,EAAA,gDAC2B,EAC9BA,EAAQ,mCACR,OAAAe,EACIgD,EACA,kFACF,EACFhD,EACI,CAAkF+G,EAClF,kFACF,EACC9H,EAAA,iDAC4B,EAC/BA,EAAc,yBACd,UAAU,CACV,OAAAe,EACMgD,EACA,kFACF,EACJhD,EACM,CAAkF+G,EAClF,kFACF,EACC9H,EAAA,kDAC4B,EACjCA,EAAc,0BACd,UAAU,CACV,OAAAe,EACMgD,EACA,kFACF,EACJhD,EACM,CAAkF+G,EAClF,kFACF,EACC9H,EAAA,mDAC6B,EAClCA,EAAQ,gCACR,OAAAe,EACIgD,EACA,kFACF,EACFhD,EACI,CAAkF+G,EAClF,kFACF,EACC9H,EAAA,8CACwB,EAC3BA,EAAQ,gCACR,OAAAe,EACIgD,EACA,kFACF,EACFhD,EACI,CAAkF+G,EAClF,kFACF,EACC9H,EAAA,8CACuB,EAC1BA,EAAQ,+BACR,OAAAe,EACIgD,EACA,kFACF,EACFhD,EACI,CAAkF+G,EAClF,kFACF,EACC9H,EAAA,6CACmB,EACtBA,EAAQ,2BACR,OAAAe,EACIgD,EACA,kFACF,EACFhD,EACI,CAAkF+G,EAClF,kFACF,EACC9H,EAAA,yCACoB,EACvBA,EAAQ,4BACR,OAAAe,EACIgD,EACA,kFACF,EACFhD,EACI,CAAkF+G,EAClF,kFACF,EACC9H,EAAA,0CACqB,EACxBA,EAAQ,6BACR,OAAAe,EACIgD,EACA,kFACF,EACFhD,EACI,CAAkF+G,EAClF,kFACF,EACC9H,EAAA,2CACmB,EACtBA,EAAQ,2BACR,OAAAe,EACIgD,EACA,kFACF,EACFhD,EACI,CAAkF+G,EAClF,kFACF,EACC9H,EAAA,yCACe,EAClBA,EAAQ,uBACR,OAAAe,EACIgD,EACA,kFACF,EACFhD,EACI,CAAkF+G,EAClF,kFACF,EACC9H,EAAA,qCACgB,EACnBA,EAAQ,wBACR,OAAAe,EACIgD,EACA,kFACF,EACFhD,EACI,CAAkF+G,EAClF,kFACF,EACC9H,EAAA,sCACiB,EACpBA,EAAQ,yBACR,OAAAe,EACIgD,EACA,kFACF,EACFhD,EACI,CAAkF+G,EAClF,kFACF,EACC9H,EAAA,uCACgB,EACnBA,EAAQ,wBACR,OAAAe,EACIgD,EACA,kFACF,EACFhD,EACI,CAAkF+G,EAClF,kFACF,EACC9H,EAAA,sCACoB,EACvBA,EAAQ,4BACR,OAAAe,EACIgD,EACA,kFACF,EACFhD,EACI,CAAkF+G,EAClF,kFACF,EACC9H,EAAA,0CACe,EAClBA,EAAQ,uBACR,OAAAe,EACIgD,EACA,kFACF,EACFhD,EACI,CAAkF+G,EAClF,kFACF,EACC9H,EAAA,qCACc,EACjBA,EAAQ,sBACR,OAAAe,EACIgD,EACA,kFACF,EACFhD,EACI,CAAkF+G,EAClF,kFACF,EACC9H,EAAA,oCACe,EAClBA,EAAQ,uBACR,OAAAe,EACIgD,EACA,kFACF,EACFhD,EACI,CAAkF+G,EAClF,kFACF,EACC9H,EAAA,qCACkB,EACrBA,EAAQ,0BACR,OAAAe,EACIgD,EACA,kFACF,EACFhD,EACI,CAAkF+G,EAClF,kFACF,EACC9H,EAAA,wCACgB,EACnBA,EAAQ,wBACR,OAAAe,EACIgD,EACA,kFACF,EACFhD,EACI,CAAkF+G,EAClF,kFACF,EACC9H,EAAA,sCACe,EAClBA,EAAQ,uBACR,OAAAe,EACIgD,EACA,kFACF,EACFhD,EACI,CAAkF+G,EAClF,kFACF,EACC9H,EAAA,qCACH,EACA,IAAQqkB,GAAArkB,EAAA,sBACR,OAAAe,EACIgD,EACA,kFACF,EACFhD,EACI,CAAkF+G,EAClF,kFACF,EACC9H,EAAA,oCACH,EACQukB,GAAAvkB,EAAA,uBACR,OAAAe,EACIgD,EACA,kFACF,EACFhD,EACI,CAAkF+G,EAClF,kFACF,EACC9H,EAAA,qCACH,EACQykB,GAAAzkB,EAAA,wBACR,OAAAe,EACIgD,EACA,kFACF,EACFhD,EACI,CAAkF+G,EAClF,kFACF,EACC9H,EAAA,sCACH,EACQ2kB,GAAA3kB,EAAA,yBACR,OAAAe,EACIgD,EACA,kFACF,EACFhD,EACI,CAAkF+G,EAClF,kFACF,EACC9H,EAAA,uCACkB,EACrBA,EAAQ,0BACR,OAAAe,EACIgD,EACA,kFACF,EACFhD,EACI,CAAkF+G,EAClF,kFACF,EACC9H,EAAA,wCACmB,EACtBA,EAAQ,2BACR,OAAAe,EACIgD,EACA,kFACF,EACFhD,EACI,CAAkF+G,EAClF,kFACF,EACC9H,EAAA,yCACoB,EACvBA,EAAQ,4BACR,OAAAe,EACIgD,EACA,kFACF,EACFhD,EACI,CAAkF+G,EAClF,kFACF,EACC9H,EAAA,0CACqB,EACxBA,EAAQ,6BACR,OAAAe,EACIgD,EACA,kFACF,EACFhD,EACI,CAAkF+G,EAClF,kFACF,EACC9H,EAAA,2CACsB,EACzBA,EAAQ,8BACR,OAAAe,EACIgD,EACA,kFACF,EACFhD,EACI,CAAkF+G,EAClF,kFACF,EACC9H,EAAA,4CACmD,EACtDA,kDAEQ,WACR,OAAAe,EACIgD,EACA,kFACF,EACFhD,EACI,CAAkF+G,EAClF,kFACF,EACM9H,EAAA,0DACJ,KACA,SACD,CACiC,EACpCA,EAAc,8BACd,UAAU,CACV,OAAAe,EACMgD,EACA,kFACF,EACJhD,EACM,CAAkF+G,EAClF,kFACF,EACM9H,EAAA,wCACJ,KACA,SACD,CACgC,EACrCA,EAAQ,mCACR,OAAAe,EACIgD,EACA,kFACF,EACFhD,EACI,CAAkF+G,EAClF,kFACF,EACC9H,EAAA,iDACiB,EACpBA,EAAQ,yBACR,OAAAe,EACIgD,EACA,kFACF,EACFhD,EACI,CAAkF+G,EAClF,kFACF,EACC9H,EAAA,uCACH,EAGAA,EAAA,IAAAmmB,EAEQnmB,EAAqB,qBAC7BA,EAAS,8BACTkB,EACM,+FACF,CACJ,GACQlB,EAAmB,mBAC3BA,EAAS,4BACTkB,EACM,6FACF,CACJ,GACQlB,EAAQ,QAChBA,EAAS,iBACTkB,EACM,kFACF,CACJ,GACQlB,EAAQ,QAChBA,EAAS,iBACTkB,EACM,kFACF,CACJ,GACQlB,EAAW,WACnBA,EAAS,oBACTkB,EACM,qFACF,CACJ,GACQlB,EAAW,WACnBA,EAAS,oBACTkB,EACM,qFACF,CACJ,GACQlB,EAAW,WACnBA,EAAS,oBACTkB,EACM,qFACF,CACJ,GACQlB,EAAY,YACpBA,EAAS,qBACTkB,EACM,iLACF,CACJ,GACQlB,EAAgB,gBACxBA,EAAS,yBACTkB,EACM,0FACF,CACJ,GACQlB,EAAgB,gBACxBA,EAAS,yBACTkB,EACM,0FACF,CACJ,GACQlB,EAAoB,oBAC5BA,EAAS,6BACTkB,EACM,8FACF,CACJ,GACQlB,EAAe,eACvBA,EAAS,wBACTkB,EACM,yFACF,CACJ,GACQlB,EAAoB,oBAC5BA,EAAS,6BACTkB,EACM,8FACF,CACJ,GACQlB,EAAe,eACvBA,EAAS,wBACTkB,EACM,yFACF,CACJ,GACQlB,EAAkB,kBAC1BA,EAAS,2BACTkB,EACM,4FACF,CACJ,GACQlB,EAAgB,gBACxBA,EAAS,yBACTkB,EACM,0FACF,CACJ,GACQlB,EAAgB,gBACxBA,EAAS,yBACTkB,EACM,0FACF,CACJ,GACQlB,EAAmB,mBAC3BA,EAAS,4BACTkB,EACM,6FACF,CACJ,GACQlB,EAAgB,gBACxBA,EAAS,yBACTkB,EACM,0FACF,CACJ,GACQlB,EAAgB,gBACxBA,EAAS,yBACTkB,EACM,0FACF,CACJ,GACQlB,EAAmB,mBAC3BA,EAAS,4BACTkB,EACM,6FACF,CACJ,GACQlB,EAAe,eACvBA,EAAS,wBACTkB,EACM,yFACF,CACJ,GACQlB,EAAa,aACrBA,EAAS,sBACTkB,EACM,uFACF,CACJ,GACQlB,EAAc,cACtBA,EAAS,uBACTkB,EACM,wFACF,CACJ,GACQlB,EAAY,YACpBA,EAAS,qBACTkB,EACM,sFACF,CACJ,GACQlB,EAAe,eACvBA,EAAS,wBACTkB,EACM,yFACF,CACJ,GACQlB,EAAY,YACpBA,EAAS,qBACTkB,EACM,sFACF,CACJ,GACQlB,EAAe,eACvBA,EAAS,wBACTkB,EACM,yFACF,CACJ,GACQlB,EAAsB,sBAC9BA,EAAS,+BACTkB,EACM,gGACF,CACJ,GACQlB,EAAqB,qBAC7BA,EAAS,8BACTkB,EACM,+FACF,CACJ,GACQlB,EAAqB,qBAC7BA,EAAS,8BACTkB,EACM,+FACF,CACJ,GACQlB,EAAmB,mBAC3BA,EAAS,4BACTkB,EACM,wLACF,CACJ,GACQlB,EAAsB,sBAC9BA,EAAS,+BACTkB,EACM,2LACF,CACJ,GACQlB,EAAM,MACdA,EAAS,eACTkB,EACM,gFACF,CACJ,GACQlB,EAAK,KACbA,EAAS,cACTkB,EACM,+EACF,CACJ,GACQlB,EAAkB,kBAC1BA,EAAS,2BACTkB,EACM,uLACF,CACJ,GACQlB,EAAgB,gBACxBA,EAAS,yBACTkB,EACM,qLACF,CACJ,GACQlB,EAAoB,oBAC5BA,EAAS,6BACTkB,EACM,yLACF,CACJ,GACQlB,EAAyB,yBACjCA,EAAS,kCACTkB,EACM,8LACF,CACJ,GACQlB,EAAoB,oBAC5BA,EAAS,6BACTkB,EACM,yLACF,CACJ,GACQlB,EAAgB,gBACxBA,EAAS,yBACTkB,EACM,qLACF,CACJ,GACQlB,EAAkB,kBAC1BA,EAAS,2BACTkB,EACM,uLACF,CACJ,GACQlB,EAAY,YACpBA,EAAS,qBACTkB,EACM,iLACF,CACJ,GACQlB,EAAK,KACbA,EAAS,cACTkB,EACM,+EACF,CACJ,GACQlB,EAAe,eACvBA,EAAS,wBACTkB,EACM,yFACF,CACJ,GACQlB,EAAW,WACnBA,EAAS,oBACTkB,EACM,qFACF,CACJ,GACQlB,EAAqB,qBAC7BA,EAAS,8BACTkB,EACM,+FACF,CACJ,GACQlB,EAAwB,wBAChCA,EAAS,iCACTkB,EACM,kGACF,CACJ,GACQlB,EAAS,SACjBA,EAAS,kBACTkB,EACM,mFACF,CACJ,GACQlB,EAAoB,oBAC5BA,EAAS,6BACTkB,EACM,8FACF,CACJ,GACQlB,EAAsB,sBAC9BA,EAAS,+BACTkB,EACM,gGACF,CACJ,GACQlB,EAAoB,oBAC5BA,EAAS,6BACTkB,EACM,8FACF,CACJ,GACQlB,EAAc,cACtBA,EAAS,uBACTkB,EACM,wFACF,CACJ,GACQlB,EAAiB,iBACzBA,EAAS,0BACTkB,EACM,2FACF,CACJ,GACQlB,EAAiB,iBACzBA,EAAS,0BACTkB,EACM,2FACF,CACJ,GACQlB,EAAc,cACtBA,EAAS,uBACTkB,EACM,wFACF,CACJ,GACQlB,EAAa,aACrBA,EAAS,sBACTkB,EACM,uFACF,CACJ,GACQlB,EAAU,UAClBA,EAAS,mBACTkB,EACM,oFACF,CACJ,GACQlB,EAAqB,qBAC7BA,EAAS,8BACTkB,EACM,+FACF,CACJ,GACQlB,EAAY,YACpBA,EAAS,qBACTkB,EACM,sFACF,CACJ,GACQlB,EAAe,eACvBA,EAAS,wBACTkB,EACM,yFACF,CACJ,GACQlB,EAAa,aACrBA,EAAS,sBACTkB,EACM,uFACF,CACJ,GACQlB,EAAsB,sBAC9BA,EAAS,+BACTkB,EACM,gGACF,CACJ,GACQlB,EAAQ,QAChBA,EAAS,iBACTkB,EACM,kFACF,CACJ,GACQlB,EAAW,WACnBA,EA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","names":["Module","moduleOverrides","key","status","toThrow","ENVIRONMENT_IS_WEB","ENVIRONMENT_IS_WORKER","ENVIRONMENT_IS_NODE","ENVIRONMENT_IS_SHELL","scriptDirectory","nodeFS","nodePath","filename","binary","ret","assert","ex","ExitStatus","abort","f","data","url","xhr","onload","onerror","title","out","err","stackSave","stackRestore","stackAlloc","dynamicAlloc","size","DYNAMICTOP_PTR","HEAP32","end","_emscripten_get_heap_size","success","_emscripten_resize_heap","warnOnce","text","asm2wasmImports","x","y","tempRet0","setTempRet0","value","getTempRet0","wasmMemory","ABORT","condition","ALLOC_NORMAL","allocate","slab","types","allocator","ptr","zeroinit","_malloc","stop","HEAP8","HEAPU8","getMemory","runtimeInitialized","UTF8Decoder","UTF8ArrayToString","u8Array","idx","maxBytesToRead","endIdx","endPtr","str","u0","u1","u2","ch","UTF8ToString","stringToUTF8Array","outU8Array","outIdx","maxBytesToWrite","startIdx","i","u","stringToUTF8","outPtr","lengthBytesUTF8","len","allocateUTF8","allocateUTF8OnStack","writeAsciiToMemory","buffer","dontAddNull","demangle","func","demangleAll","regex","jsStackTrace","e","stackTrace","js","WASM_PAGE_SIZE","alignUp","multiple","HEAP16","HEAPU32","updateGlobalBuffer","buf","updateGlobalBufferViews","STACK_BASE","STACK_MAX","DYNAMIC_BASE","TOTAL_STACK","TOTAL_MEMORY","writeStackCookie","checkStackCookie","abortStackOverflow","allocSize","callRuntimeCallbacks","callbacks","callback","__ATPRERUN__","__ATINIT__","__ATMAIN__","__ATEXIT__","__ATPOSTRUN__","runtimeExited","preRun","addOnPreRun","ensureInitRuntime","preMain","exitRuntime","postRun","addOnPostRun","cb","runDependencies","runDependencyWatcher","dependenciesFulfilled","runDependencyTracking","getUniqueRunDependency","id","orig","addRunDependency","shown","dep","removeRunDependency","dataURIPrefix","isDataURI","wasmBinaryFile","__vitePreload","getBinary","getBinaryPromise","response","resolve","reject","createWasm","env","info","receiveInstance","instance","module","exports","trueModule","receiveInstantiatedSource","output","instantiateArrayBuffer","receiver","reason","global","providedBuffer","___emscripten_environ_constructor","tempDoublePtr","___assert_fail","line","ENV","___buildEnvironment","environ","MAX_ENV_VALUES","TOTAL_ENV_SIZE","poolPtr","envPtr","strings","totalSize","ptrSize","_emscripten_get_now","___setErrNo","_clock_gettime","clk_id","tp","now","_emscripten_get_now_is_monotonic","___clock_gettime","a0","a1","___lock","___map_file","pathname","PATH","splitPathRe","parts","allowAboveRoot","last","up","path","trailingSlash","p","isAbsolute","result","root","dir","lastSlash","paths","l","r","resolvedPath","resolvedAbsolute","FS","to","from","trim","arr","start","fromParts","toParts","length","samePartsLength","outputParts","TTY","dev","ops","stream","tty","ERRNO_CODES","offset","pos","bytesRead","BUFSIZE","isPosixPlatform","fd","usingDevice","fs","intArrayFromString","val","MEMFS","mount","parent","name","mode","node","newCapacity","prevCapacity","CAPACITY_DOUBLING_MAX","oldContents","newSize","attr","new_dir","new_name","old_node","new_node","entries","oldpath","newname","position","contents","canOwn","whence","prot","flags","allocated","mmapFlags","IDBFS","populate","local","remote","src","dst","db","req","transaction","fileStore","isRealDir","toAbsolute","check","stat","store","index","event","cursor","lookup","entry","total","create","e2","remove","completed","done","NODEFS","arrayBuffer","k","newFlags","date","newDir","newName","oldPath","oldNode","newPath","NODEJS_PATH","WORKERFS","createdParents","ensureParent","curr","file","base","obj","pack","mtime","chunk","ab","opts","defaults","current","current_path","islast","link","count","parentid","hash","nodeName","rdev","readMode","writeMode","flag","perms","isdir","fd_start","fd_end","newStream","device","ma","mi","mounts","m","doCallback","mountpoint","pseudo","type","mountRoot","next","dirs","d","newpath","old_path","new_path","old_dirname","new_dirname","old_name","old_dir","relative","dontFollow","uid","gid","atime","created","trackingFlags","seeking","bytesWritten","cmd","arg","actualNumBytes","random_device","randomBuffer","crypto_module","stdin","stdout","stderr","errno","code","input","error","fflush","canRead","canWrite","dontResolveLastLink","part","properties","target","LazyUint8Array","chunkOffset","chunkNum","getter","datalength","header","hasByteServing","usesGzip","chunkSize","doXHR","lazyArray","stream_ops","keys","fn","dontCreateFile","preFinish","fullname","processData","byteArray","handled","plugin","finish","indexedDB","openRequest","files","ok","fail","putRequest","getRequest","SYSCALLS","dirfd","dirstream","addr","bufsize","endChar","amode","suggestFD","suggest","iov","iovcnt","varargs","socket","allowNull","addrp","addrlen","low","high","which","offset_high","offset_low","zero","dirp","child","old","op","argp","_free","___unlock","_difftime","time1","time0","_longjmp","_setThrew","abortOnCannotGrowMemory","requestedSize","emscripten_realloc_buffer","PAGE_MULTIPLE","oldSize","LIMIT","MIN_TOTAL_MEMORY","replacement","_exit","exit","_getenv","_gettimeofday","___tm_current","___tm_timezone","_gmtime_r","time","tmPtr","yday","_gmtime","h","retl","_llvm_bswap_i32","reth","_tzset","__get_timezone","winter","summer","match","winterName","extractZone","summerName","winterNamePtr","summerNamePtr","__get_tzname","summerOffset","winterOffset","zonePtr","_localtime","_localtime_r","_emscripten_memcpy_big","dest","num","guessedOffset","dstOffset","nonDstOffset","trueOffset","_pthread_mutex_destroy","_pthread_mutex_init","_time","_times","_memset","t","stringy","u8array","numBytesWritten","nullFunc_dd","nullFunc_ddd","nullFunc_diiid","nullFunc_fdd","nullFunc_fdi","nullFunc_fdii","nullFunc_fiii","nullFunc_i","nullFunc_id","nullFunc_idii","nullFunc_ii","nullFunc_iid","nullFunc_iiddddddddi","nullFunc_iiddddi","nullFunc_iidi","nullFunc_iidiii","nullFunc_iii","nullFunc_iiii","nullFunc_iiiid","nullFunc_iiiii","nullFunc_iiiiii","nullFunc_iiiiiii","nullFunc_iiiiiiii","nullFunc_iiiiiiiifi","nullFunc_iiiiiiiii","nullFunc_iiiiiiiiii","nullFunc_iiiiiiiiiii","nullFunc_iiiiiiiiiiii","nullFunc_iiiiiiiiiiiii","nullFunc_iiiiiiiiiiiiii","nullFunc_iiiiiiiiiiiiiii","nullFunc_iiiiiiiiiiiiiiii","nullFunc_iiiiiiiiiiiiiiiii","nullFunc_iiiiiiiiiiji","nullFunc_iiiiiiiiiijj","nullFunc_iiiiiiijjii","nullFunc_iiiiiij","nullFunc_iiiiiiji","nullFunc_iiiiijiii","nullFunc_iiiijii","nullFunc_iij","nullFunc_iiji","nullFunc_iijii","nullFunc_iijj","nullFunc_iijjjjjj","nullFunc_iji","nullFunc_ji","nullFunc_jii","nullFunc_jiiiii","nullFunc_jiji","nullFunc_jji","nullFunc_vi","nullFunc_vii","nullFunc_viii","nullFunc_viiii","nullFunc_viiiii","nullFunc_viiiiii","nullFunc_viiiiiii","nullFunc_viiiiiiii","nullFunc_viiiiiiiii","nullFunc_viiiiiiiiiiiiiiiiiiiiiiiiiiiiiiijiiiiii","nullFunc_viiiiiiiiiiiiiijiiiii","nullFunc_viiiiiiiiijiiii","nullFunc_vijii","invoke_ii","sp","dynCall_ii","invoke_iii","a2","dynCall_iii","invoke_iiii","a3","dynCall_iiii","invoke_iiiii","a4","dynCall_iiiii","invoke_vi","dynCall_vi","invoke_vii","dynCall_vii","invoke_viii","dynCall_viii","invoke_viiii","dynCall_viiii","asmGlobalArg","asmLibraryArg","___syscall114","___syscall140","___syscall145","___syscall146","___syscall180","___syscall181","___syscall195","___syscall197","___syscall220","___syscall221","___syscall3","___syscall330","___syscall38","___syscall40","___syscall41","___syscall54","___syscall63","___syscall91","_emscripten_longjmp","_llvm_bswap_i64","_mktime","asm","real____emscripten_environ_constructor","real____errno_location","real___get_daylight","real___get_environ","real___get_timezone","real___get_tzname","real__fflush","real__free","real__llvm_bswap_i16","real__llvm_bswap_i32","real__main","real__malloc","real__memmove","real__pthread_mutex_lock","real__pthread_mutex_unlock","real__realloc","real__rintf","real__saveSetjmp","real__sbrk","real__setThrew","real__testSetjmp","real_establishStackSpace","real_stackAlloc","real_stackRestore","real_stackSave","__get_daylight","runCaller","run","args","argc","argv","toLog","doRun","shouldRunNow","implicit","abortDecorators","what","extra","decorator"],"ignoreList":[],"sources":["../../public/gs.js"],"sourcesContent":["// Copyright 2010 The Emscripten Authors.  All rights reserved.\r\n// Emscripten is available under two separate licenses, the MIT license and the\r\n// University of Illinois/NCSA Open Source License.  Both these licenses can be\r\n// found in the LICENSE file.\r\n\r\n// The Module object: Our interface to the outside world. We import\r\n// and export values on it. There are various ways Module can be used:\r\n// 1. Not defined. We create it here\r\n// 2. A function parameter, function(Module) { ..generated code.. }\r\n// 3. pre-run appended it, var Module = {}; ..generated code..\r\n// 4. External script tag defines var Module.\r\n// We need to check if Module already exists (e.g. case 3 above).\r\n// Substitution will be replaced with actual code on later stage of the build,\r\n// this way Closure Compiler will not mangle it (e.g. case 4. above).\r\n// Note that if you want to run closure, and also to use Module\r\n// after the generated code, you will need to define   var Module = {};\r\n// before the code. Then that object will be used in the code, and you\r\n// can continue to use Module afterwards as well.\r\nvar Module =\r\n  typeof window.Module !== \"undefined\"\r\n    ? window.Module\r\n    : typeof Module !== \"undefined\"\r\n      ? Module\r\n      : {};\r\nconsole.log(window.Module);\r\n// --pre-jses are emitted after the Module integration code, so that they can\r\n// refer to Module (if they choose; they can also define Module)\r\n// {{PRE_JSES}}\r\n\r\n// Sometimes an existing Module object exists with properties\r\n// meant to overwrite the default module functionality. Here\r\n// we collect those properties and reapply _after_ we configure\r\n// the current environment's defaults to avoid having to be so\r\n// defensive during initialization.\r\nvar moduleOverrides = {};\r\nvar key;\r\nfor (key in Module) {\r\n  if (Module.hasOwnProperty(key)) {\r\n    moduleOverrides[key] = Module[key];\r\n  }\r\n}\r\n\r\nModule[\"arguments\"] = [];\r\nModule[\"thisProgram\"] = \"./this.program\";\r\nModule[\"quit\"] = function (status, toThrow) {\r\n  throw toThrow;\r\n};\r\nModule[\"preRun\"] = [];\r\nModule[\"postRun\"] = [];\r\n\r\n// Determine the runtime environment we are in. You can customize this by\r\n// setting the ENVIRONMENT setting at compile time (see settings.js).\r\nvar ENVIRONMENT_IS_WEB = false;\r\nvar ENVIRONMENT_IS_WORKER = false;\r\nvar ENVIRONMENT_IS_NODE = false;\r\nvar ENVIRONMENT_IS_SHELL = false;\r\nENVIRONMENT_IS_WEB = typeof window === \"object\";\r\nENVIRONMENT_IS_WORKER = typeof importScripts === \"function\";\r\nENVIRONMENT_IS_NODE =\r\n  typeof process === \"object\" &&\r\n  typeof require === \"function\" &&\r\n  !ENVIRONMENT_IS_WEB &&\r\n  !ENVIRONMENT_IS_WORKER;\r\nENVIRONMENT_IS_SHELL =\r\n  !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;\r\n\r\nif (Module[\"ENVIRONMENT\"]) {\r\n  throw new Error(\r\n    \"Module.ENVIRONMENT has been deprecated. To force the environment, use the ENVIRONMENT compile-time option (for example, -s ENVIRONMENT=web or -s ENVIRONMENT=node)\",\r\n  );\r\n}\r\n\r\n// Three configurations we can be running in:\r\n// 1) We could be the application main() thread running in the main JS UI thread. (ENVIRONMENT_IS_WORKER == false and ENVIRONMENT_IS_PTHREAD == false)\r\n// 2) We could be the application main() thread proxied to worker. (with Emscripten -s PROXY_TO_WORKER=1) (ENVIRONMENT_IS_WORKER == true, ENVIRONMENT_IS_PTHREAD == false)\r\n// 3) We could be an application pthread running in a worker. (ENVIRONMENT_IS_WORKER == true and ENVIRONMENT_IS_PTHREAD == true)\r\n\r\n// `/` should be present at the end if `scriptDirectory` is not empty\r\nvar scriptDirectory = \"\";\r\n\r\nfunction locateFile(path) {\r\n  if (Module[\"locateFile\"]) {\r\n    return Module[\"locateFile\"](path, scriptDirectory);\r\n  } else {\r\n    return scriptDirectory + path;\r\n  }\r\n}\r\n\r\nif (ENVIRONMENT_IS_NODE) {\r\n  scriptDirectory = __dirname + \"/\";\r\n\r\n  // Expose functionality in the same simple way that the shells work\r\n  // Note that we pollute the global namespace here, otherwise we break in node\r\n  var nodeFS;\r\n  var nodePath;\r\n\r\n  Module[\"read\"] = function shell_read(filename, binary) {\r\n    var ret;\r\n    if (!nodeFS) nodeFS = require(\"fs\");\r\n    if (!nodePath) nodePath = require(\"path\");\r\n    filename = nodePath[\"normalize\"](filename);\r\n    ret = nodeFS[\"readFileSync\"](filename);\r\n    return binary ? ret : ret.toString();\r\n  };\r\n\r\n  Module[\"readBinary\"] = function readBinary(filename) {\r\n    var ret = Module[\"read\"](filename, true);\r\n    if (!ret.buffer) {\r\n      ret = new Uint8Array(ret);\r\n    }\r\n    assert(ret.buffer);\r\n    return ret;\r\n  };\r\n\r\n  if (process[\"argv\"].length > 1) {\r\n    Module[\"thisProgram\"] = process[\"argv\"][1].replace(/\\\\/g, \"/\");\r\n  }\r\n\r\n  Module[\"arguments\"] = process[\"argv\"].slice(2);\r\n\r\n  if (typeof module !== \"undefined\") {\r\n    module[\"exports\"] = Module;\r\n  }\r\n\r\n  process[\"on\"](\"uncaughtException\", function (ex) {\r\n    // suppress ExitStatus exceptions from showing an error\r\n    if (!(ex instanceof ExitStatus)) {\r\n      throw ex;\r\n    }\r\n  });\r\n  // Currently node will swallow unhandled rejections, but this behavior is\r\n  // deprecated, and in the future it will exit with error status.\r\n  process[\"on\"](\"unhandledRejection\", abort);\r\n\r\n  Module[\"quit\"] = function (status) {\r\n    process[\"exit\"](status);\r\n  };\r\n\r\n  Module[\"inspect\"] = function () {\r\n    return \"[Emscripten Module object]\";\r\n  };\r\n} else if (ENVIRONMENT_IS_SHELL) {\r\n  if (typeof read != \"undefined\") {\r\n    Module[\"read\"] = function shell_read(f) {\r\n      return read(f);\r\n    };\r\n  }\r\n\r\n  Module[\"readBinary\"] = function readBinary(f) {\r\n    var data;\r\n    if (typeof readbuffer === \"function\") {\r\n      return new Uint8Array(readbuffer(f));\r\n    }\r\n    data = read(f, \"binary\");\r\n    assert(typeof data === \"object\");\r\n    return data;\r\n  };\r\n\r\n  if (typeof scriptArgs != \"undefined\") {\r\n    Module[\"arguments\"] = scriptArgs;\r\n  } else if (typeof arguments != \"undefined\") {\r\n    Module[\"arguments\"] = arguments;\r\n  }\r\n\r\n  if (typeof quit === \"function\") {\r\n    Module[\"quit\"] = function (status) {\r\n      quit(status);\r\n    };\r\n  }\r\n} else if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {\r\n  if (ENVIRONMENT_IS_WORKER) {\r\n    // Check worker, not web, since window could be polyfilled\r\n    scriptDirectory = self.location.href;\r\n  } else if (document.currentScript) {\r\n    // web\r\n    scriptDirectory = document.currentScript.src;\r\n  }\r\n  // blob urls look like blob:http://site.com/etc/etc and we cannot infer anything from them.\r\n  // otherwise, slice off the final part of the url to find the script directory.\r\n  // if scriptDirectory does not contain a slash, lastIndexOf will return -1,\r\n  // and scriptDirectory will correctly be replaced with an empty string.\r\n  if (scriptDirectory.indexOf(\"blob:\") !== 0) {\r\n    scriptDirectory = scriptDirectory.substr(\r\n      0,\r\n      scriptDirectory.lastIndexOf(\"/\") + 1,\r\n    );\r\n  } else {\r\n    scriptDirectory = \"\";\r\n  }\r\n\r\n  Module[\"read\"] = function shell_read(url) {\r\n    var xhr = new XMLHttpRequest();\r\n    xhr.open(\"GET\", url, false);\r\n    xhr.send(null);\r\n    return xhr.responseText;\r\n  };\r\n\r\n  if (ENVIRONMENT_IS_WORKER) {\r\n    Module[\"readBinary\"] = function readBinary(url) {\r\n      var xhr = new XMLHttpRequest();\r\n      xhr.open(\"GET\", url, false);\r\n      xhr.responseType = \"arraybuffer\";\r\n      xhr.send(null);\r\n      return new Uint8Array(xhr.response);\r\n    };\r\n  }\r\n\r\n  Module[\"readAsync\"] = function readAsync(url, onload, onerror) {\r\n    var xhr = new XMLHttpRequest();\r\n    xhr.open(\"GET\", url, true);\r\n    xhr.responseType = \"arraybuffer\";\r\n    xhr.onload = function xhr_onload() {\r\n      if (xhr.status == 200 || (xhr.status == 0 && xhr.response)) {\r\n        // file URLs can return 0\r\n        onload(xhr.response);\r\n        return;\r\n      }\r\n      onerror();\r\n    };\r\n    xhr.onerror = onerror;\r\n    xhr.send(null);\r\n  };\r\n\r\n  Module[\"setWindowTitle\"] = function (title) {\r\n    document.title = title;\r\n  };\r\n} else {\r\n  throw new Error(\"environment detection error\");\r\n}\r\n\r\n// Set up the out() and err() hooks, which are how we can print to stdout or\r\n// stderr, respectively.\r\n// If the user provided Module.print or printErr, use that. Otherwise,\r\n// console.log is checked first, as 'print' on the web will open a print dialogue\r\n// printErr is preferable to console.warn (works better in shells)\r\n// bind(console) is necessary to fix IE/Edge closed dev tools panel behavior.\r\nvar out =\r\n  Module[\"print\"] ||\r\n  (typeof console !== \"undefined\"\r\n    ? console.log.bind(console)\r\n    : typeof print !== \"undefined\"\r\n      ? print\r\n      : null);\r\nvar err =\r\n  Module[\"printErr\"] ||\r\n  (typeof printErr !== \"undefined\"\r\n    ? printErr\r\n    : (typeof console !== \"undefined\" && console.warn.bind(console)) || out);\r\n\r\n// Merge back in the overrides\r\nfor (key in moduleOverrides) {\r\n  if (moduleOverrides.hasOwnProperty(key)) {\r\n    Module[key] = moduleOverrides[key];\r\n  }\r\n}\r\n// Free the object hierarchy contained in the overrides, this lets the GC\r\n// reclaim data used e.g. in memoryInitializerRequest, which is a large typed array.\r\nmoduleOverrides = undefined;\r\n\r\n// perform assertions in shell.js after we set up out() and err(), as otherwise if an assertion fails it cannot print the message\r\nassert(\r\n  typeof Module[\"memoryInitializerPrefixURL\"] === \"undefined\",\r\n  \"Module.memoryInitializerPrefixURL option was removed, use Module.locateFile instead\",\r\n);\r\nassert(\r\n  typeof Module[\"pthreadMainPrefixURL\"] === \"undefined\",\r\n  \"Module.pthreadMainPrefixURL option was removed, use Module.locateFile instead\",\r\n);\r\nassert(\r\n  typeof Module[\"cdInitializerPrefixURL\"] === \"undefined\",\r\n  \"Module.cdInitializerPrefixURL option was removed, use Module.locateFile instead\",\r\n);\r\nassert(\r\n  typeof Module[\"filePackagePrefixURL\"] === \"undefined\",\r\n  \"Module.filePackagePrefixURL option was removed, use Module.locateFile instead\",\r\n);\r\n\r\n// Copyright 2017 The Emscripten Authors.  All rights reserved.\r\n// Emscripten is available under two separate licenses, the MIT license and the\r\n// University of Illinois/NCSA Open Source License.  Both these licenses can be\r\n// found in the LICENSE file.\r\n\r\n// {{PREAMBLE_ADDITIONS}}\r\n\r\nvar STACK_ALIGN = 16;\r\n\r\n// stack management, and other functionality that is provided by the compiled code,\r\n// should not be used before it is ready\r\nstackSave =\r\n  stackRestore =\r\n  stackAlloc =\r\n    function () {\r\n      abort(\r\n        \"cannot use the stack before compiled code is ready to run, and has provided stack access\",\r\n      );\r\n    };\r\n\r\nfunction staticAlloc(size) {\r\n  abort(\r\n    \"staticAlloc is no longer available at runtime; instead, perform static allocations at compile time (using makeStaticAlloc)\",\r\n  );\r\n}\r\n\r\nfunction dynamicAlloc(size) {\r\n  assert(DYNAMICTOP_PTR);\r\n  var ret = HEAP32[DYNAMICTOP_PTR >> 2];\r\n  var end = (ret + size + 15) & -16;\r\n  if (end <= _emscripten_get_heap_size()) {\r\n    HEAP32[DYNAMICTOP_PTR >> 2] = end;\r\n  } else {\r\n    var success = _emscripten_resize_heap(end);\r\n    if (!success) return 0;\r\n  }\r\n  return ret;\r\n}\r\n\r\nfunction alignMemory(size, factor) {\r\n  if (!factor) factor = STACK_ALIGN; // stack alignment (16-byte) by default\r\n  return Math.ceil(size / factor) * factor;\r\n}\r\n\r\nfunction getNativeTypeSize(type) {\r\n  switch (type) {\r\n    case \"i1\":\r\n    case \"i8\":\r\n      return 1;\r\n    case \"i16\":\r\n      return 2;\r\n    case \"i32\":\r\n      return 4;\r\n    case \"i64\":\r\n      return 8;\r\n    case \"float\":\r\n      return 4;\r\n    case \"double\":\r\n      return 8;\r\n    default: {\r\n      if (type[type.length - 1] === \"*\") {\r\n        return 4; // A pointer\r\n      } else if (type[0] === \"i\") {\r\n        var bits = parseInt(type.substr(1));\r\n        assert(\r\n          bits % 8 === 0,\r\n          \"getNativeTypeSize invalid bits \" + bits + \", type \" + type,\r\n        );\r\n        return bits / 8;\r\n      } else {\r\n        return 0;\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction warnOnce(text) {\r\n  if (!warnOnce.shown) warnOnce.shown = {};\r\n  if (!warnOnce.shown[text]) {\r\n    warnOnce.shown[text] = 1;\r\n    err(text);\r\n  }\r\n}\r\n\r\nvar asm2wasmImports = {\r\n  // special asm2wasm imports\r\n  \"f64-rem\": function (x, y) {\r\n    return x % y;\r\n  },\r\n  debugger: function () {\r\n    debugger;\r\n  },\r\n};\r\n\r\nvar jsCallStartIndex = 1;\r\nvar functionPointers = new Array(0);\r\n\r\n// Add a wasm function to the table.\r\n// Attempting to call this with JS function will cause of table.set() to fail\r\nfunction addWasmFunction(func) {\r\n  var table = wasmTable;\r\n  var ret = table.length;\r\n  table.grow(1);\r\n  table.set(ret, func);\r\n  return ret;\r\n}\r\n\r\n// 'sig' parameter is currently only used for LLVM backend under certain\r\n// circumstance: RESERVED_FUNCTION_POINTERS=1, EMULATED_FUNCTION_POINTERS=0.\r\nfunction addFunction(func, sig) {\r\n  var base = 0;\r\n  for (var i = base; i < base + 0; i++) {\r\n    if (!functionPointers[i]) {\r\n      functionPointers[i] = func;\r\n      return jsCallStartIndex + i;\r\n    }\r\n  }\r\n  throw \"Finished up all reserved function pointers. Use a higher value for RESERVED_FUNCTION_POINTERS.\";\r\n}\r\n\r\nfunction removeFunction(index) {\r\n  functionPointers[index - jsCallStartIndex] = null;\r\n}\r\n\r\nvar funcWrappers = {};\r\n\r\nfunction getFuncWrapper(func, sig) {\r\n  if (!func) return; // on null pointer, return undefined\r\n  assert(sig);\r\n  if (!funcWrappers[sig]) {\r\n    funcWrappers[sig] = {};\r\n  }\r\n  var sigCache = funcWrappers[sig];\r\n  if (!sigCache[func]) {\r\n    // optimize away arguments usage in common cases\r\n    if (sig.length === 1) {\r\n      sigCache[func] = function dynCall_wrapper() {\r\n        return dynCall(sig, func);\r\n      };\r\n    } else if (sig.length === 2) {\r\n      sigCache[func] = function dynCall_wrapper(arg) {\r\n        return dynCall(sig, func, [arg]);\r\n      };\r\n    } else {\r\n      // general case\r\n      sigCache[func] = function dynCall_wrapper() {\r\n        return dynCall(sig, func, Array.prototype.slice.call(arguments));\r\n      };\r\n    }\r\n  }\r\n  return sigCache[func];\r\n}\r\n\r\nfunction makeBigInt(low, high, unsigned) {\r\n  return unsigned\r\n    ? +(low >>> 0) + +(high >>> 0) * 4294967296.0\r\n    : +(low >>> 0) + +(high | 0) * 4294967296.0;\r\n}\r\n\r\nfunction dynCall(sig, ptr, args) {\r\n  if (args && args.length) {\r\n    assert(args.length == sig.length - 1);\r\n    assert(\r\n      \"dynCall_\" + sig in Module,\r\n      \"bad function pointer type - no table for sig '\" + sig + \"'\",\r\n    );\r\n    return Module[\"dynCall_\" + sig].apply(null, [ptr].concat(args));\r\n  } else {\r\n    assert(sig.length == 1);\r\n    assert(\r\n      \"dynCall_\" + sig in Module,\r\n      \"bad function pointer type - no table for sig '\" + sig + \"'\",\r\n    );\r\n    return Module[\"dynCall_\" + sig].call(null, ptr);\r\n  }\r\n}\r\n\r\nvar tempRet0 = 0;\r\n\r\nvar setTempRet0 = function (value) {\r\n  tempRet0 = value;\r\n};\r\n\r\nvar getTempRet0 = function () {\r\n  return tempRet0;\r\n};\r\n\r\nfunction getCompilerSetting(name) {\r\n  throw \"You must build with -s RETAIN_COMPILER_SETTINGS=1 for getCompilerSetting or emscripten_get_compiler_setting to work\";\r\n}\r\n\r\nvar Runtime = {\r\n  // helpful errors\r\n  getTempRet0: function () {\r\n    abort(\r\n      'getTempRet0() is now a top-level function, after removing the Runtime object. Remove \"Runtime.\"',\r\n    );\r\n  },\r\n  staticAlloc: function () {\r\n    abort(\r\n      'staticAlloc() is now a top-level function, after removing the Runtime object. Remove \"Runtime.\"',\r\n    );\r\n  },\r\n  stackAlloc: function () {\r\n    abort(\r\n      'stackAlloc() is now a top-level function, after removing the Runtime object. Remove \"Runtime.\"',\r\n    );\r\n  },\r\n};\r\n\r\n// The address globals begin at. Very low in memory, for code size and optimization opportunities.\r\n// Above 0 is static memory, starting with globals.\r\n// Then the stack.\r\n// Then 'dynamic' memory for sbrk.\r\nvar GLOBAL_BASE = 1024;\r\n\r\n// === Preamble library stuff ===\r\n\r\n// Documentation for the public APIs defined in this file must be updated in:\r\n//    site/source/docs/api_reference/preamble.js.rst\r\n// A prebuilt local version of the documentation is available at:\r\n//    site/build/text/docs/api_reference/preamble.js.txt\r\n// You can also build docs locally as HTML or other formats in site/\r\n// An online HTML version (which may be of a different version of Emscripten)\r\n//    is up at http://kripken.github.io/emscripten-site/docs/api_reference/preamble.js.html\r\n\r\nif (typeof WebAssembly !== \"object\") {\r\n  abort(\r\n    \"No WebAssembly support found. Build with -s WASM=0 to target JavaScript instead.\",\r\n  );\r\n}\r\n\r\n/** @type {function(number, string, boolean=)} */\r\nfunction getValue(ptr, type, noSafe) {\r\n  type = type || \"i8\";\r\n  if (type.charAt(type.length - 1) === \"*\") type = \"i32\"; // pointers are 32-bit\r\n  switch (type) {\r\n    case \"i1\":\r\n      return HEAP8[ptr >> 0];\r\n    case \"i8\":\r\n      return HEAP8[ptr >> 0];\r\n    case \"i16\":\r\n      return HEAP16[ptr >> 1];\r\n    case \"i32\":\r\n      return HEAP32[ptr >> 2];\r\n    case \"i64\":\r\n      return HEAP32[ptr >> 2];\r\n    case \"float\":\r\n      return HEAPF32[ptr >> 2];\r\n    case \"double\":\r\n      return HEAPF64[ptr >> 3];\r\n    default:\r\n      abort(\"invalid type for getValue: \" + type);\r\n  }\r\n  return null;\r\n}\r\n\r\n// Wasm globals\r\n\r\nvar wasmMemory;\r\n\r\n// Potentially used for direct table calls.\r\nvar wasmTable;\r\n\r\n//========================================\r\n// Runtime essentials\r\n//========================================\r\n\r\n// whether we are quitting the application. no code should run after this.\r\n// set in exit() and abort()\r\nvar ABORT = false;\r\n\r\n// set by exit() and abort().  Passed to 'onExit' handler.\r\n// NOTE: This is also used as the process return code code in shell environments\r\n// but only when noExitRuntime is false.\r\nvar EXITSTATUS = 0;\r\n\r\n/** @type {function(*, string=)} */\r\nfunction assert(condition, text) {\r\n  if (!condition) {\r\n    abort(\"Assertion failed: \" + text);\r\n  }\r\n}\r\n\r\n// Returns the C function with a specified identifier (for C++, you need to do manual name mangling)\r\nfunction getCFunc(ident) {\r\n  var func = Module[\"_\" + ident]; // closure exported function\r\n  assert(\r\n    func,\r\n    \"Cannot call unknown function \" + ident + \", make sure it is exported\",\r\n  );\r\n  return func;\r\n}\r\n\r\n// C calling interface.\r\nfunction ccall(ident, returnType, argTypes, args, opts) {\r\n  // For fast lookup of conversion functions\r\n  var toC = {\r\n    string: function (str) {\r\n      var ret = 0;\r\n      if (str !== null && str !== undefined && str !== 0) {\r\n        // null string\r\n        // at most 4 bytes per UTF-8 code point, +1 for the trailing '\\0'\r\n        var len = (str.length << 2) + 1;\r\n        ret = stackAlloc(len);\r\n        stringToUTF8(str, ret, len);\r\n      }\r\n      return ret;\r\n    },\r\n    array: function (arr) {\r\n      var ret = stackAlloc(arr.length);\r\n      writeArrayToMemory(arr, ret);\r\n      return ret;\r\n    },\r\n  };\r\n\r\n  function convertReturnValue(ret) {\r\n    if (returnType === \"string\") return UTF8ToString(ret);\r\n    if (returnType === \"boolean\") return Boolean(ret);\r\n    return ret;\r\n  }\r\n\r\n  var func = getCFunc(ident);\r\n  var cArgs = [];\r\n  var stack = 0;\r\n  assert(returnType !== \"array\", 'Return type should not be \"array\".');\r\n  if (args) {\r\n    for (var i = 0; i < args.length; i++) {\r\n      var converter = toC[argTypes[i]];\r\n      if (converter) {\r\n        if (stack === 0) stack = stackSave();\r\n        cArgs[i] = converter(args[i]);\r\n      } else {\r\n        cArgs[i] = args[i];\r\n      }\r\n    }\r\n  }\r\n  var ret = func.apply(null, cArgs);\r\n  ret = convertReturnValue(ret);\r\n  if (stack !== 0) stackRestore(stack);\r\n  return ret;\r\n}\r\n\r\nfunction cwrap(ident, returnType, argTypes, opts) {\r\n  return function () {\r\n    return ccall(ident, returnType, argTypes, arguments, opts);\r\n  };\r\n}\r\n\r\n/** @type {function(number, number, string, boolean=)} */\r\nfunction setValue(ptr, value, type, noSafe) {\r\n  type = type || \"i8\";\r\n  if (type.charAt(type.length - 1) === \"*\") type = \"i32\"; // pointers are 32-bit\r\n  switch (type) {\r\n    case \"i1\":\r\n      HEAP8[ptr >> 0] = value;\r\n      break;\r\n    case \"i8\":\r\n      HEAP8[ptr >> 0] = value;\r\n      break;\r\n    case \"i16\":\r\n      HEAP16[ptr >> 1] = value;\r\n      break;\r\n    case \"i32\":\r\n      HEAP32[ptr >> 2] = value;\r\n      break;\r\n    case \"i64\":\r\n      (tempI64 = [\r\n        value >>> 0,\r\n        ((tempDouble = value),\r\n        +Math_abs(tempDouble) >= 1.0\r\n          ? tempDouble > 0.0\r\n            ? (Math_min(+Math_floor(tempDouble / 4294967296.0), 4294967295.0) |\r\n                0) >>>\r\n              0\r\n            : ~~+Math_ceil(\r\n                (tempDouble - +(~~tempDouble >>> 0)) / 4294967296.0,\r\n              ) >>> 0\r\n          : 0),\r\n      ]),\r\n        (HEAP32[ptr >> 2] = tempI64[0]),\r\n        (HEAP32[(ptr + 4) >> 2] = tempI64[1]);\r\n      break;\r\n    case \"float\":\r\n      HEAPF32[ptr >> 2] = value;\r\n      break;\r\n    case \"double\":\r\n      HEAPF64[ptr >> 3] = value;\r\n      break;\r\n    default:\r\n      abort(\"invalid type for setValue: \" + type);\r\n  }\r\n}\r\n\r\nvar ALLOC_NORMAL = 0; // Tries to use _malloc()\r\nvar ALLOC_STACK = 1; // Lives for the duration of the current function call\r\nvar ALLOC_DYNAMIC = 2; // Cannot be freed except through sbrk\r\nvar ALLOC_NONE = 3; // Do not allocate\r\n\r\n// allocate(): This is for internal use. You can use it yourself as well, but the interface\r\n//             is a little tricky (see docs right below). The reason is that it is optimized\r\n//             for multiple syntaxes to save space in generated code. So you should\r\n//             normally not use allocate(), and instead allocate memory using _malloc(),\r\n//             initialize it with setValue(), and so forth.\r\n// @slab: An array of data, or a number. If a number, then the size of the block to allocate,\r\n//        in *bytes* (note that this is sometimes confusing: the next parameter does not\r\n//        affect this!)\r\n// @types: Either an array of types, one for each byte (or 0 if no type at that position),\r\n//         or a single type which is used for the entire block. This only matters if there\r\n//         is initial data - if @slab is a number, then this does not matter at all and is\r\n//         ignored.\r\n// @allocator: How to allocate memory, see ALLOC_*\r\n/** @type {function((TypedArray|Array<number>|number), string, number, number=)} */\r\nfunction allocate(slab, types, allocator, ptr) {\r\n  var zeroinit, size;\r\n  if (typeof slab === \"number\") {\r\n    zeroinit = true;\r\n    size = slab;\r\n  } else {\r\n    zeroinit = false;\r\n    size = slab.length;\r\n  }\r\n\r\n  var singleType = typeof types === \"string\" ? types : null;\r\n\r\n  var ret;\r\n  if (allocator == ALLOC_NONE) {\r\n    ret = ptr;\r\n  } else {\r\n    ret = [_malloc, stackAlloc, dynamicAlloc][allocator](\r\n      Math.max(size, singleType ? 1 : types.length),\r\n    );\r\n  }\r\n\r\n  if (zeroinit) {\r\n    var stop;\r\n    ptr = ret;\r\n    assert((ret & 3) == 0);\r\n    stop = ret + (size & ~3);\r\n    for (; ptr < stop; ptr += 4) {\r\n      HEAP32[ptr >> 2] = 0;\r\n    }\r\n    stop = ret + size;\r\n    while (ptr < stop) {\r\n      HEAP8[ptr++ >> 0] = 0;\r\n    }\r\n    return ret;\r\n  }\r\n\r\n  if (singleType === \"i8\") {\r\n    if (slab.subarray || slab.slice) {\r\n      HEAPU8.set(/** @type {!Uint8Array} */ (slab), ret);\r\n    } else {\r\n      HEAPU8.set(new Uint8Array(slab), ret);\r\n    }\r\n    return ret;\r\n  }\r\n\r\n  var i = 0,\r\n    type,\r\n    typeSize,\r\n    previousType;\r\n  while (i < size) {\r\n    var curr = slab[i];\r\n\r\n    type = singleType || types[i];\r\n    if (type === 0) {\r\n      i++;\r\n      continue;\r\n    }\r\n    assert(type, \"Must know what type to store in allocate!\");\r\n\r\n    if (type == \"i64\") type = \"i32\"; // special case: we have one i32 here, and one i32 later\r\n\r\n    setValue(ret + i, curr, type);\r\n\r\n    // no need to look up size unless type changes, so cache it\r\n    if (previousType !== type) {\r\n      typeSize = getNativeTypeSize(type);\r\n      previousType = type;\r\n    }\r\n    i += typeSize;\r\n  }\r\n\r\n  return ret;\r\n}\r\n\r\n// Allocate memory during any stage of startup - static memory early on, dynamic memory later, malloc when ready\r\nfunction getMemory(size) {\r\n  if (!runtimeInitialized) return dynamicAlloc(size);\r\n  return _malloc(size);\r\n}\r\n\r\n/** @type {function(number, number=)} */\r\nfunction Pointer_stringify(ptr, length) {\r\n  abort(\r\n    \"this function has been removed - you should use UTF8ToString(ptr, maxBytesToRead) instead!\",\r\n  );\r\n}\r\n\r\n// Given a pointer 'ptr' to a null-terminated ASCII-encoded string in the emscripten HEAP, returns\r\n// a copy of that string as a Javascript String object.\r\n\r\nfunction AsciiToString(ptr) {\r\n  var str = \"\";\r\n  while (1) {\r\n    var ch = HEAP8[ptr++ >> 0];\r\n    if (!ch) return str;\r\n    str += String.fromCharCode(ch);\r\n  }\r\n}\r\n\r\n// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',\r\n// null-terminated and encoded in ASCII form. The copy will require at most str.length+1 bytes of space in the HEAP.\r\n\r\nfunction stringToAscii(str, outPtr) {\r\n  return writeAsciiToMemory(str, outPtr, false);\r\n}\r\n\r\n// Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the given array that contains uint8 values, returns\r\n// a copy of that string as a Javascript String object.\r\n\r\nvar UTF8Decoder =\r\n  typeof TextDecoder !== \"undefined\" ? new TextDecoder(\"utf8\") : undefined;\r\n\r\n/**\r\n * @param {number} idx\r\n * @param {number=} maxBytesToRead\r\n * @return {string}\r\n */\r\nfunction UTF8ArrayToString(u8Array, idx, maxBytesToRead) {\r\n  var endIdx = idx + maxBytesToRead;\r\n  var endPtr = idx;\r\n  // TextDecoder needs to know the byte length in advance, it doesn't stop on null terminator by itself.\r\n  // Also, use the length info to avoid running tiny strings through TextDecoder, since .subarray() allocates garbage.\r\n  // (As a tiny code save trick, compare endPtr against endIdx using a negation, so that undefined means Infinity)\r\n  while (u8Array[endPtr] && !(endPtr >= endIdx)) ++endPtr;\r\n\r\n  if (endPtr - idx > 16 && u8Array.subarray && UTF8Decoder) {\r\n    return UTF8Decoder.decode(u8Array.subarray(idx, endPtr));\r\n  } else {\r\n    var str = \"\";\r\n    // If building with TextDecoder, we have already computed the string length above, so test loop end condition against that\r\n    while (idx < endPtr) {\r\n      // For UTF8 byte structure, see:\r\n      // http://en.wikipedia.org/wiki/UTF-8#Description\r\n      // https://www.ietf.org/rfc/rfc2279.txt\r\n      // https://tools.ietf.org/html/rfc3629\r\n      var u0 = u8Array[idx++];\r\n      if (!(u0 & 0x80)) {\r\n        str += String.fromCharCode(u0);\r\n        continue;\r\n      }\r\n      var u1 = u8Array[idx++] & 63;\r\n      if ((u0 & 0xe0) == 0xc0) {\r\n        str += String.fromCharCode(((u0 & 31) << 6) | u1);\r\n        continue;\r\n      }\r\n      var u2 = u8Array[idx++] & 63;\r\n      if ((u0 & 0xf0) == 0xe0) {\r\n        u0 = ((u0 & 15) << 12) | (u1 << 6) | u2;\r\n      } else {\r\n        if ((u0 & 0xf8) != 0xf0)\r\n          warnOnce(\r\n            \"Invalid UTF-8 leading byte 0x\" +\r\n              u0.toString(16) +\r\n              \" encountered when deserializing a UTF-8 string on the asm.js/wasm heap to a JS string!\",\r\n          );\r\n        u0 = ((u0 & 7) << 18) | (u1 << 12) | (u2 << 6) | (u8Array[idx++] & 63);\r\n      }\r\n\r\n      if (u0 < 0x10000) {\r\n        str += String.fromCharCode(u0);\r\n      } else {\r\n        var ch = u0 - 0x10000;\r\n        str += String.fromCharCode(0xd800 | (ch >> 10), 0xdc00 | (ch & 0x3ff));\r\n      }\r\n    }\r\n  }\r\n  return str;\r\n}\r\n\r\n// Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the emscripten HEAP, returns a\r\n// copy of that string as a Javascript String object.\r\n// maxBytesToRead: an optional length that specifies the maximum number of bytes to read. You can omit\r\n//                 this parameter to scan the string until the first \\0 byte. If maxBytesToRead is\r\n//                 passed, and the string at [ptr, ptr+maxBytesToReadr[ contains a null byte in the\r\n//                 middle, then the string will cut short at that byte index (i.e. maxBytesToRead will\r\n//                 not produce a string of exact length [ptr, ptr+maxBytesToRead[)\r\n//                 N.B. mixing frequent uses of UTF8ToString() with and without maxBytesToRead may\r\n//                 throw JS JIT optimizations off, so it is worth to consider consistently using one\r\n//                 style or the other.\r\n/**\r\n * @param {number} ptr\r\n * @param {number=} maxBytesToRead\r\n * @return {string}\r\n */\r\nfunction UTF8ToString(ptr, maxBytesToRead) {\r\n  return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : \"\";\r\n}\r\n\r\n// Copies the given Javascript String object 'str' to the given byte array at address 'outIdx',\r\n// encoded in UTF8 form and null-terminated. The copy will require at most str.length*4+1 bytes of space in the HEAP.\r\n// Use the function lengthBytesUTF8 to compute the exact number of bytes (excluding null terminator) that this function will write.\r\n// Parameters:\r\n//   str: the Javascript string to copy.\r\n//   outU8Array: the array to copy to. Each index in this array is assumed to be one 8-byte element.\r\n//   outIdx: The starting offset in the array to begin the copying.\r\n//   maxBytesToWrite: The maximum number of bytes this function can write to the array.\r\n//                    This count should include the null terminator,\r\n//                    i.e. if maxBytesToWrite=1, only the null terminator will be written and nothing else.\r\n//                    maxBytesToWrite=0 does not write any bytes to the output, not even the null terminator.\r\n// Returns the number of bytes written, EXCLUDING the null terminator.\r\n\r\nfunction stringToUTF8Array(str, outU8Array, outIdx, maxBytesToWrite) {\r\n  if (!(maxBytesToWrite > 0))\r\n    // Parameter maxBytesToWrite is not optional. Negative values, 0, null, undefined and false each don't write out any bytes.\r\n    return 0;\r\n\r\n  var startIdx = outIdx;\r\n  var endIdx = outIdx + maxBytesToWrite - 1; // -1 for string null terminator.\r\n  for (var i = 0; i < str.length; ++i) {\r\n    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! So decode UTF16->UTF32->UTF8.\r\n    // See http://unicode.org/faq/utf_bom.html#utf16-3\r\n    // For UTF8 byte structure, see http://en.wikipedia.org/wiki/UTF-8#Description and https://www.ietf.org/rfc/rfc2279.txt and https://tools.ietf.org/html/rfc3629\r\n    var u = str.charCodeAt(i); // possibly a lead surrogate\r\n    if (u >= 0xd800 && u <= 0xdfff) {\r\n      var u1 = str.charCodeAt(++i);\r\n      u = (0x10000 + ((u & 0x3ff) << 10)) | (u1 & 0x3ff);\r\n    }\r\n    if (u <= 0x7f) {\r\n      if (outIdx >= endIdx) break;\r\n      outU8Array[outIdx++] = u;\r\n    } else if (u <= 0x7ff) {\r\n      if (outIdx + 1 >= endIdx) break;\r\n      outU8Array[outIdx++] = 0xc0 | (u >> 6);\r\n      outU8Array[outIdx++] = 0x80 | (u & 63);\r\n    } else if (u <= 0xffff) {\r\n      if (outIdx + 2 >= endIdx) break;\r\n      outU8Array[outIdx++] = 0xe0 | (u >> 12);\r\n      outU8Array[outIdx++] = 0x80 | ((u >> 6) & 63);\r\n      outU8Array[outIdx++] = 0x80 | (u & 63);\r\n    } else {\r\n      if (outIdx + 3 >= endIdx) break;\r\n      if (u >= 0x200000)\r\n        warnOnce(\r\n          \"Invalid Unicode code point 0x\" +\r\n            u.toString(16) +\r\n            \" encountered when serializing a JS string to an UTF-8 string on the asm.js/wasm heap! (Valid unicode code points should be in range 0-0x1FFFFF).\",\r\n        );\r\n      outU8Array[outIdx++] = 0xf0 | (u >> 18);\r\n      outU8Array[outIdx++] = 0x80 | ((u >> 12) & 63);\r\n      outU8Array[outIdx++] = 0x80 | ((u >> 6) & 63);\r\n      outU8Array[outIdx++] = 0x80 | (u & 63);\r\n    }\r\n  }\r\n  // Null-terminate the pointer to the buffer.\r\n  outU8Array[outIdx] = 0;\r\n  return outIdx - startIdx;\r\n}\r\n\r\n// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',\r\n// null-terminated and encoded in UTF8 form. The copy will require at most str.length*4+1 bytes of space in the HEAP.\r\n// Use the function lengthBytesUTF8 to compute the exact number of bytes (excluding null terminator) that this function will write.\r\n// Returns the number of bytes written, EXCLUDING the null terminator.\r\n\r\nfunction stringToUTF8(str, outPtr, maxBytesToWrite) {\r\n  assert(\r\n    typeof maxBytesToWrite == \"number\",\r\n    \"stringToUTF8(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!\",\r\n  );\r\n  return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);\r\n}\r\n\r\n// Returns the number of bytes the given Javascript string takes if encoded as a UTF8 byte array, EXCLUDING the null terminator byte.\r\nfunction lengthBytesUTF8(str) {\r\n  var len = 0;\r\n  for (var i = 0; i < str.length; ++i) {\r\n    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! So decode UTF16->UTF32->UTF8.\r\n    // See http://unicode.org/faq/utf_bom.html#utf16-3\r\n    var u = str.charCodeAt(i); // possibly a lead surrogate\r\n    if (u >= 0xd800 && u <= 0xdfff)\r\n      u = (0x10000 + ((u & 0x3ff) << 10)) | (str.charCodeAt(++i) & 0x3ff);\r\n    if (u <= 0x7f) ++len;\r\n    else if (u <= 0x7ff) len += 2;\r\n    else if (u <= 0xffff) len += 3;\r\n    else len += 4;\r\n  }\r\n  return len;\r\n}\r\n\r\n// Given a pointer 'ptr' to a null-terminated UTF16LE-encoded string in the emscripten HEAP, returns\r\n// a copy of that string as a Javascript String object.\r\n\r\nvar UTF16Decoder =\r\n  typeof TextDecoder !== \"undefined\" ? new TextDecoder(\"utf-16le\") : undefined;\r\n\r\nfunction UTF16ToString(ptr) {\r\n  assert(\r\n    ptr % 2 == 0,\r\n    \"Pointer passed to UTF16ToString must be aligned to two bytes!\",\r\n  );\r\n  var endPtr = ptr;\r\n  // TextDecoder needs to know the byte length in advance, it doesn't stop on null terminator by itself.\r\n  // Also, use the length info to avoid running tiny strings through TextDecoder, since .subarray() allocates garbage.\r\n  var idx = endPtr >> 1;\r\n  while (HEAP16[idx]) ++idx;\r\n  endPtr = idx << 1;\r\n\r\n  if (endPtr - ptr > 32 && UTF16Decoder) {\r\n    return UTF16Decoder.decode(HEAPU8.subarray(ptr, endPtr));\r\n  } else {\r\n    var i = 0;\r\n\r\n    var str = \"\";\r\n    while (1) {\r\n      var codeUnit = HEAP16[(ptr + i * 2) >> 1];\r\n      if (codeUnit == 0) return str;\r\n      ++i;\r\n      // fromCharCode constructs a character from a UTF-16 code unit, so we can pass the UTF16 string right through.\r\n      str += String.fromCharCode(codeUnit);\r\n    }\r\n  }\r\n}\r\n\r\n// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',\r\n// null-terminated and encoded in UTF16 form. The copy will require at most str.length*4+2 bytes of space in the HEAP.\r\n// Use the function lengthBytesUTF16() to compute the exact number of bytes (excluding null terminator) that this function will write.\r\n// Parameters:\r\n//   str: the Javascript string to copy.\r\n//   outPtr: Byte address in Emscripten HEAP where to write the string to.\r\n//   maxBytesToWrite: The maximum number of bytes this function can write to the array. This count should include the null\r\n//                    terminator, i.e. if maxBytesToWrite=2, only the null terminator will be written and nothing else.\r\n//                    maxBytesToWrite<2 does not write any bytes to the output, not even the null terminator.\r\n// Returns the number of bytes written, EXCLUDING the null terminator.\r\n\r\nfunction stringToUTF16(str, outPtr, maxBytesToWrite) {\r\n  assert(\r\n    outPtr % 2 == 0,\r\n    \"Pointer passed to stringToUTF16 must be aligned to two bytes!\",\r\n  );\r\n  assert(\r\n    typeof maxBytesToWrite == \"number\",\r\n    \"stringToUTF16(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!\",\r\n  );\r\n  // Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.\r\n  if (maxBytesToWrite === undefined) {\r\n    maxBytesToWrite = 0x7fffffff;\r\n  }\r\n  if (maxBytesToWrite < 2) return 0;\r\n  maxBytesToWrite -= 2; // Null terminator.\r\n  var startPtr = outPtr;\r\n  var numCharsToWrite =\r\n    maxBytesToWrite < str.length * 2 ? maxBytesToWrite / 2 : str.length;\r\n  for (var i = 0; i < numCharsToWrite; ++i) {\r\n    // charCodeAt returns a UTF-16 encoded code unit, so it can be directly written to the HEAP.\r\n    var codeUnit = str.charCodeAt(i); // possibly a lead surrogate\r\n    HEAP16[outPtr >> 1] = codeUnit;\r\n    outPtr += 2;\r\n  }\r\n  // Null-terminate the pointer to the HEAP.\r\n  HEAP16[outPtr >> 1] = 0;\r\n  return outPtr - startPtr;\r\n}\r\n\r\n// Returns the number of bytes the given Javascript string takes if encoded as a UTF16 byte array, EXCLUDING the null terminator byte.\r\n\r\nfunction lengthBytesUTF16(str) {\r\n  return str.length * 2;\r\n}\r\n\r\nfunction UTF32ToString(ptr) {\r\n  assert(\r\n    ptr % 4 == 0,\r\n    \"Pointer passed to UTF32ToString must be aligned to four bytes!\",\r\n  );\r\n  var i = 0;\r\n\r\n  var str = \"\";\r\n  while (1) {\r\n    var utf32 = HEAP32[(ptr + i * 4) >> 2];\r\n    if (utf32 == 0) return str;\r\n    ++i;\r\n    // Gotcha: fromCharCode constructs a character from a UTF-16 encoded code (pair), not from a Unicode code point! So encode the code point to UTF-16 for constructing.\r\n    // See http://unicode.org/faq/utf_bom.html#utf16-3\r\n    if (utf32 >= 0x10000) {\r\n      var ch = utf32 - 0x10000;\r\n      str += String.fromCharCode(0xd800 | (ch >> 10), 0xdc00 | (ch & 0x3ff));\r\n    } else {\r\n      str += String.fromCharCode(utf32);\r\n    }\r\n  }\r\n}\r\n\r\n// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',\r\n// null-terminated and encoded in UTF32 form. The copy will require at most str.length*4+4 bytes of space in the HEAP.\r\n// Use the function lengthBytesUTF32() to compute the exact number of bytes (excluding null terminator) that this function will write.\r\n// Parameters:\r\n//   str: the Javascript string to copy.\r\n//   outPtr: Byte address in Emscripten HEAP where to write the string to.\r\n//   maxBytesToWrite: The maximum number of bytes this function can write to the array. This count should include the null\r\n//                    terminator, i.e. if maxBytesToWrite=4, only the null terminator will be written and nothing else.\r\n//                    maxBytesToWrite<4 does not write any bytes to the output, not even the null terminator.\r\n// Returns the number of bytes written, EXCLUDING the null terminator.\r\n\r\nfunction stringToUTF32(str, outPtr, maxBytesToWrite) {\r\n  assert(\r\n    outPtr % 4 == 0,\r\n    \"Pointer passed to stringToUTF32 must be aligned to four bytes!\",\r\n  );\r\n  assert(\r\n    typeof maxBytesToWrite == \"number\",\r\n    \"stringToUTF32(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!\",\r\n  );\r\n  // Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.\r\n  if (maxBytesToWrite === undefined) {\r\n    maxBytesToWrite = 0x7fffffff;\r\n  }\r\n  if (maxBytesToWrite < 4) return 0;\r\n  var startPtr = outPtr;\r\n  var endPtr = startPtr + maxBytesToWrite - 4;\r\n  for (var i = 0; i < str.length; ++i) {\r\n    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! We must decode the string to UTF-32 to the heap.\r\n    // See http://unicode.org/faq/utf_bom.html#utf16-3\r\n    var codeUnit = str.charCodeAt(i); // possibly a lead surrogate\r\n    if (codeUnit >= 0xd800 && codeUnit <= 0xdfff) {\r\n      var trailSurrogate = str.charCodeAt(++i);\r\n      codeUnit =\r\n        (0x10000 + ((codeUnit & 0x3ff) << 10)) | (trailSurrogate & 0x3ff);\r\n    }\r\n    HEAP32[outPtr >> 2] = codeUnit;\r\n    outPtr += 4;\r\n    if (outPtr + 4 > endPtr) break;\r\n  }\r\n  // Null-terminate the pointer to the HEAP.\r\n  HEAP32[outPtr >> 2] = 0;\r\n  return outPtr - startPtr;\r\n}\r\n\r\n// Returns the number of bytes the given Javascript string takes if encoded as a UTF16 byte array, EXCLUDING the null terminator byte.\r\n\r\nfunction lengthBytesUTF32(str) {\r\n  var len = 0;\r\n  for (var i = 0; i < str.length; ++i) {\r\n    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! We must decode the string to UTF-32 to the heap.\r\n    // See http://unicode.org/faq/utf_bom.html#utf16-3\r\n    var codeUnit = str.charCodeAt(i);\r\n    if (codeUnit >= 0xd800 && codeUnit <= 0xdfff) ++i; // possibly a lead surrogate, so skip over the tail surrogate.\r\n    len += 4;\r\n  }\r\n\r\n  return len;\r\n}\r\n\r\n// Allocate heap space for a JS string, and write it there.\r\n// It is the responsibility of the caller to free() that memory.\r\nfunction allocateUTF8(str) {\r\n  var size = lengthBytesUTF8(str) + 1;\r\n  var ret = _malloc(size);\r\n  if (ret) stringToUTF8Array(str, HEAP8, ret, size);\r\n  return ret;\r\n}\r\n\r\n// Allocate stack space for a JS string, and write it there.\r\nfunction allocateUTF8OnStack(str) {\r\n  var size = lengthBytesUTF8(str) + 1;\r\n  var ret = stackAlloc(size);\r\n  stringToUTF8Array(str, HEAP8, ret, size);\r\n  return ret;\r\n}\r\n\r\n// Deprecated: This function should not be called because it is unsafe and does not provide\r\n// a maximum length limit of how many bytes it is allowed to write. Prefer calling the\r\n// function stringToUTF8Array() instead, which takes in a maximum length that can be used\r\n// to be secure from out of bounds writes.\r\n/** @deprecated */\r\nfunction writeStringToMemory(string, buffer, dontAddNull) {\r\n  warnOnce(\r\n    \"writeStringToMemory is deprecated and should not be called! Use stringToUTF8() instead!\",\r\n  );\r\n\r\n  var /** @type {number} */ lastChar, /** @type {number} */ end;\r\n  if (dontAddNull) {\r\n    // stringToUTF8Array always appends null. If we don't want to do that, remember the\r\n    // character that existed at the location where the null will be placed, and restore\r\n    // that after the write (below).\r\n    end = buffer + lengthBytesUTF8(string);\r\n    lastChar = HEAP8[end];\r\n  }\r\n  stringToUTF8(string, buffer, Infinity);\r\n  if (dontAddNull) HEAP8[end] = lastChar; // Restore the value under the null character.\r\n}\r\n\r\nfunction writeArrayToMemory(array, buffer) {\r\n  assert(\r\n    array.length >= 0,\r\n    \"writeArrayToMemory array must have a length (should be an array or typed array)\",\r\n  );\r\n  HEAP8.set(array, buffer);\r\n}\r\n\r\nfunction writeAsciiToMemory(str, buffer, dontAddNull) {\r\n  for (var i = 0; i < str.length; ++i) {\r\n    assert((str.charCodeAt(i) === str.charCodeAt(i)) & 0xff);\r\n    HEAP8[buffer++ >> 0] = str.charCodeAt(i);\r\n  }\r\n  // Null-terminate the pointer to the HEAP.\r\n  if (!dontAddNull) HEAP8[buffer >> 0] = 0;\r\n}\r\n\r\nfunction demangle(func) {\r\n  warnOnce(\r\n    \"warning: build with  -s DEMANGLE_SUPPORT=1  to link in libcxxabi demangling\",\r\n  );\r\n  return func;\r\n}\r\n\r\nfunction demangleAll(text) {\r\n  var regex = /__Z[\\w\\d_]+/g;\r\n  return text.replace(regex, function (x) {\r\n    var y = demangle(x);\r\n    return x === y ? x : y + \" [\" + x + \"]\";\r\n  });\r\n}\r\n\r\nfunction jsStackTrace() {\r\n  var err = new Error();\r\n  if (!err.stack) {\r\n    // IE10+ special cases: It does have callstack info, but it is only populated if an Error object is thrown,\r\n    // so try that as a special-case.\r\n    try {\r\n      throw new Error(0);\r\n    } catch (e) {\r\n      err = e;\r\n    }\r\n    if (!err.stack) {\r\n      return \"(no stack trace available)\";\r\n    }\r\n  }\r\n  return err.stack.toString();\r\n}\r\n\r\nfunction stackTrace() {\r\n  var js = jsStackTrace();\r\n  if (Module[\"extraStackTrace\"]) js += \"\\n\" + Module[\"extraStackTrace\"]();\r\n  return demangleAll(js);\r\n}\r\n\r\n// Memory management\r\n\r\nvar PAGE_SIZE = 16384;\r\nvar WASM_PAGE_SIZE = 65536;\r\nvar ASMJS_PAGE_SIZE = 16777216;\r\n\r\nfunction alignUp(x, multiple) {\r\n  if (x % multiple > 0) {\r\n    x += multiple - (x % multiple);\r\n  }\r\n  return x;\r\n}\r\n\r\nvar HEAP,\r\n  /** @type {ArrayBuffer} */\r\n  buffer,\r\n  /** @type {Int8Array} */\r\n  HEAP8,\r\n  /** @type {Uint8Array} */\r\n  HEAPU8,\r\n  /** @type {Int16Array} */\r\n  HEAP16,\r\n  /** @type {Uint16Array} */\r\n  HEAPU16,\r\n  /** @type {Int32Array} */\r\n  HEAP32,\r\n  /** @type {Uint32Array} */\r\n  HEAPU32,\r\n  /** @type {Float32Array} */\r\n  HEAPF32,\r\n  /** @type {Float64Array} */\r\n  HEAPF64;\r\n\r\nfunction updateGlobalBuffer(buf) {\r\n  Module[\"buffer\"] = buffer = buf;\r\n}\r\n\r\nfunction updateGlobalBufferViews() {\r\n  Module[\"HEAP8\"] = HEAP8 = new Int8Array(buffer);\r\n  Module[\"HEAP16\"] = HEAP16 = new Int16Array(buffer);\r\n  Module[\"HEAP32\"] = HEAP32 = new Int32Array(buffer);\r\n  Module[\"HEAPU8\"] = HEAPU8 = new Uint8Array(buffer);\r\n  Module[\"HEAPU16\"] = HEAPU16 = new Uint16Array(buffer);\r\n  Module[\"HEAPU32\"] = HEAPU32 = new Uint32Array(buffer);\r\n  Module[\"HEAPF32\"] = HEAPF32 = new Float32Array(buffer);\r\n  Module[\"HEAPF64\"] = HEAPF64 = new Float64Array(buffer);\r\n}\r\n\r\nvar STATIC_BASE = 1024,\r\n  STACK_BASE = 10348944,\r\n  STACKTOP = STACK_BASE,\r\n  STACK_MAX = 15591824,\r\n  DYNAMIC_BASE = 15591824,\r\n  DYNAMICTOP_PTR = 10348688;\r\n\r\nassert(STACK_BASE % 16 === 0, \"stack must start aligned\");\r\nassert(DYNAMIC_BASE % 16 === 0, \"heap must start aligned\");\r\n\r\nvar TOTAL_STACK = 5242880;\r\nif (Module[\"TOTAL_STACK\"])\r\n  assert(\r\n    TOTAL_STACK === Module[\"TOTAL_STACK\"],\r\n    \"the stack size can no longer be determined at runtime\",\r\n  );\r\n\r\nvar TOTAL_MEMORY = Module[\"TOTAL_MEMORY\"] || 16777216;\r\nif (TOTAL_MEMORY < TOTAL_STACK)\r\n  err(\r\n    \"TOTAL_MEMORY should be larger than TOTAL_STACK, was \" +\r\n      TOTAL_MEMORY +\r\n      \"! (TOTAL_STACK=\" +\r\n      TOTAL_STACK +\r\n      \")\",\r\n  );\r\n\r\n// Initialize the runtime's memory\r\n// check for full engine support (use string 'subarray' to avoid closure compiler confusion)\r\nassert(\r\n  typeof Int32Array !== \"undefined\" &&\r\n    typeof Float64Array !== \"undefined\" &&\r\n    Int32Array.prototype.subarray !== undefined &&\r\n    Int32Array.prototype.set !== undefined,\r\n  \"JS engine does not provide full typed array support\",\r\n);\r\n\r\n// Use a provided buffer, if there is one, or else allocate a new one\r\nif (Module[\"buffer\"]) {\r\n  buffer = Module[\"buffer\"];\r\n  assert(\r\n    buffer.byteLength === TOTAL_MEMORY,\r\n    \"provided buffer should be \" +\r\n      TOTAL_MEMORY +\r\n      \" bytes, but it is \" +\r\n      buffer.byteLength,\r\n  );\r\n} else {\r\n  // Use a WebAssembly memory where available\r\n  if (\r\n    typeof WebAssembly === \"object\" &&\r\n    typeof WebAssembly.Memory === \"function\"\r\n  ) {\r\n    assert(TOTAL_MEMORY % WASM_PAGE_SIZE === 0);\r\n    wasmMemory = new WebAssembly.Memory({\r\n      initial: TOTAL_MEMORY / WASM_PAGE_SIZE,\r\n    });\r\n    buffer = wasmMemory.buffer;\r\n  } else {\r\n    buffer = new ArrayBuffer(TOTAL_MEMORY);\r\n  }\r\n  assert(buffer.byteLength === TOTAL_MEMORY);\r\n  Module[\"buffer\"] = buffer;\r\n}\r\nupdateGlobalBufferViews();\r\n\r\nHEAP32[DYNAMICTOP_PTR >> 2] = DYNAMIC_BASE;\r\n\r\n// Initializes the stack cookie. Called at the startup of main and at the startup of each thread in pthreads mode.\r\nfunction writeStackCookie() {\r\n  assert((STACK_MAX & 3) == 0);\r\n  HEAPU32[(STACK_MAX >> 2) - 1] = 0x02135467;\r\n  HEAPU32[(STACK_MAX >> 2) - 2] = 0x89bacdfe;\r\n}\r\n\r\nfunction checkStackCookie() {\r\n  if (\r\n    HEAPU32[(STACK_MAX >> 2) - 1] != 0x02135467 ||\r\n    HEAPU32[(STACK_MAX >> 2) - 2] != 0x89bacdfe\r\n  ) {\r\n    abort(\r\n      \"Stack overflow! Stack cookie has been overwritten, expected hex dwords 0x89BACDFE and 0x02135467, but received 0x\" +\r\n        HEAPU32[(STACK_MAX >> 2) - 2].toString(16) +\r\n        \" \" +\r\n        HEAPU32[(STACK_MAX >> 2) - 1].toString(16),\r\n    );\r\n  }\r\n  // Also test the global address 0 for integrity.\r\n  if (HEAP32[0] !== 0x63736d65 /* 'emsc' */)\r\n    throw \"Runtime error: The application has corrupted its heap memory area (address zero)!\";\r\n}\r\n\r\nfunction abortStackOverflow(allocSize) {\r\n  abort(\r\n    \"Stack overflow! Attempted to allocate \" +\r\n      allocSize +\r\n      \" bytes on the stack, but stack has only \" +\r\n      (STACK_MAX - stackSave() + allocSize) +\r\n      \" bytes available!\",\r\n  );\r\n}\r\n\r\nHEAP32[0] = 0x63736d65; /* 'emsc' */\r\n\r\n// Endianness check (note: assumes compiler arch was little-endian)\r\nHEAP16[1] = 0x6373;\r\nif (HEAPU8[2] !== 0x73 || HEAPU8[3] !== 0x63)\r\n  throw \"Runtime error: expected the system to be little-endian!\";\r\n\r\nfunction callRuntimeCallbacks(callbacks) {\r\n  while (callbacks.length > 0) {\r\n    var callback = callbacks.shift();\r\n    if (typeof callback == \"function\") {\r\n      callback();\r\n      continue;\r\n    }\r\n    var func = callback.func;\r\n    if (typeof func === \"number\") {\r\n      if (callback.arg === undefined) {\r\n        Module[\"dynCall_v\"](func);\r\n      } else {\r\n        Module[\"dynCall_vi\"](func, callback.arg);\r\n      }\r\n    } else {\r\n      func(callback.arg === undefined ? null : callback.arg);\r\n    }\r\n  }\r\n}\r\n\r\nvar __ATPRERUN__ = []; // functions called before the runtime is initialized\r\nvar __ATINIT__ = []; // functions called during startup\r\nvar __ATMAIN__ = []; // functions called when main() is to be run\r\nvar __ATEXIT__ = []; // functions called during shutdown\r\nvar __ATPOSTRUN__ = []; // functions called after the main() is called\r\n\r\nvar runtimeInitialized = false;\r\nvar runtimeExited = false;\r\n\r\nfunction preRun() {\r\n  // compatibility - merge in anything from Module['preRun'] at this time\r\n  if (Module[\"preRun\"]) {\r\n    if (typeof Module[\"preRun\"] == \"function\")\r\n      Module[\"preRun\"] = [Module[\"preRun\"]];\r\n    while (Module[\"preRun\"].length) {\r\n      addOnPreRun(Module[\"preRun\"].shift());\r\n    }\r\n  }\r\n  callRuntimeCallbacks(__ATPRERUN__);\r\n}\r\n\r\nfunction ensureInitRuntime() {\r\n  checkStackCookie();\r\n  if (runtimeInitialized) return;\r\n  runtimeInitialized = true;\r\n  callRuntimeCallbacks(__ATINIT__);\r\n}\r\n\r\nfunction preMain() {\r\n  checkStackCookie();\r\n  callRuntimeCallbacks(__ATMAIN__);\r\n}\r\n\r\nfunction exitRuntime() {\r\n  checkStackCookie();\r\n  callRuntimeCallbacks(__ATEXIT__);\r\n  runtimeExited = true;\r\n}\r\n\r\nfunction postRun() {\r\n  checkStackCookie();\r\n  // compatibility - merge in anything from Module['postRun'] at this time\r\n  if (Module[\"postRun\"]) {\r\n    if (typeof Module[\"postRun\"] == \"function\")\r\n      Module[\"postRun\"] = [Module[\"postRun\"]];\r\n    while (Module[\"postRun\"].length) {\r\n      addOnPostRun(Module[\"postRun\"].shift());\r\n    }\r\n  }\r\n  callRuntimeCallbacks(__ATPOSTRUN__);\r\n}\r\n\r\nfunction addOnPreRun(cb) {\r\n  __ATPRERUN__.unshift(cb);\r\n}\r\n\r\nfunction addOnInit(cb) {\r\n  __ATINIT__.unshift(cb);\r\n}\r\n\r\nfunction addOnPreMain(cb) {\r\n  __ATMAIN__.unshift(cb);\r\n}\r\n\r\nfunction addOnExit(cb) {\r\n  __ATEXIT__.unshift(cb);\r\n}\r\n\r\nfunction addOnPostRun(cb) {\r\n  __ATPOSTRUN__.unshift(cb);\r\n}\r\n\r\nfunction unSign(value, bits, ignore) {\r\n  if (value >= 0) {\r\n    return value;\r\n  }\r\n  return bits <= 32\r\n    ? 2 * Math.abs(1 << (bits - 1)) + value // Need some trickery, since if bits == 32, we are right at the limit of the bits JS uses in bitshifts\r\n    : Math.pow(2, bits) + value;\r\n}\r\n\r\nfunction reSign(value, bits, ignore) {\r\n  if (value <= 0) {\r\n    return value;\r\n  }\r\n  var half =\r\n    bits <= 32\r\n      ? Math.abs(1 << (bits - 1)) // abs is needed if bits == 32\r\n      : Math.pow(2, bits - 1);\r\n  if (value >= half && (bits <= 32 || value > half)) {\r\n    // for huge values, we can hit the precision limit and always get true here. so don't do that\r\n    // but, in general there is no perfect solution here. With 64-bit ints, we get rounding and errors\r\n    // TODO: In i64 mode 1, resign the two parts separately and safely\r\n    value = -2 * half + value; // Cannot bitshift half, as it may be at the limit of the bits JS uses in bitshifts\r\n  }\r\n  return value;\r\n}\r\n\r\nassert(\r\n  Math.imul,\r\n  \"This browser does not support Math.imul(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill\",\r\n);\r\nassert(\r\n  Math.fround,\r\n  \"This browser does not support Math.fround(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill\",\r\n);\r\nassert(\r\n  Math.clz32,\r\n  \"This browser does not support Math.clz32(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill\",\r\n);\r\nassert(\r\n  Math.trunc,\r\n  \"This browser does not support Math.trunc(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill\",\r\n);\r\n\r\nvar Math_abs = Math.abs;\r\nvar Math_cos = Math.cos;\r\nvar Math_sin = Math.sin;\r\nvar Math_tan = Math.tan;\r\nvar Math_acos = Math.acos;\r\nvar Math_asin = Math.asin;\r\nvar Math_atan = Math.atan;\r\nvar Math_atan2 = Math.atan2;\r\nvar Math_exp = Math.exp;\r\nvar Math_log = Math.log;\r\nvar Math_sqrt = Math.sqrt;\r\nvar Math_ceil = Math.ceil;\r\nvar Math_floor = Math.floor;\r\nvar Math_pow = Math.pow;\r\nvar Math_imul = Math.imul;\r\nvar Math_fround = Math.fround;\r\nvar Math_round = Math.round;\r\nvar Math_min = Math.min;\r\nvar Math_max = Math.max;\r\nvar Math_clz32 = Math.clz32;\r\nvar Math_trunc = Math.trunc;\r\n\r\n// A counter of dependencies for calling run(). If we need to\r\n// do asynchronous work before running, increment this and\r\n// decrement it. Incrementing must happen in a place like\r\n// Module.preRun (used by emcc to add file preloading).\r\n// Note that you can add dependencies in preRun, even though\r\n// it happens right before run - run will be postponed until\r\n// the dependencies are met.\r\nvar runDependencies = 0;\r\nvar runDependencyWatcher = null;\r\nvar dependenciesFulfilled = null; // overridden to take different actions when all run dependencies are fulfilled\r\nvar runDependencyTracking = {};\r\n\r\nfunction getUniqueRunDependency(id) {\r\n  var orig = id;\r\n  while (1) {\r\n    if (!runDependencyTracking[id]) return id;\r\n    id = orig + Math.random();\r\n  }\r\n  return id;\r\n}\r\n\r\nfunction addRunDependency(id) {\r\n  runDependencies++;\r\n  if (Module[\"monitorRunDependencies\"]) {\r\n    Module[\"monitorRunDependencies\"](runDependencies);\r\n  }\r\n  if (id) {\r\n    assert(!runDependencyTracking[id]);\r\n    runDependencyTracking[id] = 1;\r\n    if (runDependencyWatcher === null && typeof setInterval !== \"undefined\") {\r\n      // Check for missing dependencies every few seconds\r\n      runDependencyWatcher = setInterval(function () {\r\n        if (ABORT) {\r\n          clearInterval(runDependencyWatcher);\r\n          runDependencyWatcher = null;\r\n          return;\r\n        }\r\n        var shown = false;\r\n        for (var dep in runDependencyTracking) {\r\n          if (!shown) {\r\n            shown = true;\r\n            err(\"still waiting on run dependencies:\");\r\n          }\r\n          err(\"dependency: \" + dep);\r\n        }\r\n        if (shown) {\r\n          err(\"(end of list)\");\r\n        }\r\n      }, 10000);\r\n    }\r\n  } else {\r\n    err(\"warning: run dependency added without ID\");\r\n  }\r\n}\r\n\r\nfunction removeRunDependency(id) {\r\n  runDependencies--;\r\n  if (Module[\"monitorRunDependencies\"]) {\r\n    Module[\"monitorRunDependencies\"](runDependencies);\r\n  }\r\n  if (id) {\r\n    assert(runDependencyTracking[id]);\r\n    delete runDependencyTracking[id];\r\n  } else {\r\n    err(\"warning: run dependency removed without ID\");\r\n  }\r\n  if (runDependencies == 0) {\r\n    if (runDependencyWatcher !== null) {\r\n      clearInterval(runDependencyWatcher);\r\n      runDependencyWatcher = null;\r\n    }\r\n    if (dependenciesFulfilled) {\r\n      var callback = dependenciesFulfilled;\r\n      dependenciesFulfilled = null;\r\n      callback(); // can add another dependenciesFulfilled\r\n    }\r\n  }\r\n}\r\n\r\nModule[\"preloadedImages\"] = {}; // maps url to image data\r\nModule[\"preloadedAudios\"] = {}; // maps url to audio data\r\n\r\nvar memoryInitializer = null;\r\n\r\n// Copyright 2017 The Emscripten Authors.  All rights reserved.\r\n// Emscripten is available under two separate licenses, the MIT license and the\r\n// University of Illinois/NCSA Open Source License.  Both these licenses can be\r\n// found in the LICENSE file.\r\n\r\n// Prefix of data URIs emitted by SINGLE_FILE and related options.\r\nvar dataURIPrefix = \"data:application/octet-stream;base64,\";\r\n\r\n// Indicates whether filename is a base64 data URI.\r\nfunction isDataURI(filename) {\r\n  if (!filename.startsWith || !filename.indexOf) {\r\n    return false;\r\n  }\r\n  return String.prototype.startsWith\r\n    ? filename.startsWith(dataURIPrefix)\r\n    : filename.indexOf(dataURIPrefix) === 0;\r\n}\r\n\r\nvar wasmBinaryFile = await import(\"./gs.wasm?url\");\r\n// if (!isDataURI(wasmBinaryFile)) {\r\n//   wasmBinaryFile = locateFile(wasmBinaryFile);\r\n// }\r\n\r\nfunction getBinary() {\r\n  try {\r\n    if (Module[\"wasmBinary\"]) {\r\n      return new Uint8Array(Module[\"wasmBinary\"]);\r\n    }\r\n    if (Module[\"readBinary\"]) {\r\n      return Module[\"readBinary\"](wasmBinaryFile);\r\n    } else {\r\n      throw \"both async and sync fetching of the wasm failed\";\r\n    }\r\n  } catch (err) {\r\n    abort(err);\r\n  }\r\n}\r\n\r\nfunction getBinaryPromise() {\r\n  // if we don't have the binary yet, and have the Fetch api, use that\r\n  // in some environments, like Electron's render process, Fetch api may be present, but have a different context than expected, let's only use it on the Web\r\n  if (\r\n    !Module[\"wasmBinary\"] &&\r\n    (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) &&\r\n    typeof fetch === \"function\"\r\n  ) {\r\n    return fetch(wasmBinaryFile, { credentials: \"same-origin\" })\r\n      .then(function (response) {\r\n        if (!response[\"ok\"]) {\r\n          throw \"failed to load wasm binary file at '\" + wasmBinaryFile + \"'\";\r\n        }\r\n        return response[\"arrayBuffer\"]();\r\n      })\r\n      .catch(function () {\r\n        return getBinary();\r\n      });\r\n  }\r\n  // Otherwise, getBinary should be able to get it synchronously\r\n  return new Promise(function (resolve, reject) {\r\n    resolve(getBinary());\r\n  });\r\n}\r\n\r\n// Create the wasm instance.\r\n// Receives the wasm imports, returns the exports.\r\nfunction createWasm(env) {\r\n  // prepare imports\r\n  var info = {\r\n    env: env,\r\n    global: {\r\n      NaN: NaN,\r\n      Infinity: Infinity,\r\n    },\r\n    \"global.Math\": Math,\r\n    asm2wasm: asm2wasmImports,\r\n  };\r\n  // Load the wasm module and create an instance of using native support in the JS engine.\r\n  // handle a generated wasm instance, receiving its exports and\r\n  // performing other necessary setup\r\n  function receiveInstance(instance, module) {\r\n    var exports = instance.exports;\r\n    Module[\"asm\"] = exports;\r\n    removeRunDependency(\"wasm-instantiate\");\r\n  }\r\n\r\n  addRunDependency(\"wasm-instantiate\");\r\n\r\n  // User shell pages can write their own Module.instantiateWasm = function(imports, successCallback) callback\r\n  // to manually instantiate the Wasm module themselves. This allows pages to run the instantiation parallel\r\n  // to any other async startup actions they are performing.\r\n  if (Module[\"instantiateWasm\"]) {\r\n    try {\r\n      return Module[\"instantiateWasm\"](info, receiveInstance);\r\n    } catch (e) {\r\n      err(\"Module.instantiateWasm callback failed with error: \" + e);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  // Async compilation can be confusing when an error on the page overwrites Module\r\n  // (for example, if the order of elements is wrong, and the one defining Module is\r\n  // later), so we save Module and check it later.\r\n  var trueModule = Module;\r\n\r\n  function receiveInstantiatedSource(output) {\r\n    // 'output' is a WebAssemblyInstantiatedSource object which has both the module and instance.\r\n    // receiveInstance() will swap in the exports (to Module.asm) so they can be called\r\n    assert(\r\n      Module === trueModule,\r\n      \"the Module object should not be replaced during async compilation - perhaps the order of HTML elements is wrong?\",\r\n    );\r\n    trueModule = null;\r\n    // TODO: Due to Closure regression https://github.com/google/closure-compiler/issues/3193, the above line no longer optimizes out down to the following line.\r\n    // When the regression is fixed, can restore the above USE_PTHREADS-enabled path.\r\n    receiveInstance(output[\"instance\"]);\r\n  }\r\n\r\n  function instantiateArrayBuffer(receiver) {\r\n    getBinaryPromise()\r\n      .then(function (binary) {\r\n        return WebAssembly.instantiate(binary, info);\r\n      })\r\n      .then(receiver, function (reason) {\r\n        err(\"failed to asynchronously prepare wasm: \" + reason);\r\n        abort(reason);\r\n      });\r\n  }\r\n\r\n  // Prefer streaming instantiation if available.\r\n  if (\r\n    !Module[\"wasmBinary\"] &&\r\n    typeof WebAssembly.instantiateStreaming === \"function\" &&\r\n    !isDataURI(wasmBinaryFile) &&\r\n    typeof fetch === \"function\"\r\n  ) {\r\n    WebAssembly.instantiateStreaming(\r\n      fetch(wasmBinaryFile.default, { credentials: \"same-origin\" }),\r\n      info,\r\n    ).then(receiveInstantiatedSource, function (reason) {\r\n      // We expect the most common failure cause to be a bad MIME type for the binary,\r\n      // in which case falling back to ArrayBuffer instantiation should work.\r\n      err(\"wasm streaming compile failed: \" + reason);\r\n      err(\"falling back to ArrayBuffer instantiation\");\r\n      instantiateArrayBuffer(receiveInstantiatedSource);\r\n    });\r\n  } else {\r\n    instantiateArrayBuffer(receiveInstantiatedSource);\r\n  }\r\n  return {}; // no exports yet; we'll fill them in later\r\n}\r\n\r\n// Provide an \"asm.js function\" for the application, called to \"link\" the asm.js module. We instantiate\r\n// the wasm module at that time, and it receives imports and provides exports and so forth, the app\r\n// doesn't need to care that it is wasm or asm.js.\r\n\r\nModule[\"asm\"] = function (global, env, providedBuffer) {\r\n  // memory was already allocated (so js could use the buffer)\r\n  env[\"memory\"] = wasmMemory;\r\n  // import table\r\n  env[\"table\"] = wasmTable = new WebAssembly.Table({\r\n    initial: 393218,\r\n    maximum: 393218,\r\n    element: \"anyfunc\",\r\n  });\r\n  env[\"__memory_base\"] = 1024; // tell the memory segments where to place themselves\r\n  env[\"__table_base\"] = 0; // table starts at 0 by default (even in dynamic linking, for the main module)\r\n\r\n  var exports = createWasm(env);\r\n  assert(exports, \"binaryen setup failed (no wasm support?)\");\r\n  return exports;\r\n};\r\n\r\n// === Body ===\r\n\r\nvar ASM_CONSTS = [];\r\n\r\n// STATICTOP = STATIC_BASE + 10347920;\r\n/* global initializers */\r\n__ATINIT__.push({\r\n  func: function () {\r\n    ___emscripten_environ_constructor();\r\n  },\r\n});\r\n\r\n/* no memory initializer */\r\nvar tempDoublePtr = 10348928;\r\nassert(tempDoublePtr % 8 == 0);\r\n\r\nfunction copyTempFloat(ptr) {\r\n  // functions, because inlining this code increases code size too much\r\n  HEAP8[tempDoublePtr] = HEAP8[ptr];\r\n  HEAP8[tempDoublePtr + 1] = HEAP8[ptr + 1];\r\n  HEAP8[tempDoublePtr + 2] = HEAP8[ptr + 2];\r\n  HEAP8[tempDoublePtr + 3] = HEAP8[ptr + 3];\r\n}\r\n\r\nfunction copyTempDouble(ptr) {\r\n  HEAP8[tempDoublePtr] = HEAP8[ptr];\r\n  HEAP8[tempDoublePtr + 1] = HEAP8[ptr + 1];\r\n  HEAP8[tempDoublePtr + 2] = HEAP8[ptr + 2];\r\n  HEAP8[tempDoublePtr + 3] = HEAP8[ptr + 3];\r\n  HEAP8[tempDoublePtr + 4] = HEAP8[ptr + 4];\r\n  HEAP8[tempDoublePtr + 5] = HEAP8[ptr + 5];\r\n  HEAP8[tempDoublePtr + 6] = HEAP8[ptr + 6];\r\n  HEAP8[tempDoublePtr + 7] = HEAP8[ptr + 7];\r\n}\r\n\r\n// {{PRE_LIBRARY}}\r\n\r\nfunction ___assert_fail(condition, filename, line, func) {\r\n  abort(\r\n    \"Assertion failed: \" +\r\n      UTF8ToString(condition) +\r\n      \", at: \" +\r\n      [\r\n        filename ? UTF8ToString(filename) : \"unknown filename\",\r\n        line,\r\n        func ? UTF8ToString(func) : \"unknown function\",\r\n      ],\r\n  );\r\n}\r\n\r\nvar ENV = {};\r\n\r\nfunction ___buildEnvironment(environ) {\r\n  // WARNING: Arbitrary limit!\r\n  var MAX_ENV_VALUES = 64;\r\n  var TOTAL_ENV_SIZE = 1024;\r\n\r\n  // Statically allocate memory for the environment.\r\n  var poolPtr;\r\n  var envPtr;\r\n  if (!___buildEnvironment.called) {\r\n    ___buildEnvironment.called = true;\r\n    // Set default values. Use string keys for Closure Compiler compatibility.\r\n    ENV[\"USER\"] = ENV[\"LOGNAME\"] = \"web_user\";\r\n    ENV[\"PATH\"] = \"/\";\r\n    ENV[\"PWD\"] = \"/\";\r\n    ENV[\"HOME\"] = \"/home/web_user\";\r\n    ENV[\"LANG\"] = \"C.UTF-8\";\r\n    ENV[\"_\"] = Module[\"thisProgram\"];\r\n    // Allocate memory.\r\n    poolPtr = getMemory(TOTAL_ENV_SIZE);\r\n    envPtr = getMemory(MAX_ENV_VALUES * 4);\r\n    HEAP32[envPtr >> 2] = poolPtr;\r\n    HEAP32[environ >> 2] = envPtr;\r\n  } else {\r\n    envPtr = HEAP32[environ >> 2];\r\n    poolPtr = HEAP32[envPtr >> 2];\r\n  }\r\n\r\n  // Collect key=value lines.\r\n  var strings = [];\r\n  var totalSize = 0;\r\n  for (var key in ENV) {\r\n    if (typeof ENV[key] === \"string\") {\r\n      var line = key + \"=\" + ENV[key];\r\n      strings.push(line);\r\n      totalSize += line.length;\r\n    }\r\n  }\r\n  if (totalSize > TOTAL_ENV_SIZE) {\r\n    throw new Error(\"Environment size exceeded TOTAL_ENV_SIZE!\");\r\n  }\r\n\r\n  // Make new.\r\n  var ptrSize = 4;\r\n  for (var i = 0; i < strings.length; i++) {\r\n    var line = strings[i];\r\n    writeAsciiToMemory(line, poolPtr);\r\n    HEAP32[(envPtr + i * ptrSize) >> 2] = poolPtr;\r\n    poolPtr += line.length + 1;\r\n  }\r\n  HEAP32[(envPtr + strings.length * ptrSize) >> 2] = 0;\r\n}\r\n\r\nfunction _emscripten_get_now() {\r\n  abort();\r\n}\r\n\r\nfunction _emscripten_get_now_is_monotonic() {\r\n  // return whether emscripten_get_now is guaranteed monotonic; the Date.now\r\n  // implementation is not :(\r\n  return (\r\n    ENVIRONMENT_IS_NODE ||\r\n    typeof dateNow !== \"undefined\" ||\r\n    ((ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) &&\r\n      self[\"performance\"] &&\r\n      self[\"performance\"][\"now\"])\r\n  );\r\n}\r\n\r\nfunction ___setErrNo(value) {\r\n  if (Module[\"___errno_location\"])\r\n    HEAP32[Module[\"___errno_location\"]() >> 2] = value;\r\n  else err(\"failed to set errno from JS\");\r\n  return value;\r\n}\r\n\r\nfunction _clock_gettime(clk_id, tp) {\r\n  // int clock_gettime(clockid_t clk_id, struct timespec *tp);\r\n  var now;\r\n  if (clk_id === 0) {\r\n    now = Date.now();\r\n  } else if (clk_id === 1 && _emscripten_get_now_is_monotonic()) {\r\n    now = _emscripten_get_now();\r\n  } else {\r\n    ___setErrNo(22);\r\n    return -1;\r\n  }\r\n  HEAP32[tp >> 2] = (now / 1000) | 0; // seconds\r\n  HEAP32[(tp + 4) >> 2] = ((now % 1000) * 1000 * 1000) | 0; // nanoseconds\r\n  return 0;\r\n}\r\n\r\nfunction ___clock_gettime(\r\n  a0,\r\n  a1,\r\n  /*``*/\r\n) {\r\n  return _clock_gettime(a0, a1);\r\n}\r\n\r\nfunction ___lock() {}\r\n\r\nfunction ___map_file(pathname, size) {\r\n  ___setErrNo(1);\r\n  return -1;\r\n}\r\n\r\nvar PATH = {\r\n  splitPath: function (filename) {\r\n    var splitPathRe =\r\n      /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\r\n    return splitPathRe.exec(filename).slice(1);\r\n  },\r\n  normalizeArray: function (parts, allowAboveRoot) {\r\n    // if the path tries to go above the root, `up` ends up > 0\r\n    var up = 0;\r\n    for (var i = parts.length - 1; i >= 0; i--) {\r\n      var last = parts[i];\r\n      if (last === \".\") {\r\n        parts.splice(i, 1);\r\n      } else if (last === \"..\") {\r\n        parts.splice(i, 1);\r\n        up++;\r\n      } else if (up) {\r\n        parts.splice(i, 1);\r\n        up--;\r\n      }\r\n    }\r\n    // if the path is allowed to go above the root, restore leading ..s\r\n    if (allowAboveRoot) {\r\n      for (; up; up--) {\r\n        parts.unshift(\"..\");\r\n      }\r\n    }\r\n    return parts;\r\n  },\r\n  normalize: function (path) {\r\n    var isAbsolute = path.charAt(0) === \"/\",\r\n      trailingSlash = path.substr(-1) === \"/\";\r\n    // Normalize the path\r\n    path = PATH.normalizeArray(\r\n      path.split(\"/\").filter(function (p) {\r\n        return !!p;\r\n      }),\r\n      !isAbsolute,\r\n    ).join(\"/\");\r\n    if (!path && !isAbsolute) {\r\n      path = \".\";\r\n    }\r\n    if (path && trailingSlash) {\r\n      path += \"/\";\r\n    }\r\n    return (isAbsolute ? \"/\" : \"\") + path;\r\n  },\r\n  dirname: function (path) {\r\n    var result = PATH.splitPath(path),\r\n      root = result[0],\r\n      dir = result[1];\r\n    if (!root && !dir) {\r\n      // No dirname whatsoever\r\n      return \".\";\r\n    }\r\n    if (dir) {\r\n      // It has a dirname, strip trailing slash\r\n      dir = dir.substr(0, dir.length - 1);\r\n    }\r\n    return root + dir;\r\n  },\r\n  basename: function (path) {\r\n    // EMSCRIPTEN return '/'' for '/', not an empty string\r\n    if (path === \"/\") return \"/\";\r\n    var lastSlash = path.lastIndexOf(\"/\");\r\n    if (lastSlash === -1) return path;\r\n    return path.substr(lastSlash + 1);\r\n  },\r\n  extname: function (path) {\r\n    return PATH.splitPath(path)[3];\r\n  },\r\n  join: function () {\r\n    var paths = Array.prototype.slice.call(arguments, 0);\r\n    return PATH.normalize(paths.join(\"/\"));\r\n  },\r\n  join2: function (l, r) {\r\n    return PATH.normalize(l + \"/\" + r);\r\n  },\r\n  resolve: function () {\r\n    var resolvedPath = \"\",\r\n      resolvedAbsolute = false;\r\n    for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\r\n      var path = i >= 0 ? arguments[i] : FS.cwd();\r\n      // Skip empty and invalid entries\r\n      if (typeof path !== \"string\") {\r\n        throw new TypeError(\"Arguments to path.resolve must be strings\");\r\n      } else if (!path) {\r\n        return \"\"; // an invalid portion invalidates the whole thing\r\n      }\r\n      resolvedPath = path + \"/\" + resolvedPath;\r\n      resolvedAbsolute = path.charAt(0) === \"/\";\r\n    }\r\n    // At this point the path should be resolved to a full absolute path, but\r\n    // handle relative paths to be safe (might happen when process.cwd() fails)\r\n    resolvedPath = PATH.normalizeArray(\r\n      resolvedPath.split(\"/\").filter(function (p) {\r\n        return !!p;\r\n      }),\r\n      !resolvedAbsolute,\r\n    ).join(\"/\");\r\n    return (resolvedAbsolute ? \"/\" : \"\") + resolvedPath || \".\";\r\n  },\r\n  relative: function (from, to) {\r\n    from = PATH.resolve(from).substr(1);\r\n    to = PATH.resolve(to).substr(1);\r\n\r\n    function trim(arr) {\r\n      var start = 0;\r\n      for (; start < arr.length; start++) {\r\n        if (arr[start] !== \"\") break;\r\n      }\r\n      var end = arr.length - 1;\r\n      for (; end >= 0; end--) {\r\n        if (arr[end] !== \"\") break;\r\n      }\r\n      if (start > end) return [];\r\n      return arr.slice(start, end - start + 1);\r\n    }\r\n\r\n    var fromParts = trim(from.split(\"/\"));\r\n    var toParts = trim(to.split(\"/\"));\r\n    var length = Math.min(fromParts.length, toParts.length);\r\n    var samePartsLength = length;\r\n    for (var i = 0; i < length; i++) {\r\n      if (fromParts[i] !== toParts[i]) {\r\n        samePartsLength = i;\r\n        break;\r\n      }\r\n    }\r\n    var outputParts = [];\r\n    for (var i = samePartsLength; i < fromParts.length; i++) {\r\n      outputParts.push(\"..\");\r\n    }\r\n    outputParts = outputParts.concat(toParts.slice(samePartsLength));\r\n    return outputParts.join(\"/\");\r\n  },\r\n};\r\n\r\nvar TTY = {\r\n  ttys: [],\r\n  init: function () {\r\n    // https://github.com/emscripten-core/emscripten/pull/1555\r\n    // if (ENVIRONMENT_IS_NODE) {\r\n    //   // currently, FS.init does not distinguish if process.stdin is a file or TTY\r\n    //   // device, it always assumes it's a TTY device. because of this, we're forcing\r\n    //   // process.stdin to UTF8 encoding to at least make stdin reading compatible\r\n    //   // with text files until FS.init can be refactored.\r\n    //   process['stdin']['setEncoding']('utf8');\r\n    // }\r\n  },\r\n  shutdown: function () {\r\n    // https://github.com/emscripten-core/emscripten/pull/1555\r\n    // if (ENVIRONMENT_IS_NODE) {\r\n    //   // inolen: any idea as to why node -e 'process.stdin.read()' wouldn't exit immediately (with process.stdin being a tty)?\r\n    //   // isaacs: because now it's reading from the stream, you've expressed interest in it, so that read() kicks off a _read() which creates a ReadReq operation\r\n    //   // inolen: I thought read() in that case was a synchronous operation that just grabbed some amount of buffered data if it exists?\r\n    //   // isaacs: it is. but it also triggers a _read() call, which calls readStart() on the handle\r\n    //   // isaacs: do process.stdin.pause() and i'd think it'd probably close the pending call\r\n    //   process['stdin']['pause']();\r\n    // }\r\n  },\r\n  register: function (dev, ops) {\r\n    TTY.ttys[dev] = { input: [], output: [], ops: ops };\r\n    FS.registerDevice(dev, TTY.stream_ops);\r\n  },\r\n  stream_ops: {\r\n    open: function (stream) {\r\n      var tty = TTY.ttys[stream.node.rdev];\r\n      if (!tty) {\r\n        throw new FS.ErrnoError(ERRNO_CODES.ENODEV);\r\n      }\r\n      stream.tty = tty;\r\n      stream.seekable = false;\r\n    },\r\n    close: function (stream) {\r\n      // flush any pending line data\r\n      stream.tty.ops.flush(stream.tty);\r\n    },\r\n    flush: function (stream) {\r\n      stream.tty.ops.flush(stream.tty);\r\n    },\r\n    read: function (stream, buffer, offset, length, pos /* ignored */) {\r\n      if (!stream.tty || !stream.tty.ops.get_char) {\r\n        throw new FS.ErrnoError(ERRNO_CODES.ENXIO);\r\n      }\r\n      var bytesRead = 0;\r\n      for (var i = 0; i < length; i++) {\r\n        var result;\r\n        try {\r\n          result = stream.tty.ops.get_char(stream.tty);\r\n        } catch (e) {\r\n          throw new FS.ErrnoError(ERRNO_CODES.EIO);\r\n        }\r\n        if (result === undefined && bytesRead === 0) {\r\n          throw new FS.ErrnoError(ERRNO_CODES.EAGAIN);\r\n        }\r\n        if (result === null || result === undefined) break;\r\n        bytesRead++;\r\n        buffer[offset + i] = result;\r\n      }\r\n      if (bytesRead) {\r\n        stream.node.timestamp = Date.now();\r\n      }\r\n      return bytesRead;\r\n    },\r\n    write: function (stream, buffer, offset, length, pos) {\r\n      if (!stream.tty || !stream.tty.ops.put_char) {\r\n        throw new FS.ErrnoError(ERRNO_CODES.ENXIO);\r\n      }\r\n      try {\r\n        for (var i = 0; i < length; i++) {\r\n          stream.tty.ops.put_char(stream.tty, buffer[offset + i]);\r\n        }\r\n      } catch (e) {\r\n        throw new FS.ErrnoError(ERRNO_CODES.EIO);\r\n      }\r\n      if (length) {\r\n        stream.node.timestamp = Date.now();\r\n      }\r\n      return i;\r\n    },\r\n  },\r\n  default_tty_ops: {\r\n    get_char: function (tty) {\r\n      if (!tty.input.length) {\r\n        var result = null;\r\n        if (ENVIRONMENT_IS_NODE) {\r\n          // we will read data by chunks of BUFSIZE\r\n          var BUFSIZE = 256;\r\n          var buf = new Buffer(BUFSIZE);\r\n          var bytesRead = 0;\r\n\r\n          var isPosixPlatform = process.platform != \"win32\"; // Node doesn't offer a direct check, so test by exclusion\r\n\r\n          var fd = process.stdin.fd;\r\n          if (isPosixPlatform) {\r\n            // Linux and Mac cannot use process.stdin.fd (which isn't set up as sync)\r\n            var usingDevice = false;\r\n            try {\r\n              fd = fs.openSync(\"/dev/stdin\", \"r\");\r\n              usingDevice = true;\r\n            } catch (e) {}\r\n          }\r\n\r\n          try {\r\n            bytesRead = fs.readSync(fd, buf, 0, BUFSIZE, null);\r\n          } catch (e) {\r\n            // Cross-platform differences: on Windows, reading EOF throws an exception, but on other OSes,\r\n            // reading EOF returns 0. Uniformize behavior by treating the EOF exception to return 0.\r\n            if (e.toString().indexOf(\"EOF\") != -1) bytesRead = 0;\r\n            else throw e;\r\n          }\r\n\r\n          if (usingDevice) {\r\n            fs.closeSync(fd);\r\n          }\r\n          if (bytesRead > 0) {\r\n            result = buf.slice(0, bytesRead).toString(\"utf-8\");\r\n          } else {\r\n            result = null;\r\n          }\r\n        } else if (\r\n          typeof window != \"undefined\" &&\r\n          typeof window.prompt == \"function\"\r\n        ) {\r\n          // Browser.\r\n          result = window.prompt(\"Input: \"); // returns null on cancel\r\n          if (result !== null) {\r\n            result += \"\\n\";\r\n          }\r\n        } else if (typeof readline == \"function\") {\r\n          // Command line.\r\n          result = readline();\r\n          if (result !== null) {\r\n            result += \"\\n\";\r\n          }\r\n        }\r\n        if (!result) {\r\n          return null;\r\n        }\r\n        tty.input = intArrayFromString(result, true);\r\n      }\r\n      return tty.input.shift();\r\n    },\r\n    put_char: function (tty, val) {\r\n      if (val === null || val === 10) {\r\n        out(UTF8ArrayToString(tty.output, 0));\r\n        tty.output = [];\r\n      } else {\r\n        if (val != 0) tty.output.push(val); // val == 0 would cut text output off in the middle.\r\n      }\r\n    },\r\n    flush: function (tty) {\r\n      if (tty.output && tty.output.length > 0) {\r\n        out(UTF8ArrayToString(tty.output, 0));\r\n        tty.output = [];\r\n      }\r\n    },\r\n  },\r\n  default_tty1_ops: {\r\n    put_char: function (tty, val) {\r\n      if (val === null || val === 10) {\r\n        err(UTF8ArrayToString(tty.output, 0));\r\n        tty.output = [];\r\n      } else {\r\n        if (val != 0) tty.output.push(val);\r\n      }\r\n    },\r\n    flush: function (tty) {\r\n      if (tty.output && tty.output.length > 0) {\r\n        err(UTF8ArrayToString(tty.output, 0));\r\n        tty.output = [];\r\n      }\r\n    },\r\n  },\r\n};\r\n\r\nvar MEMFS = {\r\n  ops_table: null,\r\n  mount: function (mount) {\r\n    return MEMFS.createNode(null, \"/\", 16384 | 511 /* 0777 */, 0);\r\n  },\r\n  createNode: function (parent, name, mode, dev) {\r\n    if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {\r\n      // no supported\r\n      throw new FS.ErrnoError(ERRNO_CODES.EPERM);\r\n    }\r\n    if (!MEMFS.ops_table) {\r\n      MEMFS.ops_table = {\r\n        dir: {\r\n          node: {\r\n            getattr: MEMFS.node_ops.getattr,\r\n            setattr: MEMFS.node_ops.setattr,\r\n            lookup: MEMFS.node_ops.lookup,\r\n            mknod: MEMFS.node_ops.mknod,\r\n            rename: MEMFS.node_ops.rename,\r\n            unlink: MEMFS.node_ops.unlink,\r\n            rmdir: MEMFS.node_ops.rmdir,\r\n            readdir: MEMFS.node_ops.readdir,\r\n            symlink: MEMFS.node_ops.symlink,\r\n          },\r\n          stream: {\r\n            llseek: MEMFS.stream_ops.llseek,\r\n          },\r\n        },\r\n        file: {\r\n          node: {\r\n            getattr: MEMFS.node_ops.getattr,\r\n            setattr: MEMFS.node_ops.setattr,\r\n          },\r\n          stream: {\r\n            llseek: MEMFS.stream_ops.llseek,\r\n            read: MEMFS.stream_ops.read,\r\n            write: MEMFS.stream_ops.write,\r\n            allocate: MEMFS.stream_ops.allocate,\r\n            mmap: MEMFS.stream_ops.mmap,\r\n            msync: MEMFS.stream_ops.msync,\r\n          },\r\n        },\r\n        link: {\r\n          node: {\r\n            getattr: MEMFS.node_ops.getattr,\r\n            setattr: MEMFS.node_ops.setattr,\r\n            readlink: MEMFS.node_ops.readlink,\r\n          },\r\n          stream: {},\r\n        },\r\n        chrdev: {\r\n          node: {\r\n            getattr: MEMFS.node_ops.getattr,\r\n            setattr: MEMFS.node_ops.setattr,\r\n          },\r\n          stream: FS.chrdev_stream_ops,\r\n        },\r\n      };\r\n    }\r\n    var node = FS.createNode(parent, name, mode, dev);\r\n    if (FS.isDir(node.mode)) {\r\n      node.node_ops = MEMFS.ops_table.dir.node;\r\n      node.stream_ops = MEMFS.ops_table.dir.stream;\r\n      node.contents = {};\r\n    } else if (FS.isFile(node.mode)) {\r\n      node.node_ops = MEMFS.ops_table.file.node;\r\n      node.stream_ops = MEMFS.ops_table.file.stream;\r\n      node.usedBytes = 0; // The actual number of bytes used in the typed array, as opposed to contents.length which gives the whole capacity.\r\n      // When the byte data of the file is populated, this will point to either a typed array, or a normal JS array. Typed arrays are preferred\r\n      // for performance, and used by default. However, typed arrays are not resizable like normal JS arrays are, so there is a small disk size\r\n      // penalty involved for appending file writes that continuously grow a file similar to std::vector capacity vs used -scheme.\r\n      node.contents = null;\r\n    } else if (FS.isLink(node.mode)) {\r\n      node.node_ops = MEMFS.ops_table.link.node;\r\n      node.stream_ops = MEMFS.ops_table.link.stream;\r\n    } else if (FS.isChrdev(node.mode)) {\r\n      node.node_ops = MEMFS.ops_table.chrdev.node;\r\n      node.stream_ops = MEMFS.ops_table.chrdev.stream;\r\n    }\r\n    node.timestamp = Date.now();\r\n    // add the new node to the parent\r\n    if (parent) {\r\n      parent.contents[name] = node;\r\n    }\r\n    return node;\r\n  },\r\n  getFileDataAsRegularArray: function (node) {\r\n    if (node.contents && node.contents.subarray) {\r\n      var arr = [];\r\n      for (var i = 0; i < node.usedBytes; ++i) arr.push(node.contents[i]);\r\n      return arr; // Returns a copy of the original data.\r\n    }\r\n    return node.contents; // No-op, the file contents are already in a JS array. Return as-is.\r\n  },\r\n  getFileDataAsTypedArray: function (node) {\r\n    if (!node.contents) return new Uint8Array();\r\n    if (node.contents.subarray)\r\n      return node.contents.subarray(0, node.usedBytes); // Make sure to not return excess unused bytes.\r\n    return new Uint8Array(node.contents);\r\n  },\r\n  expandFileStorage: function (node, newCapacity) {\r\n    var prevCapacity = node.contents ? node.contents.length : 0;\r\n    if (prevCapacity >= newCapacity) return; // No need to expand, the storage was already large enough.\r\n    // Don't expand strictly to the given requested limit if it's only a very small increase, but instead geometrically grow capacity.\r\n    // For small filesizes (<1MB), perform size*2 geometric increase, but for large sizes, do a much more conservative size*1.125 increase to\r\n    // avoid overshooting the allocation cap by a very large margin.\r\n    var CAPACITY_DOUBLING_MAX = 1024 * 1024;\r\n    newCapacity = Math.max(\r\n      newCapacity,\r\n      (prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2.0 : 1.125)) | 0,\r\n    );\r\n    if (prevCapacity != 0) newCapacity = Math.max(newCapacity, 256); // At minimum allocate 256b for each file when expanding.\r\n    var oldContents = node.contents;\r\n    node.contents = new Uint8Array(newCapacity); // Allocate new storage.\r\n    if (node.usedBytes > 0)\r\n      node.contents.set(oldContents.subarray(0, node.usedBytes), 0); // Copy old data over to the new storage.\r\n    return;\r\n  },\r\n  resizeFileStorage: function (node, newSize) {\r\n    if (node.usedBytes == newSize) return;\r\n    if (newSize == 0) {\r\n      node.contents = null; // Fully decommit when requesting a resize to zero.\r\n      node.usedBytes = 0;\r\n      return;\r\n    }\r\n    if (!node.contents || node.contents.subarray) {\r\n      // Resize a typed array if that is being used as the backing store.\r\n      var oldContents = node.contents;\r\n      node.contents = new Uint8Array(new ArrayBuffer(newSize)); // Allocate new storage.\r\n      if (oldContents) {\r\n        node.contents.set(\r\n          oldContents.subarray(0, Math.min(newSize, node.usedBytes)),\r\n        ); // Copy old data over to the new storage.\r\n      }\r\n      node.usedBytes = newSize;\r\n      return;\r\n    }\r\n    // Backing with a JS array.\r\n    if (!node.contents) node.contents = [];\r\n    if (node.contents.length > newSize) node.contents.length = newSize;\r\n    else while (node.contents.length < newSize) node.contents.push(0);\r\n    node.usedBytes = newSize;\r\n  },\r\n  node_ops: {\r\n    getattr: function (node) {\r\n      var attr = {};\r\n      // device numbers reuse inode numbers.\r\n      attr.dev = FS.isChrdev(node.mode) ? node.id : 1;\r\n      attr.ino = node.id;\r\n      attr.mode = node.mode;\r\n      attr.nlink = 1;\r\n      attr.uid = 0;\r\n      attr.gid = 0;\r\n      attr.rdev = node.rdev;\r\n      if (FS.isDir(node.mode)) {\r\n        attr.size = 4096;\r\n      } else if (FS.isFile(node.mode)) {\r\n        attr.size = node.usedBytes;\r\n      } else if (FS.isLink(node.mode)) {\r\n        attr.size = node.link.length;\r\n      } else {\r\n        attr.size = 0;\r\n      }\r\n      attr.atime = new Date(node.timestamp);\r\n      attr.mtime = new Date(node.timestamp);\r\n      attr.ctime = new Date(node.timestamp);\r\n      // NOTE: In our implementation, st_blocks = Math.ceil(st_size/st_blksize),\r\n      //       but this is not required by the standard.\r\n      attr.blksize = 4096;\r\n      attr.blocks = Math.ceil(attr.size / attr.blksize);\r\n      return attr;\r\n    },\r\n    setattr: function (node, attr) {\r\n      if (attr.mode !== undefined) {\r\n        node.mode = attr.mode;\r\n      }\r\n      if (attr.timestamp !== undefined) {\r\n        node.timestamp = attr.timestamp;\r\n      }\r\n      if (attr.size !== undefined) {\r\n        MEMFS.resizeFileStorage(node, attr.size);\r\n      }\r\n    },\r\n    lookup: function (parent, name) {\r\n      throw FS.genericErrors[ERRNO_CODES.ENOENT];\r\n    },\r\n    mknod: function (parent, name, mode, dev) {\r\n      return MEMFS.createNode(parent, name, mode, dev);\r\n    },\r\n    rename: function (old_node, new_dir, new_name) {\r\n      // if we're overwriting a directory at new_name, make sure it's empty.\r\n      if (FS.isDir(old_node.mode)) {\r\n        var new_node;\r\n        try {\r\n          new_node = FS.lookupNode(new_dir, new_name);\r\n        } catch (e) {}\r\n        if (new_node) {\r\n          for (var i in new_node.contents) {\r\n            throw new FS.ErrnoError(ERRNO_CODES.ENOTEMPTY);\r\n          }\r\n        }\r\n      }\r\n      // do the internal rewiring\r\n      delete old_node.parent.contents[old_node.name];\r\n      old_node.name = new_name;\r\n      new_dir.contents[new_name] = old_node;\r\n      old_node.parent = new_dir;\r\n    },\r\n    unlink: function (parent, name) {\r\n      delete parent.contents[name];\r\n    },\r\n    rmdir: function (parent, name) {\r\n      var node = FS.lookupNode(parent, name);\r\n      for (var i in node.contents) {\r\n        throw new FS.ErrnoError(ERRNO_CODES.ENOTEMPTY);\r\n      }\r\n      delete parent.contents[name];\r\n    },\r\n    readdir: function (node) {\r\n      var entries = [\".\", \"..\"];\r\n      for (var key in node.contents) {\r\n        if (!node.contents.hasOwnProperty(key)) {\r\n          continue;\r\n        }\r\n        entries.push(key);\r\n      }\r\n      return entries;\r\n    },\r\n    symlink: function (parent, newname, oldpath) {\r\n      var node = MEMFS.createNode(parent, newname, 511 /* 0777 */ | 40960, 0);\r\n      node.link = oldpath;\r\n      return node;\r\n    },\r\n    readlink: function (node) {\r\n      if (!FS.isLink(node.mode)) {\r\n        throw new FS.ErrnoError(ERRNO_CODES.EINVAL);\r\n      }\r\n      return node.link;\r\n    },\r\n  },\r\n  stream_ops: {\r\n    read: function (stream, buffer, offset, length, position) {\r\n      var contents = stream.node.contents;\r\n      if (position >= stream.node.usedBytes) return 0;\r\n      var size = Math.min(stream.node.usedBytes - position, length);\r\n      assert(size >= 0);\r\n      if (size > 8 && contents.subarray) {\r\n        // non-trivial, and typed array\r\n        buffer.set(contents.subarray(position, position + size), offset);\r\n      } else {\r\n        for (var i = 0; i < size; i++)\r\n          buffer[offset + i] = contents[position + i];\r\n      }\r\n      return size;\r\n    },\r\n    write: function (stream, buffer, offset, length, position, canOwn) {\r\n      // If memory can grow, we don't want to hold on to references of\r\n      // the memory Buffer, as they may get invalidated. That means\r\n      // we need to do a copy here.\r\n      // FIXME: this is inefficient as the file packager may have\r\n      //        copied the data into memory already - we may want to\r\n      //        integrate more there and let the file packager loading\r\n      //        code be able to query if memory growth is on or off.\r\n      if (canOwn) {\r\n        warnOnce(\r\n          \"file packager has copied file data into memory, but in memory growth we are forced to copy it again (see --no-heap-copy)\",\r\n        );\r\n      }\r\n      canOwn = false;\r\n\r\n      if (!length) return 0;\r\n      var node = stream.node;\r\n      node.timestamp = Date.now();\r\n\r\n      if (buffer.subarray && (!node.contents || node.contents.subarray)) {\r\n        // This write is from a typed array to a typed array?\r\n        if (canOwn) {\r\n          assert(\r\n            position === 0,\r\n            \"canOwn must imply no weird position inside the file\",\r\n          );\r\n          node.contents = buffer.subarray(offset, offset + length);\r\n          node.usedBytes = length;\r\n          return length;\r\n        } else if (node.usedBytes === 0 && position === 0) {\r\n          // If this is a simple first write to an empty file, do a fast set since we don't need to care about old data.\r\n          node.contents = new Uint8Array(\r\n            buffer.subarray(offset, offset + length),\r\n          );\r\n          node.usedBytes = length;\r\n          return length;\r\n        } else if (position + length <= node.usedBytes) {\r\n          // Writing to an already allocated and used subrange of the file?\r\n          node.contents.set(buffer.subarray(offset, offset + length), position);\r\n          return length;\r\n        }\r\n      }\r\n\r\n      // Appending to an existing file and we need to reallocate, or source data did not come as a typed array.\r\n      MEMFS.expandFileStorage(node, position + length);\r\n      if (node.contents.subarray && buffer.subarray)\r\n        node.contents.set(buffer.subarray(offset, offset + length), position); // Use typed array write if available.\r\n      else {\r\n        for (var i = 0; i < length; i++) {\r\n          node.contents[position + i] = buffer[offset + i]; // Or fall back to manual write if not.\r\n        }\r\n      }\r\n      node.usedBytes = Math.max(node.usedBytes, position + length);\r\n      return length;\r\n    },\r\n    llseek: function (stream, offset, whence) {\r\n      var position = offset;\r\n      if (whence === 1) {\r\n        // SEEK_CUR.\r\n        position += stream.position;\r\n      } else if (whence === 2) {\r\n        // SEEK_END.\r\n        if (FS.isFile(stream.node.mode)) {\r\n          position += stream.node.usedBytes;\r\n        }\r\n      }\r\n      if (position < 0) {\r\n        throw new FS.ErrnoError(ERRNO_CODES.EINVAL);\r\n      }\r\n      return position;\r\n    },\r\n    allocate: function (stream, offset, length) {\r\n      MEMFS.expandFileStorage(stream.node, offset + length);\r\n      stream.node.usedBytes = Math.max(stream.node.usedBytes, offset + length);\r\n    },\r\n    mmap: function (stream, buffer, offset, length, position, prot, flags) {\r\n      if (!FS.isFile(stream.node.mode)) {\r\n        throw new FS.ErrnoError(ERRNO_CODES.ENODEV);\r\n      }\r\n      var ptr;\r\n      var allocated;\r\n      var contents = stream.node.contents;\r\n      // Only make a new copy when MAP_PRIVATE is specified.\r\n      if (\r\n        !(flags & 2) &&\r\n        (contents.buffer === buffer || contents.buffer === buffer.buffer)\r\n      ) {\r\n        // We can't emulate MAP_SHARED when the file is not backed by the buffer\r\n        // we're mapping to (e.g. the HEAP buffer).\r\n        allocated = false;\r\n        ptr = contents.byteOffset;\r\n      } else {\r\n        // Try to avoid unnecessary slices.\r\n        if (position > 0 || position + length < stream.node.usedBytes) {\r\n          if (contents.subarray) {\r\n            contents = contents.subarray(position, position + length);\r\n          } else {\r\n            contents = Array.prototype.slice.call(\r\n              contents,\r\n              position,\r\n              position + length,\r\n            );\r\n          }\r\n        }\r\n        allocated = true;\r\n        ptr = _malloc(length);\r\n        if (!ptr) {\r\n          throw new FS.ErrnoError(ERRNO_CODES.ENOMEM);\r\n        }\r\n        buffer.set(contents, ptr);\r\n      }\r\n      return { ptr: ptr, allocated: allocated };\r\n    },\r\n    msync: function (stream, buffer, offset, length, mmapFlags) {\r\n      if (!FS.isFile(stream.node.mode)) {\r\n        throw new FS.ErrnoError(ERRNO_CODES.ENODEV);\r\n      }\r\n      if (mmapFlags & 2) {\r\n        // MAP_PRIVATE calls need not to be synced back to underlying fs\r\n        return 0;\r\n      }\r\n\r\n      var bytesWritten = MEMFS.stream_ops.write(\r\n        stream,\r\n        buffer,\r\n        0,\r\n        length,\r\n        offset,\r\n        false,\r\n      );\r\n      // should we check if bytesWritten and length are the same?\r\n      return 0;\r\n    },\r\n  },\r\n};\r\n\r\nvar IDBFS = {\r\n  dbs: {},\r\n  indexedDB: function () {\r\n    if (typeof indexedDB !== \"undefined\") return indexedDB;\r\n    var ret = null;\r\n    if (typeof window === \"object\")\r\n      ret =\r\n        window.indexedDB ||\r\n        window.mozIndexedDB ||\r\n        window.webkitIndexedDB ||\r\n        window.msIndexedDB;\r\n    assert(ret, \"IDBFS used, but indexedDB not supported\");\r\n    return ret;\r\n  },\r\n  DB_VERSION: 21,\r\n  DB_STORE_NAME: \"FILE_DATA\",\r\n  mount: function (mount) {\r\n    // reuse all of the core MEMFS functionality\r\n    return MEMFS.mount.apply(null, arguments);\r\n  },\r\n  syncfs: function (mount, populate, callback) {\r\n    IDBFS.getLocalSet(mount, function (err, local) {\r\n      if (err) return callback(err);\r\n\r\n      IDBFS.getRemoteSet(mount, function (err, remote) {\r\n        if (err) return callback(err);\r\n\r\n        var src = populate ? remote : local;\r\n        var dst = populate ? local : remote;\r\n\r\n        IDBFS.reconcile(src, dst, callback);\r\n      });\r\n    });\r\n  },\r\n  getDB: function (name, callback) {\r\n    // check the cache first\r\n    var db = IDBFS.dbs[name];\r\n    if (db) {\r\n      return callback(null, db);\r\n    }\r\n\r\n    var req;\r\n    try {\r\n      req = IDBFS.indexedDB().open(name, IDBFS.DB_VERSION);\r\n    } catch (e) {\r\n      return callback(e);\r\n    }\r\n    if (!req) {\r\n      return callback(\"Unable to connect to IndexedDB\");\r\n    }\r\n    req.onupgradeneeded = function (e) {\r\n      var db = e.target.result;\r\n      var transaction = e.target.transaction;\r\n\r\n      var fileStore;\r\n\r\n      if (db.objectStoreNames.contains(IDBFS.DB_STORE_NAME)) {\r\n        fileStore = transaction.objectStore(IDBFS.DB_STORE_NAME);\r\n      } else {\r\n        fileStore = db.createObjectStore(IDBFS.DB_STORE_NAME);\r\n      }\r\n\r\n      if (!fileStore.indexNames.contains(\"timestamp\")) {\r\n        fileStore.createIndex(\"timestamp\", \"timestamp\", { unique: false });\r\n      }\r\n    };\r\n    req.onsuccess = function () {\r\n      db = req.result;\r\n\r\n      // add to the cache\r\n      IDBFS.dbs[name] = db;\r\n      callback(null, db);\r\n    };\r\n    req.onerror = function (e) {\r\n      callback(this.error);\r\n      e.preventDefault();\r\n    };\r\n  },\r\n  getLocalSet: function (mount, callback) {\r\n    var entries = {};\r\n\r\n    function isRealDir(p) {\r\n      return p !== \".\" && p !== \"..\";\r\n    }\r\n\r\n    function toAbsolute(root) {\r\n      return function (p) {\r\n        return PATH.join2(root, p);\r\n      };\r\n    }\r\n\r\n    var check = FS.readdir(mount.mountpoint)\r\n      .filter(isRealDir)\r\n      .map(toAbsolute(mount.mountpoint));\r\n\r\n    while (check.length) {\r\n      var path = check.pop();\r\n      var stat;\r\n\r\n      try {\r\n        stat = FS.stat(path);\r\n      } catch (e) {\r\n        return callback(e);\r\n      }\r\n\r\n      if (FS.isDir(stat.mode)) {\r\n        check.push.apply(\r\n          check,\r\n          FS.readdir(path).filter(isRealDir).map(toAbsolute(path)),\r\n        );\r\n      }\r\n\r\n      entries[path] = { timestamp: stat.mtime };\r\n    }\r\n\r\n    return callback(null, { type: \"local\", entries: entries });\r\n  },\r\n  getRemoteSet: function (mount, callback) {\r\n    var entries = {};\r\n\r\n    IDBFS.getDB(mount.mountpoint, function (err, db) {\r\n      if (err) return callback(err);\r\n\r\n      try {\r\n        var transaction = db.transaction([IDBFS.DB_STORE_NAME], \"readonly\");\r\n        transaction.onerror = function (e) {\r\n          callback(this.error);\r\n          e.preventDefault();\r\n        };\r\n\r\n        var store = transaction.objectStore(IDBFS.DB_STORE_NAME);\r\n        var index = store.index(\"timestamp\");\r\n\r\n        index.openKeyCursor().onsuccess = function (event) {\r\n          var cursor = event.target.result;\r\n\r\n          if (!cursor) {\r\n            return callback(null, { type: \"remote\", db: db, entries: entries });\r\n          }\r\n\r\n          entries[cursor.primaryKey] = { timestamp: cursor.key };\r\n\r\n          cursor.continue();\r\n        };\r\n      } catch (e) {\r\n        return callback(e);\r\n      }\r\n    });\r\n  },\r\n  loadLocalEntry: function (path, callback) {\r\n    var stat, node;\r\n\r\n    try {\r\n      var lookup = FS.lookupPath(path);\r\n      node = lookup.node;\r\n      stat = FS.stat(path);\r\n    } catch (e) {\r\n      return callback(e);\r\n    }\r\n\r\n    if (FS.isDir(stat.mode)) {\r\n      return callback(null, { timestamp: stat.mtime, mode: stat.mode });\r\n    } else if (FS.isFile(stat.mode)) {\r\n      // Performance consideration: storing a normal JavaScript array to a IndexedDB is much slower than storing a typed array.\r\n      // Therefore always convert the file contents to a typed array first before writing the data to IndexedDB.\r\n      node.contents = MEMFS.getFileDataAsTypedArray(node);\r\n      return callback(null, {\r\n        timestamp: stat.mtime,\r\n        mode: stat.mode,\r\n        contents: node.contents,\r\n      });\r\n    } else {\r\n      return callback(new Error(\"node type not supported\"));\r\n    }\r\n  },\r\n  storeLocalEntry: function (path, entry, callback) {\r\n    try {\r\n      if (FS.isDir(entry.mode)) {\r\n        FS.mkdir(path, entry.mode);\r\n      } else if (FS.isFile(entry.mode)) {\r\n        FS.writeFile(path, entry.contents, { canOwn: true });\r\n      } else {\r\n        return callback(new Error(\"node type not supported\"));\r\n      }\r\n\r\n      FS.chmod(path, entry.mode);\r\n      FS.utime(path, entry.timestamp, entry.timestamp);\r\n    } catch (e) {\r\n      return callback(e);\r\n    }\r\n\r\n    callback(null);\r\n  },\r\n  removeLocalEntry: function (path, callback) {\r\n    try {\r\n      var lookup = FS.lookupPath(path);\r\n      var stat = FS.stat(path);\r\n\r\n      if (FS.isDir(stat.mode)) {\r\n        FS.rmdir(path);\r\n      } else if (FS.isFile(stat.mode)) {\r\n        FS.unlink(path);\r\n      }\r\n    } catch (e) {\r\n      return callback(e);\r\n    }\r\n\r\n    callback(null);\r\n  },\r\n  loadRemoteEntry: function (store, path, callback) {\r\n    var req = store.get(path);\r\n    req.onsuccess = function (event) {\r\n      callback(null, event.target.result);\r\n    };\r\n    req.onerror = function (e) {\r\n      callback(this.error);\r\n      e.preventDefault();\r\n    };\r\n  },\r\n  storeRemoteEntry: function (store, path, entry, callback) {\r\n    var req = store.put(entry, path);\r\n    req.onsuccess = function () {\r\n      callback(null);\r\n    };\r\n    req.onerror = function (e) {\r\n      callback(this.error);\r\n      e.preventDefault();\r\n    };\r\n  },\r\n  removeRemoteEntry: function (store, path, callback) {\r\n    var req = store.delete(path);\r\n    req.onsuccess = function () {\r\n      callback(null);\r\n    };\r\n    req.onerror = function (e) {\r\n      callback(this.error);\r\n      e.preventDefault();\r\n    };\r\n  },\r\n  reconcile: function (src, dst, callback) {\r\n    var total = 0;\r\n\r\n    var create = [];\r\n    Object.keys(src.entries).forEach(function (key) {\r\n      var e = src.entries[key];\r\n      var e2 = dst.entries[key];\r\n      if (!e2 || e.timestamp > e2.timestamp) {\r\n        create.push(key);\r\n        total++;\r\n      }\r\n    });\r\n\r\n    var remove = [];\r\n    Object.keys(dst.entries).forEach(function (key) {\r\n      var e = dst.entries[key];\r\n      var e2 = src.entries[key];\r\n      if (!e2) {\r\n        remove.push(key);\r\n        total++;\r\n      }\r\n    });\r\n\r\n    if (!total) {\r\n      return callback(null);\r\n    }\r\n\r\n    var errored = false;\r\n    var completed = 0;\r\n    var db = src.type === \"remote\" ? src.db : dst.db;\r\n    var transaction = db.transaction([IDBFS.DB_STORE_NAME], \"readwrite\");\r\n    var store = transaction.objectStore(IDBFS.DB_STORE_NAME);\r\n\r\n    function done(err) {\r\n      if (err) {\r\n        if (!done.errored) {\r\n          done.errored = true;\r\n          return callback(err);\r\n        }\r\n        return;\r\n      }\r\n      if (++completed >= total) {\r\n        return callback(null);\r\n      }\r\n    }\r\n\r\n    transaction.onerror = function (e) {\r\n      done(this.error);\r\n      e.preventDefault();\r\n    };\r\n\r\n    // sort paths in ascending order so directory entries are created\r\n    // before the files inside them\r\n    create.sort().forEach(function (path) {\r\n      if (dst.type === \"local\") {\r\n        IDBFS.loadRemoteEntry(store, path, function (err, entry) {\r\n          if (err) return done(err);\r\n          IDBFS.storeLocalEntry(path, entry, done);\r\n        });\r\n      } else {\r\n        IDBFS.loadLocalEntry(path, function (err, entry) {\r\n          if (err) return done(err);\r\n          IDBFS.storeRemoteEntry(store, path, entry, done);\r\n        });\r\n      }\r\n    });\r\n\r\n    // sort paths in descending order so files are deleted before their\r\n    // parent directories\r\n    remove\r\n      .sort()\r\n      .reverse()\r\n      .forEach(function (path) {\r\n        if (dst.type === \"local\") {\r\n          IDBFS.removeLocalEntry(path, done);\r\n        } else {\r\n          IDBFS.removeRemoteEntry(store, path, done);\r\n        }\r\n      });\r\n  },\r\n};\r\n\r\nvar NODEFS = {\r\n  isWindows: false,\r\n  staticInit: function () {\r\n    NODEFS.isWindows = !!process.platform.match(/^win/);\r\n    var flags = process[\"binding\"](\"constants\");\r\n    // Node.js 4 compatibility: it has no namespaces for constants\r\n    if (flags[\"fs\"]) {\r\n      flags = flags[\"fs\"];\r\n    }\r\n    NODEFS.flagsForNodeMap = {\r\n      1024: flags[\"O_APPEND\"],\r\n      64: flags[\"O_CREAT\"],\r\n      128: flags[\"O_EXCL\"],\r\n      0: flags[\"O_RDONLY\"],\r\n      2: flags[\"O_RDWR\"],\r\n      4096: flags[\"O_SYNC\"],\r\n      512: flags[\"O_TRUNC\"],\r\n      1: flags[\"O_WRONLY\"],\r\n    };\r\n  },\r\n  bufferFrom: function (arrayBuffer) {\r\n    // Node.js < 4.5 compatibility: Buffer.from does not support ArrayBuffer\r\n    // Buffer.from before 4.5 was just a method inherited from Uint8Array\r\n    // Buffer.alloc has been added with Buffer.from together, so check it instead\r\n    return Buffer.alloc ? Buffer.from(arrayBuffer) : new Buffer(arrayBuffer);\r\n  },\r\n  mount: function (mount) {\r\n    assert(ENVIRONMENT_IS_NODE);\r\n    return NODEFS.createNode(null, \"/\", NODEFS.getMode(mount.opts.root), 0);\r\n  },\r\n  createNode: function (parent, name, mode, dev) {\r\n    if (!FS.isDir(mode) && !FS.isFile(mode) && !FS.isLink(mode)) {\r\n      throw new FS.ErrnoError(ERRNO_CODES.EINVAL);\r\n    }\r\n    var node = FS.createNode(parent, name, mode);\r\n    node.node_ops = NODEFS.node_ops;\r\n    node.stream_ops = NODEFS.stream_ops;\r\n    return node;\r\n  },\r\n  getMode: function (path) {\r\n    var stat;\r\n    try {\r\n      stat = fs.lstatSync(path);\r\n      if (NODEFS.isWindows) {\r\n        // Node.js on Windows never represents permission bit 'x', so\r\n        // propagate read bits to execute bits\r\n        stat.mode = stat.mode | ((stat.mode & 292) >> 2);\r\n      }\r\n    } catch (e) {\r\n      if (!e.code) throw e;\r\n      throw new FS.ErrnoError(ERRNO_CODES[e.code]);\r\n    }\r\n    return stat.mode;\r\n  },\r\n  realPath: function (node) {\r\n    var parts = [];\r\n    while (node.parent !== node) {\r\n      parts.push(node.name);\r\n      node = node.parent;\r\n    }\r\n    parts.push(node.mount.opts.root);\r\n    parts.reverse();\r\n    return PATH.join.apply(null, parts);\r\n  },\r\n  flagsForNode: function (flags) {\r\n    flags &= ~0x200000 /*O_PATH*/; // Ignore this flag from musl, otherwise node.js fails to open the file.\r\n    flags &= ~0x800 /*O_NONBLOCK*/; // Ignore this flag from musl, otherwise node.js fails to open the file.\r\n    flags &= ~0x8000 /*O_LARGEFILE*/; // Ignore this flag from musl, otherwise node.js fails to open the file.\r\n    flags &= ~0x80000 /*O_CLOEXEC*/; // Some applications may pass it; it makes no sense for a single process.\r\n    var newFlags = 0;\r\n    for (var k in NODEFS.flagsForNodeMap) {\r\n      if (flags & k) {\r\n        newFlags |= NODEFS.flagsForNodeMap[k];\r\n        flags ^= k;\r\n      }\r\n    }\r\n\r\n    if (!flags) {\r\n      return newFlags;\r\n    } else {\r\n      throw new FS.ErrnoError(ERRNO_CODES.EINVAL);\r\n    }\r\n  },\r\n  node_ops: {\r\n    getattr: function (node) {\r\n      var path = NODEFS.realPath(node);\r\n      var stat;\r\n      try {\r\n        stat = fs.lstatSync(path);\r\n      } catch (e) {\r\n        if (!e.code) throw e;\r\n        throw new FS.ErrnoError(ERRNO_CODES[e.code]);\r\n      }\r\n      // node.js v0.10.20 doesn't report blksize and blocks on Windows. Fake them with default blksize of 4096.\r\n      // See http://support.microsoft.com/kb/140365\r\n      if (NODEFS.isWindows && !stat.blksize) {\r\n        stat.blksize = 4096;\r\n      }\r\n      if (NODEFS.isWindows && !stat.blocks) {\r\n        stat.blocks = ((stat.size + stat.blksize - 1) / stat.blksize) | 0;\r\n      }\r\n      return {\r\n        dev: stat.dev,\r\n        ino: stat.ino,\r\n        mode: stat.mode,\r\n        nlink: stat.nlink,\r\n        uid: stat.uid,\r\n        gid: stat.gid,\r\n        rdev: stat.rdev,\r\n        size: stat.size,\r\n        atime: stat.atime,\r\n        mtime: stat.mtime,\r\n        ctime: stat.ctime,\r\n        blksize: stat.blksize,\r\n        blocks: stat.blocks,\r\n      };\r\n    },\r\n    setattr: function (node, attr) {\r\n      var path = NODEFS.realPath(node);\r\n      try {\r\n        if (attr.mode !== undefined) {\r\n          fs.chmodSync(path, attr.mode);\r\n          // update the common node structure mode as well\r\n          node.mode = attr.mode;\r\n        }\r\n        if (attr.timestamp !== undefined) {\r\n          var date = new Date(attr.timestamp);\r\n          fs.utimesSync(path, date, date);\r\n        }\r\n        if (attr.size !== undefined) {\r\n          fs.truncateSync(path, attr.size);\r\n        }\r\n      } catch (e) {\r\n        if (!e.code) throw e;\r\n        throw new FS.ErrnoError(ERRNO_CODES[e.code]);\r\n      }\r\n    },\r\n    lookup: function (parent, name) {\r\n      var path = PATH.join2(NODEFS.realPath(parent), name);\r\n      var mode = NODEFS.getMode(path);\r\n      return NODEFS.createNode(parent, name, mode);\r\n    },\r\n    mknod: function (parent, name, mode, dev) {\r\n      var node = NODEFS.createNode(parent, name, mode, dev);\r\n      // create the backing node for this in the fs root as well\r\n      var path = NODEFS.realPath(node);\r\n      try {\r\n        if (FS.isDir(node.mode)) {\r\n          fs.mkdirSync(path, node.mode);\r\n        } else {\r\n          fs.writeFileSync(path, \"\", { mode: node.mode });\r\n        }\r\n      } catch (e) {\r\n        if (!e.code) throw e;\r\n        throw new FS.ErrnoError(ERRNO_CODES[e.code]);\r\n      }\r\n      return node;\r\n    },\r\n    rename: function (oldNode, newDir, newName) {\r\n      var oldPath = NODEFS.realPath(oldNode);\r\n      var newPath = PATH.join2(NODEFS.realPath(newDir), newName);\r\n      try {\r\n        fs.renameSync(oldPath, newPath);\r\n      } catch (e) {\r\n        if (!e.code) throw e;\r\n        throw new FS.ErrnoError(ERRNO_CODES[e.code]);\r\n      }\r\n    },\r\n    unlink: function (parent, name) {\r\n      var path = PATH.join2(NODEFS.realPath(parent), name);\r\n      try {\r\n        fs.unlinkSync(path);\r\n      } catch (e) {\r\n        if (!e.code) throw e;\r\n        throw new FS.ErrnoError(ERRNO_CODES[e.code]);\r\n      }\r\n    },\r\n    rmdir: function (parent, name) {\r\n      var path = PATH.join2(NODEFS.realPath(parent), name);\r\n      try {\r\n        fs.rmdirSync(path);\r\n      } catch (e) {\r\n        if (!e.code) throw e;\r\n        throw new FS.ErrnoError(ERRNO_CODES[e.code]);\r\n      }\r\n    },\r\n    readdir: function (node) {\r\n      var path = NODEFS.realPath(node);\r\n      try {\r\n        return fs.readdirSync(path);\r\n      } catch (e) {\r\n        if (!e.code) throw e;\r\n        throw new FS.ErrnoError(ERRNO_CODES[e.code]);\r\n      }\r\n    },\r\n    symlink: function (parent, newName, oldPath) {\r\n      var newPath = PATH.join2(NODEFS.realPath(parent), newName);\r\n      try {\r\n        fs.symlinkSync(oldPath, newPath);\r\n      } catch (e) {\r\n        if (!e.code) throw e;\r\n        throw new FS.ErrnoError(ERRNO_CODES[e.code]);\r\n      }\r\n    },\r\n    readlink: function (node) {\r\n      var path = NODEFS.realPath(node);\r\n      try {\r\n        path = fs.readlinkSync(path);\r\n        path = NODEJS_PATH.relative(\r\n          NODEJS_PATH.resolve(node.mount.opts.root),\r\n          path,\r\n        );\r\n        return path;\r\n      } catch (e) {\r\n        if (!e.code) throw e;\r\n        throw new FS.ErrnoError(ERRNO_CODES[e.code]);\r\n      }\r\n    },\r\n  },\r\n  stream_ops: {\r\n    open: function (stream) {\r\n      var path = NODEFS.realPath(stream.node);\r\n      try {\r\n        if (FS.isFile(stream.node.mode)) {\r\n          stream.nfd = fs.openSync(path, NODEFS.flagsForNode(stream.flags));\r\n        }\r\n      } catch (e) {\r\n        if (!e.code) throw e;\r\n        throw new FS.ErrnoError(ERRNO_CODES[e.code]);\r\n      }\r\n    },\r\n    close: function (stream) {\r\n      try {\r\n        if (FS.isFile(stream.node.mode) && stream.nfd) {\r\n          fs.closeSync(stream.nfd);\r\n        }\r\n      } catch (e) {\r\n        if (!e.code) throw e;\r\n        throw new FS.ErrnoError(ERRNO_CODES[e.code]);\r\n      }\r\n    },\r\n    read: function (stream, buffer, offset, length, position) {\r\n      // Node.js < 6 compatibility: node errors on 0 length reads\r\n      if (length === 0) return 0;\r\n      try {\r\n        return fs.readSync(\r\n          stream.nfd,\r\n          NODEFS.bufferFrom(buffer.buffer),\r\n          offset,\r\n          length,\r\n          position,\r\n        );\r\n      } catch (e) {\r\n        throw new FS.ErrnoError(ERRNO_CODES[e.code]);\r\n      }\r\n    },\r\n    write: function (stream, buffer, offset, length, position) {\r\n      try {\r\n        return fs.writeSync(\r\n          stream.nfd,\r\n          NODEFS.bufferFrom(buffer.buffer),\r\n          offset,\r\n          length,\r\n          position,\r\n        );\r\n      } catch (e) {\r\n        throw new FS.ErrnoError(ERRNO_CODES[e.code]);\r\n      }\r\n    },\r\n    llseek: function (stream, offset, whence) {\r\n      var position = offset;\r\n      if (whence === 1) {\r\n        // SEEK_CUR.\r\n        position += stream.position;\r\n      } else if (whence === 2) {\r\n        // SEEK_END.\r\n        if (FS.isFile(stream.node.mode)) {\r\n          try {\r\n            var stat = fs.fstatSync(stream.nfd);\r\n            position += stat.size;\r\n          } catch (e) {\r\n            throw new FS.ErrnoError(ERRNO_CODES[e.code]);\r\n          }\r\n        }\r\n      }\r\n\r\n      if (position < 0) {\r\n        throw new FS.ErrnoError(ERRNO_CODES.EINVAL);\r\n      }\r\n\r\n      return position;\r\n    },\r\n  },\r\n};\r\n\r\nvar WORKERFS = {\r\n  DIR_MODE: 16895,\r\n  FILE_MODE: 33279,\r\n  reader: null,\r\n  mount: function (mount) {\r\n    assert(ENVIRONMENT_IS_WORKER);\r\n    if (!WORKERFS.reader) WORKERFS.reader = new FileReaderSync();\r\n    var root = WORKERFS.createNode(null, \"/\", WORKERFS.DIR_MODE, 0);\r\n    var createdParents = {};\r\n\r\n    function ensureParent(path) {\r\n      // return the parent node, creating subdirs as necessary\r\n      var parts = path.split(\"/\");\r\n      var parent = root;\r\n      for (var i = 0; i < parts.length - 1; i++) {\r\n        var curr = parts.slice(0, i + 1).join(\"/\");\r\n        // Issue 4254: Using curr as a node name will prevent the node\r\n        // from being found in FS.nameTable when FS.open is called on\r\n        // a path which holds a child of this node,\r\n        // given that all FS functions assume node names\r\n        // are just their corresponding parts within their given path,\r\n        // rather than incremental aggregates which include their parent's\r\n        // directories.\r\n        if (!createdParents[curr]) {\r\n          createdParents[curr] = WORKERFS.createNode(\r\n            parent,\r\n            parts[i],\r\n            WORKERFS.DIR_MODE,\r\n            0,\r\n          );\r\n        }\r\n        parent = createdParents[curr];\r\n      }\r\n      return parent;\r\n    }\r\n\r\n    function base(path) {\r\n      var parts = path.split(\"/\");\r\n      return parts[parts.length - 1];\r\n    }\r\n\r\n    // We also accept FileList here, by using Array.prototype\r\n    Array.prototype.forEach.call(mount.opts[\"files\"] || [], function (file) {\r\n      WORKERFS.createNode(\r\n        ensureParent(file.name),\r\n        base(file.name),\r\n        WORKERFS.FILE_MODE,\r\n        0,\r\n        file,\r\n        file.lastModifiedDate,\r\n      );\r\n    });\r\n    (mount.opts[\"blobs\"] || []).forEach(function (obj) {\r\n      WORKERFS.createNode(\r\n        ensureParent(obj[\"name\"]),\r\n        base(obj[\"name\"]),\r\n        WORKERFS.FILE_MODE,\r\n        0,\r\n        obj[\"data\"],\r\n      );\r\n    });\r\n    (mount.opts[\"packages\"] || []).forEach(function (pack) {\r\n      pack[\"metadata\"].files.forEach(function (file) {\r\n        var name = file.filename.substr(1); // remove initial slash\r\n        WORKERFS.createNode(\r\n          ensureParent(name),\r\n          base(name),\r\n          WORKERFS.FILE_MODE,\r\n          0,\r\n          pack[\"blob\"].slice(file.start, file.end),\r\n        );\r\n      });\r\n    });\r\n    return root;\r\n  },\r\n  createNode: function (parent, name, mode, dev, contents, mtime) {\r\n    var node = FS.createNode(parent, name, mode);\r\n    node.mode = mode;\r\n    node.node_ops = WORKERFS.node_ops;\r\n    node.stream_ops = WORKERFS.stream_ops;\r\n    node.timestamp = (mtime || new Date()).getTime();\r\n    assert(WORKERFS.FILE_MODE !== WORKERFS.DIR_MODE);\r\n    if (mode === WORKERFS.FILE_MODE) {\r\n      node.size = contents.size;\r\n      node.contents = contents;\r\n    } else {\r\n      node.size = 4096;\r\n      node.contents = {};\r\n    }\r\n    if (parent) {\r\n      parent.contents[name] = node;\r\n    }\r\n    return node;\r\n  },\r\n  node_ops: {\r\n    getattr: function (node) {\r\n      return {\r\n        dev: 1,\r\n        ino: undefined,\r\n        mode: node.mode,\r\n        nlink: 1,\r\n        uid: 0,\r\n        gid: 0,\r\n        rdev: undefined,\r\n        size: node.size,\r\n        atime: new Date(node.timestamp),\r\n        mtime: new Date(node.timestamp),\r\n        ctime: new Date(node.timestamp),\r\n        blksize: 4096,\r\n        blocks: Math.ceil(node.size / 4096),\r\n      };\r\n    },\r\n    setattr: function (node, attr) {\r\n      if (attr.mode !== undefined) {\r\n        node.mode = attr.mode;\r\n      }\r\n      if (attr.timestamp !== undefined) {\r\n        node.timestamp = attr.timestamp;\r\n      }\r\n    },\r\n    lookup: function (parent, name) {\r\n      throw new FS.ErrnoError(ERRNO_CODES.ENOENT);\r\n    },\r\n    mknod: function (parent, name, mode, dev) {\r\n      throw new FS.ErrnoError(ERRNO_CODES.EPERM);\r\n    },\r\n    rename: function (oldNode, newDir, newName) {\r\n      throw new FS.ErrnoError(ERRNO_CODES.EPERM);\r\n    },\r\n    unlink: function (parent, name) {\r\n      throw new FS.ErrnoError(ERRNO_CODES.EPERM);\r\n    },\r\n    rmdir: function (parent, name) {\r\n      throw new FS.ErrnoError(ERRNO_CODES.EPERM);\r\n    },\r\n    readdir: function (node) {\r\n      var entries = [\".\", \"..\"];\r\n      for (var key in node.contents) {\r\n        if (!node.contents.hasOwnProperty(key)) {\r\n          continue;\r\n        }\r\n        entries.push(key);\r\n      }\r\n      return entries;\r\n    },\r\n    symlink: function (parent, newName, oldPath) {\r\n      throw new FS.ErrnoError(ERRNO_CODES.EPERM);\r\n    },\r\n    readlink: function (node) {\r\n      throw new FS.ErrnoError(ERRNO_CODES.EPERM);\r\n    },\r\n  },\r\n  stream_ops: {\r\n    read: function (stream, buffer, offset, length, position) {\r\n      if (position >= stream.node.size) return 0;\r\n      var chunk = stream.node.contents.slice(position, position + length);\r\n      var ab = WORKERFS.reader.readAsArrayBuffer(chunk);\r\n      buffer.set(new Uint8Array(ab), offset);\r\n      return chunk.size;\r\n    },\r\n    write: function (stream, buffer, offset, length, position) {\r\n      throw new FS.ErrnoError(ERRNO_CODES.EIO);\r\n    },\r\n    llseek: function (stream, offset, whence) {\r\n      var position = offset;\r\n      if (whence === 1) {\r\n        // SEEK_CUR.\r\n        position += stream.position;\r\n      } else if (whence === 2) {\r\n        // SEEK_END.\r\n        if (FS.isFile(stream.node.mode)) {\r\n          position += stream.node.size;\r\n        }\r\n      }\r\n      if (position < 0) {\r\n        throw new FS.ErrnoError(ERRNO_CODES.EINVAL);\r\n      }\r\n      return position;\r\n    },\r\n  },\r\n};\r\n\r\nvar ERRNO_MESSAGES = {\r\n  0: \"Success\",\r\n  1: \"Not super-user\",\r\n  2: \"No such file or directory\",\r\n  3: \"No such process\",\r\n  4: \"Interrupted system call\",\r\n  5: \"I/O error\",\r\n  6: \"No such device or address\",\r\n  7: \"Arg list too long\",\r\n  8: \"Exec format error\",\r\n  9: \"Bad file number\",\r\n  10: \"No children\",\r\n  11: \"No more processes\",\r\n  12: \"Not enough core\",\r\n  13: \"Permission denied\",\r\n  14: \"Bad address\",\r\n  15: \"Block device required\",\r\n  16: \"Mount device busy\",\r\n  17: \"File exists\",\r\n  18: \"Cross-device link\",\r\n  19: \"No such device\",\r\n  20: \"Not a directory\",\r\n  21: \"Is a directory\",\r\n  22: \"Invalid argument\",\r\n  23: \"Too many open files in system\",\r\n  24: \"Too many open files\",\r\n  25: \"Not a typewriter\",\r\n  26: \"Text file busy\",\r\n  27: \"File too large\",\r\n  28: \"No space left on device\",\r\n  29: \"Illegal seek\",\r\n  30: \"Read only file system\",\r\n  31: \"Too many links\",\r\n  32: \"Broken pipe\",\r\n  33: \"Math arg out of domain of func\",\r\n  34: \"Math result not representable\",\r\n  35: \"File locking deadlock error\",\r\n  36: \"File or path name too long\",\r\n  37: \"No record locks available\",\r\n  38: \"Function not implemented\",\r\n  39: \"Directory not empty\",\r\n  40: \"Too many symbolic links\",\r\n  42: \"No message of desired type\",\r\n  43: \"Identifier removed\",\r\n  44: \"Channel number out of range\",\r\n  45: \"Level 2 not synchronized\",\r\n  46: \"Level 3 halted\",\r\n  47: \"Level 3 reset\",\r\n  48: \"Link number out of range\",\r\n  49: \"Protocol driver not attached\",\r\n  50: \"No CSI structure available\",\r\n  51: \"Level 2 halted\",\r\n  52: \"Invalid exchange\",\r\n  53: \"Invalid request descriptor\",\r\n  54: \"Exchange full\",\r\n  55: \"No anode\",\r\n  56: \"Invalid request code\",\r\n  57: \"Invalid slot\",\r\n  59: \"Bad font file fmt\",\r\n  60: \"Device not a stream\",\r\n  61: \"No data (for no delay io)\",\r\n  62: \"Timer expired\",\r\n  63: \"Out of streams resources\",\r\n  64: \"Machine is not on the network\",\r\n  65: \"Package not installed\",\r\n  66: \"The object is remote\",\r\n  67: \"The link has been severed\",\r\n  68: \"Advertise error\",\r\n  69: \"Srmount error\",\r\n  70: \"Communication error on send\",\r\n  71: \"Protocol error\",\r\n  72: \"Multihop attempted\",\r\n  73: \"Cross mount point (not really error)\",\r\n  74: \"Trying to read unreadable message\",\r\n  75: \"Value too large for defined data type\",\r\n  76: \"Given log. name not unique\",\r\n  77: \"f.d. invalid for this operation\",\r\n  78: \"Remote address changed\",\r\n  79: \"Can   access a needed shared lib\",\r\n  80: \"Accessing a corrupted shared lib\",\r\n  81: \".lib section in a.out corrupted\",\r\n  82: \"Attempting to link in too many libs\",\r\n  83: \"Attempting to exec a shared library\",\r\n  84: \"Illegal byte sequence\",\r\n  86: \"Streams pipe error\",\r\n  87: \"Too many users\",\r\n  88: \"Socket operation on non-socket\",\r\n  89: \"Destination address required\",\r\n  90: \"Message too long\",\r\n  91: \"Protocol wrong type for socket\",\r\n  92: \"Protocol not available\",\r\n  93: \"Unknown protocol\",\r\n  94: \"Socket type not supported\",\r\n  95: \"Not supported\",\r\n  96: \"Protocol family not supported\",\r\n  97: \"Address family not supported by protocol family\",\r\n  98: \"Address already in use\",\r\n  99: \"Address not available\",\r\n  100: \"Network interface is not configured\",\r\n  101: \"Network is unreachable\",\r\n  102: \"Connection reset by network\",\r\n  103: \"Connection aborted\",\r\n  104: \"Connection reset by peer\",\r\n  105: \"No buffer space available\",\r\n  106: \"Socket is already connected\",\r\n  107: \"Socket is not connected\",\r\n  108: \"Can't send after socket shutdown\",\r\n  109: \"Too many references\",\r\n  110: \"Connection timed out\",\r\n  111: \"Connection refused\",\r\n  112: \"Host is down\",\r\n  113: \"Host is unreachable\",\r\n  114: \"Socket already connected\",\r\n  115: \"Connection already in progress\",\r\n  116: \"Stale file handle\",\r\n  122: \"Quota exceeded\",\r\n  123: \"No medium (in tape drive)\",\r\n  125: \"Operation canceled\",\r\n  130: \"Previous owner died\",\r\n  131: \"State not recoverable\",\r\n};\r\n\r\nvar ERRNO_CODES = {\r\n  EPERM: 1,\r\n  ENOENT: 2,\r\n  ESRCH: 3,\r\n  EINTR: 4,\r\n  EIO: 5,\r\n  ENXIO: 6,\r\n  E2BIG: 7,\r\n  ENOEXEC: 8,\r\n  EBADF: 9,\r\n  ECHILD: 10,\r\n  EAGAIN: 11,\r\n  EWOULDBLOCK: 11,\r\n  ENOMEM: 12,\r\n  EACCES: 13,\r\n  EFAULT: 14,\r\n  ENOTBLK: 15,\r\n  EBUSY: 16,\r\n  EEXIST: 17,\r\n  EXDEV: 18,\r\n  ENODEV: 19,\r\n  ENOTDIR: 20,\r\n  EISDIR: 21,\r\n  EINVAL: 22,\r\n  ENFILE: 23,\r\n  EMFILE: 24,\r\n  ENOTTY: 25,\r\n  ETXTBSY: 26,\r\n  EFBIG: 27,\r\n  ENOSPC: 28,\r\n  ESPIPE: 29,\r\n  EROFS: 30,\r\n  EMLINK: 31,\r\n  EPIPE: 32,\r\n  EDOM: 33,\r\n  ERANGE: 34,\r\n  ENOMSG: 42,\r\n  EIDRM: 43,\r\n  ECHRNG: 44,\r\n  EL2NSYNC: 45,\r\n  EL3HLT: 46,\r\n  EL3RST: 47,\r\n  ELNRNG: 48,\r\n  EUNATCH: 49,\r\n  ENOCSI: 50,\r\n  EL2HLT: 51,\r\n  EDEADLK: 35,\r\n  ENOLCK: 37,\r\n  EBADE: 52,\r\n  EBADR: 53,\r\n  EXFULL: 54,\r\n  ENOANO: 55,\r\n  EBADRQC: 56,\r\n  EBADSLT: 57,\r\n  EDEADLOCK: 35,\r\n  EBFONT: 59,\r\n  ENOSTR: 60,\r\n  ENODATA: 61,\r\n  ETIME: 62,\r\n  ENOSR: 63,\r\n  ENONET: 64,\r\n  ENOPKG: 65,\r\n  EREMOTE: 66,\r\n  ENOLINK: 67,\r\n  EADV: 68,\r\n  ESRMNT: 69,\r\n  ECOMM: 70,\r\n  EPROTO: 71,\r\n  EMULTIHOP: 72,\r\n  EDOTDOT: 73,\r\n  EBADMSG: 74,\r\n  ENOTUNIQ: 76,\r\n  EBADFD: 77,\r\n  EREMCHG: 78,\r\n  ELIBACC: 79,\r\n  ELIBBAD: 80,\r\n  ELIBSCN: 81,\r\n  ELIBMAX: 82,\r\n  ELIBEXEC: 83,\r\n  ENOSYS: 38,\r\n  ENOTEMPTY: 39,\r\n  ENAMETOOLONG: 36,\r\n  ELOOP: 40,\r\n  EOPNOTSUPP: 95,\r\n  EPFNOSUPPORT: 96,\r\n  ECONNRESET: 104,\r\n  ENOBUFS: 105,\r\n  EAFNOSUPPORT: 97,\r\n  EPROTOTYPE: 91,\r\n  ENOTSOCK: 88,\r\n  ENOPROTOOPT: 92,\r\n  ESHUTDOWN: 108,\r\n  ECONNREFUSED: 111,\r\n  EADDRINUSE: 98,\r\n  ECONNABORTED: 103,\r\n  ENETUNREACH: 101,\r\n  ENETDOWN: 100,\r\n  ETIMEDOUT: 110,\r\n  EHOSTDOWN: 112,\r\n  EHOSTUNREACH: 113,\r\n  EINPROGRESS: 115,\r\n  EALREADY: 114,\r\n  EDESTADDRREQ: 89,\r\n  EMSGSIZE: 90,\r\n  EPROTONOSUPPORT: 93,\r\n  ESOCKTNOSUPPORT: 94,\r\n  EADDRNOTAVAIL: 99,\r\n  ENETRESET: 102,\r\n  EISCONN: 106,\r\n  ENOTCONN: 107,\r\n  ETOOMANYREFS: 109,\r\n  EUSERS: 87,\r\n  EDQUOT: 122,\r\n  ESTALE: 116,\r\n  ENOTSUP: 95,\r\n  ENOMEDIUM: 123,\r\n  EILSEQ: 84,\r\n  EOVERFLOW: 75,\r\n  ECANCELED: 125,\r\n  ENOTRECOVERABLE: 131,\r\n  EOWNERDEAD: 130,\r\n  ESTRPIPE: 86,\r\n};\r\n\r\nvar _stdin = 10348704;\r\n\r\nvar _stdout = 10348720;\r\n\r\nvar _stderr = 10348736;\r\nvar FS = {\r\n  root: null,\r\n  mounts: [],\r\n  devices: {},\r\n  streams: [],\r\n  nextInode: 1,\r\n  nameTable: null,\r\n  currentPath: \"/\",\r\n  initialized: false,\r\n  ignorePermissions: true,\r\n  trackingDelegate: {},\r\n  tracking: { openFlags: { READ: 1, WRITE: 2 } },\r\n  ErrnoError: null,\r\n  genericErrors: {},\r\n  filesystems: null,\r\n  syncFSRequests: 0,\r\n  handleFSError: function (e) {\r\n    if (!(e instanceof FS.ErrnoError)) throw e + \" : \" + stackTrace();\r\n    return ___setErrNo(e.errno);\r\n  },\r\n  lookupPath: function (path, opts) {\r\n    path = PATH.resolve(FS.cwd(), path);\r\n    opts = opts || {};\r\n\r\n    if (!path) return { path: \"\", node: null };\r\n\r\n    var defaults = {\r\n      follow_mount: true,\r\n      recurse_count: 0,\r\n    };\r\n    for (var key in defaults) {\r\n      if (opts[key] === undefined) {\r\n        opts[key] = defaults[key];\r\n      }\r\n    }\r\n\r\n    if (opts.recurse_count > 8) {\r\n      // max recursive lookup of 8\r\n      throw new FS.ErrnoError(40);\r\n    }\r\n\r\n    // split the path\r\n    var parts = PATH.normalizeArray(\r\n      path.split(\"/\").filter(function (p) {\r\n        return !!p;\r\n      }),\r\n      false,\r\n    );\r\n\r\n    // start at the root\r\n    var current = FS.root;\r\n    var current_path = \"/\";\r\n\r\n    for (var i = 0; i < parts.length; i++) {\r\n      var islast = i === parts.length - 1;\r\n      if (islast && opts.parent) {\r\n        // stop resolving\r\n        break;\r\n      }\r\n\r\n      current = FS.lookupNode(current, parts[i]);\r\n      current_path = PATH.join2(current_path, parts[i]);\r\n\r\n      // jump to the mount's root node if this is a mountpoint\r\n      if (FS.isMountpoint(current)) {\r\n        if (!islast || (islast && opts.follow_mount)) {\r\n          current = current.mounted.root;\r\n        }\r\n      }\r\n\r\n      // by default, lookupPath will not follow a symlink if it is the final path component.\r\n      // setting opts.follow = true will override this behavior.\r\n      if (!islast || opts.follow) {\r\n        var count = 0;\r\n        while (FS.isLink(current.mode)) {\r\n          var link = FS.readlink(current_path);\r\n          current_path = PATH.resolve(PATH.dirname(current_path), link);\r\n\r\n          var lookup = FS.lookupPath(current_path, {\r\n            recurse_count: opts.recurse_count,\r\n          });\r\n          current = lookup.node;\r\n\r\n          if (count++ > 40) {\r\n            // limit max consecutive symlinks to 40 (SYMLOOP_MAX).\r\n            throw new FS.ErrnoError(40);\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    return { path: current_path, node: current };\r\n  },\r\n  getPath: function (node) {\r\n    var path;\r\n    while (true) {\r\n      if (FS.isRoot(node)) {\r\n        var mount = node.mount.mountpoint;\r\n        if (!path) return mount;\r\n        return mount[mount.length - 1] !== \"/\"\r\n          ? mount + \"/\" + path\r\n          : mount + path;\r\n      }\r\n      path = path ? node.name + \"/\" + path : node.name;\r\n      node = node.parent;\r\n    }\r\n  },\r\n  hashName: function (parentid, name) {\r\n    var hash = 0;\r\n\r\n    for (var i = 0; i < name.length; i++) {\r\n      hash = ((hash << 5) - hash + name.charCodeAt(i)) | 0;\r\n    }\r\n    return ((parentid + hash) >>> 0) % FS.nameTable.length;\r\n  },\r\n  hashAddNode: function (node) {\r\n    var hash = FS.hashName(node.parent.id, node.name);\r\n    node.name_next = FS.nameTable[hash];\r\n    FS.nameTable[hash] = node;\r\n  },\r\n  hashRemoveNode: function (node) {\r\n    var hash = FS.hashName(node.parent.id, node.name);\r\n    if (FS.nameTable[hash] === node) {\r\n      FS.nameTable[hash] = node.name_next;\r\n    } else {\r\n      var current = FS.nameTable[hash];\r\n      while (current) {\r\n        if (current.name_next === node) {\r\n          current.name_next = node.name_next;\r\n          break;\r\n        }\r\n        current = current.name_next;\r\n      }\r\n    }\r\n  },\r\n  lookupNode: function (parent, name) {\r\n    var err = FS.mayLookup(parent);\r\n    if (err) {\r\n      throw new FS.ErrnoError(err, parent);\r\n    }\r\n    var hash = FS.hashName(parent.id, name);\r\n    for (var node = FS.nameTable[hash]; node; node = node.name_next) {\r\n      var nodeName = node.name;\r\n      if (node.parent.id === parent.id && nodeName === name) {\r\n        return node;\r\n      }\r\n    }\r\n    // if we failed to find it in the cache, call into the VFS\r\n    return FS.lookup(parent, name);\r\n  },\r\n  createNode: function (parent, name, mode, rdev) {\r\n    if (!FS.FSNode) {\r\n      FS.FSNode = function (parent, name, mode, rdev) {\r\n        if (!parent) {\r\n          parent = this; // root node sets parent to itself\r\n        }\r\n        this.parent = parent;\r\n        this.mount = parent.mount;\r\n        this.mounted = null;\r\n        this.id = FS.nextInode++;\r\n        this.name = name;\r\n        this.mode = mode;\r\n        this.node_ops = {};\r\n        this.stream_ops = {};\r\n        this.rdev = rdev;\r\n      };\r\n\r\n      FS.FSNode.prototype = {};\r\n\r\n      // compatibility\r\n      var readMode = 292 | 73;\r\n      var writeMode = 146;\r\n\r\n      // NOTE we must use Object.defineProperties instead of individual calls to\r\n      // Object.defineProperty in order to make closure compiler happy\r\n      Object.defineProperties(FS.FSNode.prototype, {\r\n        read: {\r\n          get: function () {\r\n            return (this.mode & readMode) === readMode;\r\n          },\r\n          set: function (val) {\r\n            val ? (this.mode |= readMode) : (this.mode &= ~readMode);\r\n          },\r\n        },\r\n        write: {\r\n          get: function () {\r\n            return (this.mode & writeMode) === writeMode;\r\n          },\r\n          set: function (val) {\r\n            val ? (this.mode |= writeMode) : (this.mode &= ~writeMode);\r\n          },\r\n        },\r\n        isFolder: {\r\n          get: function () {\r\n            return FS.isDir(this.mode);\r\n          },\r\n        },\r\n        isDevice: {\r\n          get: function () {\r\n            return FS.isChrdev(this.mode);\r\n          },\r\n        },\r\n      });\r\n    }\r\n\r\n    var node = new FS.FSNode(parent, name, mode, rdev);\r\n\r\n    FS.hashAddNode(node);\r\n\r\n    return node;\r\n  },\r\n  destroyNode: function (node) {\r\n    FS.hashRemoveNode(node);\r\n  },\r\n  isRoot: function (node) {\r\n    return node === node.parent;\r\n  },\r\n  isMountpoint: function (node) {\r\n    return !!node.mounted;\r\n  },\r\n  isFile: function (mode) {\r\n    return (mode & 61440) === 32768;\r\n  },\r\n  isDir: function (mode) {\r\n    return (mode & 61440) === 16384;\r\n  },\r\n  isLink: function (mode) {\r\n    return (mode & 61440) === 40960;\r\n  },\r\n  isChrdev: function (mode) {\r\n    return (mode & 61440) === 8192;\r\n  },\r\n  isBlkdev: function (mode) {\r\n    return (mode & 61440) === 24576;\r\n  },\r\n  isFIFO: function (mode) {\r\n    return (mode & 61440) === 4096;\r\n  },\r\n  isSocket: function (mode) {\r\n    return (mode & 49152) === 49152;\r\n  },\r\n  flagModes: {\r\n    r: 0,\r\n    rs: 1052672,\r\n    \"r+\": 2,\r\n    w: 577,\r\n    wx: 705,\r\n    xw: 705,\r\n    \"w+\": 578,\r\n    \"wx+\": 706,\r\n    \"xw+\": 706,\r\n    a: 1089,\r\n    ax: 1217,\r\n    xa: 1217,\r\n    \"a+\": 1090,\r\n    \"ax+\": 1218,\r\n    \"xa+\": 1218,\r\n  },\r\n  modeStringToFlags: function (str) {\r\n    var flags = FS.flagModes[str];\r\n    if (typeof flags === \"undefined\") {\r\n      throw new Error(\"Unknown file open mode: \" + str);\r\n    }\r\n    return flags;\r\n  },\r\n  flagsToPermissionString: function (flag) {\r\n    var perms = [\"r\", \"w\", \"rw\"][flag & 3];\r\n    if (flag & 512) {\r\n      perms += \"w\";\r\n    }\r\n    return perms;\r\n  },\r\n  nodePermissions: function (node, perms) {\r\n    if (FS.ignorePermissions) {\r\n      return 0;\r\n    }\r\n    // return 0 if any user, group or owner bits are set.\r\n    if (perms.indexOf(\"r\") !== -1 && !(node.mode & 292)) {\r\n      return 13;\r\n    } else if (perms.indexOf(\"w\") !== -1 && !(node.mode & 146)) {\r\n      return 13;\r\n    } else if (perms.indexOf(\"x\") !== -1 && !(node.mode & 73)) {\r\n      return 13;\r\n    }\r\n    return 0;\r\n  },\r\n  mayLookup: function (dir) {\r\n    var err = FS.nodePermissions(dir, \"x\");\r\n    if (err) return err;\r\n    if (!dir.node_ops.lookup) return 13;\r\n    return 0;\r\n  },\r\n  mayCreate: function (dir, name) {\r\n    try {\r\n      var node = FS.lookupNode(dir, name);\r\n      return 17;\r\n    } catch (e) {}\r\n    return FS.nodePermissions(dir, \"wx\");\r\n  },\r\n  mayDelete: function (dir, name, isdir) {\r\n    var node;\r\n    try {\r\n      node = FS.lookupNode(dir, name);\r\n    } catch (e) {\r\n      return e.errno;\r\n    }\r\n    var err = FS.nodePermissions(dir, \"wx\");\r\n    if (err) {\r\n      return err;\r\n    }\r\n    if (isdir) {\r\n      if (!FS.isDir(node.mode)) {\r\n        return 20;\r\n      }\r\n      if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {\r\n        return 16;\r\n      }\r\n    } else {\r\n      if (FS.isDir(node.mode)) {\r\n        return 21;\r\n      }\r\n    }\r\n    return 0;\r\n  },\r\n  mayOpen: function (node, flags) {\r\n    if (!node) {\r\n      return 2;\r\n    }\r\n    if (FS.isLink(node.mode)) {\r\n      return 40;\r\n    } else if (FS.isDir(node.mode)) {\r\n      if (\r\n        FS.flagsToPermissionString(flags) !== \"r\" || // opening for write\r\n        flags & 512\r\n      ) {\r\n        // TODO: check for O_SEARCH? (== search for dir only)\r\n        return 21;\r\n      }\r\n    }\r\n    return FS.nodePermissions(node, FS.flagsToPermissionString(flags));\r\n  },\r\n  MAX_OPEN_FDS: 4096,\r\n  nextfd: function (fd_start, fd_end) {\r\n    fd_start = fd_start || 0;\r\n    fd_end = fd_end || FS.MAX_OPEN_FDS;\r\n    for (var fd = fd_start; fd <= fd_end; fd++) {\r\n      if (!FS.streams[fd]) {\r\n        return fd;\r\n      }\r\n    }\r\n    throw new FS.ErrnoError(24);\r\n  },\r\n  getStream: function (fd) {\r\n    return FS.streams[fd];\r\n  },\r\n  createStream: function (stream, fd_start, fd_end) {\r\n    if (!FS.FSStream) {\r\n      FS.FSStream = function () {};\r\n      FS.FSStream.prototype = {};\r\n      // compatibility\r\n      Object.defineProperties(FS.FSStream.prototype, {\r\n        object: {\r\n          get: function () {\r\n            return this.node;\r\n          },\r\n          set: function (val) {\r\n            this.node = val;\r\n          },\r\n        },\r\n        isRead: {\r\n          get: function () {\r\n            return (this.flags & 2097155) !== 1;\r\n          },\r\n        },\r\n        isWrite: {\r\n          get: function () {\r\n            return (this.flags & 2097155) !== 0;\r\n          },\r\n        },\r\n        isAppend: {\r\n          get: function () {\r\n            return this.flags & 1024;\r\n          },\r\n        },\r\n      });\r\n    }\r\n    // clone it, so we can return an instance of FSStream\r\n    var newStream = new FS.FSStream();\r\n    for (var p in stream) {\r\n      newStream[p] = stream[p];\r\n    }\r\n    stream = newStream;\r\n    var fd = FS.nextfd(fd_start, fd_end);\r\n    stream.fd = fd;\r\n    FS.streams[fd] = stream;\r\n    return stream;\r\n  },\r\n  closeStream: function (fd) {\r\n    FS.streams[fd] = null;\r\n  },\r\n  chrdev_stream_ops: {\r\n    open: function (stream) {\r\n      var device = FS.getDevice(stream.node.rdev);\r\n      // override node's stream ops with the device's\r\n      stream.stream_ops = device.stream_ops;\r\n      // forward the open call\r\n      if (stream.stream_ops.open) {\r\n        stream.stream_ops.open(stream);\r\n      }\r\n    },\r\n    llseek: function () {\r\n      throw new FS.ErrnoError(29);\r\n    },\r\n  },\r\n  major: function (dev) {\r\n    return dev >> 8;\r\n  },\r\n  minor: function (dev) {\r\n    return dev & 0xff;\r\n  },\r\n  makedev: function (ma, mi) {\r\n    return (ma << 8) | mi;\r\n  },\r\n  registerDevice: function (dev, ops) {\r\n    FS.devices[dev] = { stream_ops: ops };\r\n  },\r\n  getDevice: function (dev) {\r\n    return FS.devices[dev];\r\n  },\r\n  getMounts: function (mount) {\r\n    var mounts = [];\r\n    var check = [mount];\r\n\r\n    while (check.length) {\r\n      var m = check.pop();\r\n\r\n      mounts.push(m);\r\n\r\n      check.push.apply(check, m.mounts);\r\n    }\r\n\r\n    return mounts;\r\n  },\r\n  syncfs: function (populate, callback) {\r\n    if (typeof populate === \"function\") {\r\n      callback = populate;\r\n      populate = false;\r\n    }\r\n\r\n    FS.syncFSRequests++;\r\n\r\n    if (FS.syncFSRequests > 1) {\r\n      console.log(\r\n        \"warning: \" +\r\n          FS.syncFSRequests +\r\n          \" FS.syncfs operations in flight at once, probably just doing extra work\",\r\n      );\r\n    }\r\n\r\n    var mounts = FS.getMounts(FS.root.mount);\r\n    var completed = 0;\r\n\r\n    function doCallback(err) {\r\n      assert(FS.syncFSRequests > 0);\r\n      FS.syncFSRequests--;\r\n      return callback(err);\r\n    }\r\n\r\n    function done(err) {\r\n      if (err) {\r\n        if (!done.errored) {\r\n          done.errored = true;\r\n          return doCallback(err);\r\n        }\r\n        return;\r\n      }\r\n      if (++completed >= mounts.length) {\r\n        doCallback(null);\r\n      }\r\n    }\r\n\r\n    // sync all mounts\r\n    mounts.forEach(function (mount) {\r\n      if (!mount.type.syncfs) {\r\n        return done(null);\r\n      }\r\n      mount.type.syncfs(mount, populate, done);\r\n    });\r\n  },\r\n  mount: function (type, opts, mountpoint) {\r\n    var root = mountpoint === \"/\";\r\n    var pseudo = !mountpoint;\r\n    var node;\r\n\r\n    if (root && FS.root) {\r\n      throw new FS.ErrnoError(16);\r\n    } else if (!root && !pseudo) {\r\n      var lookup = FS.lookupPath(mountpoint, { follow_mount: false });\r\n\r\n      mountpoint = lookup.path; // use the absolute path\r\n      node = lookup.node;\r\n\r\n      if (FS.isMountpoint(node)) {\r\n        throw new FS.ErrnoError(16);\r\n      }\r\n\r\n      if (!FS.isDir(node.mode)) {\r\n        throw new FS.ErrnoError(20);\r\n      }\r\n    }\r\n\r\n    var mount = {\r\n      type: type,\r\n      opts: opts,\r\n      mountpoint: mountpoint,\r\n      mounts: [],\r\n    };\r\n\r\n    // create a root node for the fs\r\n    var mountRoot = type.mount(mount);\r\n    mountRoot.mount = mount;\r\n    mount.root = mountRoot;\r\n\r\n    if (root) {\r\n      FS.root = mountRoot;\r\n    } else if (node) {\r\n      // set as a mountpoint\r\n      node.mounted = mount;\r\n\r\n      // add the new mount to the current mount's children\r\n      if (node.mount) {\r\n        node.mount.mounts.push(mount);\r\n      }\r\n    }\r\n\r\n    return mountRoot;\r\n  },\r\n  unmount: function (mountpoint) {\r\n    var lookup = FS.lookupPath(mountpoint, { follow_mount: false });\r\n\r\n    if (!FS.isMountpoint(lookup.node)) {\r\n      throw new FS.ErrnoError(22);\r\n    }\r\n\r\n    // destroy the nodes for this mount, and all its child mounts\r\n    var node = lookup.node;\r\n    var mount = node.mounted;\r\n    var mounts = FS.getMounts(mount);\r\n\r\n    Object.keys(FS.nameTable).forEach(function (hash) {\r\n      var current = FS.nameTable[hash];\r\n\r\n      while (current) {\r\n        var next = current.name_next;\r\n\r\n        if (mounts.indexOf(current.mount) !== -1) {\r\n          FS.destroyNode(current);\r\n        }\r\n\r\n        current = next;\r\n      }\r\n    });\r\n\r\n    // no longer a mountpoint\r\n    node.mounted = null;\r\n\r\n    // remove this mount from the child mounts\r\n    var idx = node.mount.mounts.indexOf(mount);\r\n    assert(idx !== -1);\r\n    node.mount.mounts.splice(idx, 1);\r\n  },\r\n  lookup: function (parent, name) {\r\n    return parent.node_ops.lookup(parent, name);\r\n  },\r\n  mknod: function (path, mode, dev) {\r\n    var lookup = FS.lookupPath(path, { parent: true });\r\n    var parent = lookup.node;\r\n    var name = PATH.basename(path);\r\n    if (!name || name === \".\" || name === \"..\") {\r\n      throw new FS.ErrnoError(22);\r\n    }\r\n    var err = FS.mayCreate(parent, name);\r\n    if (err) {\r\n      throw new FS.ErrnoError(err);\r\n    }\r\n    if (!parent.node_ops.mknod) {\r\n      throw new FS.ErrnoError(1);\r\n    }\r\n    return parent.node_ops.mknod(parent, name, mode, dev);\r\n  },\r\n  create: function (path, mode) {\r\n    mode = mode !== undefined ? mode : 438 /* 0666 */;\r\n    mode &= 4095;\r\n    mode |= 32768;\r\n    return FS.mknod(path, mode, 0);\r\n  },\r\n  mkdir: function (path, mode) {\r\n    mode = mode !== undefined ? mode : 511 /* 0777 */;\r\n    mode &= 511 | 512;\r\n    mode |= 16384;\r\n    return FS.mknod(path, mode, 0);\r\n  },\r\n  mkdirTree: function (path, mode) {\r\n    var dirs = path.split(\"/\");\r\n    var d = \"\";\r\n    for (var i = 0; i < dirs.length; ++i) {\r\n      if (!dirs[i]) continue;\r\n      d += \"/\" + dirs[i];\r\n      try {\r\n        FS.mkdir(d, mode);\r\n      } catch (e) {\r\n        if (e.errno != 17) throw e;\r\n      }\r\n    }\r\n  },\r\n  mkdev: function (path, mode, dev) {\r\n    if (typeof dev === \"undefined\") {\r\n      dev = mode;\r\n      mode = 438 /* 0666 */;\r\n    }\r\n    mode |= 8192;\r\n    return FS.mknod(path, mode, dev);\r\n  },\r\n  symlink: function (oldpath, newpath) {\r\n    if (!PATH.resolve(oldpath)) {\r\n      throw new FS.ErrnoError(2);\r\n    }\r\n    var lookup = FS.lookupPath(newpath, { parent: true });\r\n    var parent = lookup.node;\r\n    if (!parent) {\r\n      throw new FS.ErrnoError(2);\r\n    }\r\n    var newname = PATH.basename(newpath);\r\n    var err = FS.mayCreate(parent, newname);\r\n    if (err) {\r\n      throw new FS.ErrnoError(err);\r\n    }\r\n    if (!parent.node_ops.symlink) {\r\n      throw new FS.ErrnoError(1);\r\n    }\r\n    return parent.node_ops.symlink(parent, newname, oldpath);\r\n  },\r\n  rename: function (old_path, new_path) {\r\n    var old_dirname = PATH.dirname(old_path);\r\n    var new_dirname = PATH.dirname(new_path);\r\n    var old_name = PATH.basename(old_path);\r\n    var new_name = PATH.basename(new_path);\r\n    // parents must exist\r\n    var lookup, old_dir, new_dir;\r\n    try {\r\n      lookup = FS.lookupPath(old_path, { parent: true });\r\n      old_dir = lookup.node;\r\n      lookup = FS.lookupPath(new_path, { parent: true });\r\n      new_dir = lookup.node;\r\n    } catch (e) {\r\n      throw new FS.ErrnoError(16);\r\n    }\r\n    if (!old_dir || !new_dir) throw new FS.ErrnoError(2);\r\n    // need to be part of the same mount\r\n    if (old_dir.mount !== new_dir.mount) {\r\n      throw new FS.ErrnoError(18);\r\n    }\r\n    // source must exist\r\n    var old_node = FS.lookupNode(old_dir, old_name);\r\n    // old path should not be an ancestor of the new path\r\n    var relative = PATH.relative(old_path, new_dirname);\r\n    if (relative.charAt(0) !== \".\") {\r\n      throw new FS.ErrnoError(22);\r\n    }\r\n    // new path should not be an ancestor of the old path\r\n    relative = PATH.relative(new_path, old_dirname);\r\n    if (relative.charAt(0) !== \".\") {\r\n      throw new FS.ErrnoError(39);\r\n    }\r\n    // see if the new path already exists\r\n    var new_node;\r\n    try {\r\n      new_node = FS.lookupNode(new_dir, new_name);\r\n    } catch (e) {\r\n      // not fatal\r\n    }\r\n    // early out if nothing needs to change\r\n    if (old_node === new_node) {\r\n      return;\r\n    }\r\n    // we'll need to delete the old entry\r\n    var isdir = FS.isDir(old_node.mode);\r\n    var err = FS.mayDelete(old_dir, old_name, isdir);\r\n    if (err) {\r\n      throw new FS.ErrnoError(err);\r\n    }\r\n    // need delete permissions if we'll be overwriting.\r\n    // need create permissions if new doesn't already exist.\r\n    err = new_node\r\n      ? FS.mayDelete(new_dir, new_name, isdir)\r\n      : FS.mayCreate(new_dir, new_name);\r\n    if (err) {\r\n      throw new FS.ErrnoError(err);\r\n    }\r\n    if (!old_dir.node_ops.rename) {\r\n      throw new FS.ErrnoError(1);\r\n    }\r\n    if (FS.isMountpoint(old_node) || (new_node && FS.isMountpoint(new_node))) {\r\n      throw new FS.ErrnoError(16);\r\n    }\r\n    // if we are going to change the parent, check write permissions\r\n    if (new_dir !== old_dir) {\r\n      err = FS.nodePermissions(old_dir, \"w\");\r\n      if (err) {\r\n        throw new FS.ErrnoError(err);\r\n      }\r\n    }\r\n    try {\r\n      if (FS.trackingDelegate[\"willMovePath\"]) {\r\n        FS.trackingDelegate[\"willMovePath\"](old_path, new_path);\r\n      }\r\n    } catch (e) {\r\n      console.log(\r\n        \"FS.trackingDelegate['willMovePath']('\" +\r\n          old_path +\r\n          \"', '\" +\r\n          new_path +\r\n          \"') threw an exception: \" +\r\n          e.message,\r\n      );\r\n    }\r\n    // remove the node from the lookup hash\r\n    FS.hashRemoveNode(old_node);\r\n    // do the underlying fs rename\r\n    try {\r\n      old_dir.node_ops.rename(old_node, new_dir, new_name);\r\n    } catch (e) {\r\n      throw e;\r\n    } finally {\r\n      // add the node back to the hash (in case node_ops.rename\r\n      // changed its name)\r\n      FS.hashAddNode(old_node);\r\n    }\r\n    try {\r\n      if (FS.trackingDelegate[\"onMovePath\"])\r\n        FS.trackingDelegate[\"onMovePath\"](old_path, new_path);\r\n    } catch (e) {\r\n      console.log(\r\n        \"FS.trackingDelegate['onMovePath']('\" +\r\n          old_path +\r\n          \"', '\" +\r\n          new_path +\r\n          \"') threw an exception: \" +\r\n          e.message,\r\n      );\r\n    }\r\n  },\r\n  rmdir: function (path) {\r\n    var lookup = FS.lookupPath(path, { parent: true });\r\n    var parent = lookup.node;\r\n    var name = PATH.basename(path);\r\n    var node = FS.lookupNode(parent, name);\r\n    var err = FS.mayDelete(parent, name, true);\r\n    if (err) {\r\n      throw new FS.ErrnoError(err);\r\n    }\r\n    if (!parent.node_ops.rmdir) {\r\n      throw new FS.ErrnoError(1);\r\n    }\r\n    if (FS.isMountpoint(node)) {\r\n      throw new FS.ErrnoError(16);\r\n    }\r\n    try {\r\n      if (FS.trackingDelegate[\"willDeletePath\"]) {\r\n        FS.trackingDelegate[\"willDeletePath\"](path);\r\n      }\r\n    } catch (e) {\r\n      console.log(\r\n        \"FS.trackingDelegate['willDeletePath']('\" +\r\n          path +\r\n          \"') threw an exception: \" +\r\n          e.message,\r\n      );\r\n    }\r\n    parent.node_ops.rmdir(parent, name);\r\n    FS.destroyNode(node);\r\n    try {\r\n      if (FS.trackingDelegate[\"onDeletePath\"])\r\n        FS.trackingDelegate[\"onDeletePath\"](path);\r\n    } catch (e) {\r\n      console.log(\r\n        \"FS.trackingDelegate['onDeletePath']('\" +\r\n          path +\r\n          \"') threw an exception: \" +\r\n          e.message,\r\n      );\r\n    }\r\n  },\r\n  readdir: function (path) {\r\n    var lookup = FS.lookupPath(path, { follow: true });\r\n    var node = lookup.node;\r\n    if (!node.node_ops.readdir) {\r\n      throw new FS.ErrnoError(20);\r\n    }\r\n    return node.node_ops.readdir(node);\r\n  },\r\n  unlink: function (path) {\r\n    var lookup = FS.lookupPath(path, { parent: true });\r\n    var parent = lookup.node;\r\n    var name = PATH.basename(path);\r\n    var node = FS.lookupNode(parent, name);\r\n    var err = FS.mayDelete(parent, name, false);\r\n    if (err) {\r\n      // According to POSIX, we should map EISDIR to EPERM, but\r\n      // we instead do what Linux does (and we must, as we use\r\n      // the musl linux libc).\r\n      throw new FS.ErrnoError(err);\r\n    }\r\n    if (!parent.node_ops.unlink) {\r\n      throw new FS.ErrnoError(1);\r\n    }\r\n    if (FS.isMountpoint(node)) {\r\n      throw new FS.ErrnoError(16);\r\n    }\r\n    try {\r\n      if (FS.trackingDelegate[\"willDeletePath\"]) {\r\n        FS.trackingDelegate[\"willDeletePath\"](path);\r\n      }\r\n    } catch (e) {\r\n      console.log(\r\n        \"FS.trackingDelegate['willDeletePath']('\" +\r\n          path +\r\n          \"') threw an exception: \" +\r\n          e.message,\r\n      );\r\n    }\r\n    parent.node_ops.unlink(parent, name);\r\n    FS.destroyNode(node);\r\n    try {\r\n      if (FS.trackingDelegate[\"onDeletePath\"])\r\n        FS.trackingDelegate[\"onDeletePath\"](path);\r\n    } catch (e) {\r\n      console.log(\r\n        \"FS.trackingDelegate['onDeletePath']('\" +\r\n          path +\r\n          \"') threw an exception: \" +\r\n          e.message,\r\n      );\r\n    }\r\n  },\r\n  readlink: function (path) {\r\n    var lookup = FS.lookupPath(path);\r\n    var link = lookup.node;\r\n    if (!link) {\r\n      throw new FS.ErrnoError(2);\r\n    }\r\n    if (!link.node_ops.readlink) {\r\n      throw new FS.ErrnoError(22);\r\n    }\r\n    return PATH.resolve(FS.getPath(link.parent), link.node_ops.readlink(link));\r\n  },\r\n  stat: function (path, dontFollow) {\r\n    var lookup = FS.lookupPath(path, { follow: !dontFollow });\r\n    var node = lookup.node;\r\n    if (!node) {\r\n      throw new FS.ErrnoError(2);\r\n    }\r\n    if (!node.node_ops.getattr) {\r\n      throw new FS.ErrnoError(1);\r\n    }\r\n    return node.node_ops.getattr(node);\r\n  },\r\n  lstat: function (path) {\r\n    return FS.stat(path, true);\r\n  },\r\n  chmod: function (path, mode, dontFollow) {\r\n    var node;\r\n    if (typeof path === \"string\") {\r\n      var lookup = FS.lookupPath(path, { follow: !dontFollow });\r\n      node = lookup.node;\r\n    } else {\r\n      node = path;\r\n    }\r\n    if (!node.node_ops.setattr) {\r\n      throw new FS.ErrnoError(1);\r\n    }\r\n    node.node_ops.setattr(node, {\r\n      mode: (mode & 4095) | (node.mode & ~4095),\r\n      timestamp: Date.now(),\r\n    });\r\n  },\r\n  lchmod: function (path, mode) {\r\n    FS.chmod(path, mode, true);\r\n  },\r\n  fchmod: function (fd, mode) {\r\n    var stream = FS.getStream(fd);\r\n    if (!stream) {\r\n      throw new FS.ErrnoError(9);\r\n    }\r\n    FS.chmod(stream.node, mode);\r\n  },\r\n  chown: function (path, uid, gid, dontFollow) {\r\n    var node;\r\n    if (typeof path === \"string\") {\r\n      var lookup = FS.lookupPath(path, { follow: !dontFollow });\r\n      node = lookup.node;\r\n    } else {\r\n      node = path;\r\n    }\r\n    if (!node.node_ops.setattr) {\r\n      throw new FS.ErrnoError(1);\r\n    }\r\n    node.node_ops.setattr(node, {\r\n      timestamp: Date.now(),\r\n      // we ignore the uid / gid for now\r\n    });\r\n  },\r\n  lchown: function (path, uid, gid) {\r\n    FS.chown(path, uid, gid, true);\r\n  },\r\n  fchown: function (fd, uid, gid) {\r\n    var stream = FS.getStream(fd);\r\n    if (!stream) {\r\n      throw new FS.ErrnoError(9);\r\n    }\r\n    FS.chown(stream.node, uid, gid);\r\n  },\r\n  truncate: function (path, len) {\r\n    if (len < 0) {\r\n      throw new FS.ErrnoError(22);\r\n    }\r\n    var node;\r\n    if (typeof path === \"string\") {\r\n      var lookup = FS.lookupPath(path, { follow: true });\r\n      node = lookup.node;\r\n    } else {\r\n      node = path;\r\n    }\r\n    if (!node.node_ops.setattr) {\r\n      throw new FS.ErrnoError(1);\r\n    }\r\n    if (FS.isDir(node.mode)) {\r\n      throw new FS.ErrnoError(21);\r\n    }\r\n    if (!FS.isFile(node.mode)) {\r\n      throw new FS.ErrnoError(22);\r\n    }\r\n    var err = FS.nodePermissions(node, \"w\");\r\n    if (err) {\r\n      throw new FS.ErrnoError(err);\r\n    }\r\n    node.node_ops.setattr(node, {\r\n      size: len,\r\n      timestamp: Date.now(),\r\n    });\r\n  },\r\n  ftruncate: function (fd, len) {\r\n    var stream = FS.getStream(fd);\r\n    if (!stream) {\r\n      throw new FS.ErrnoError(9);\r\n    }\r\n    if ((stream.flags & 2097155) === 0) {\r\n      throw new FS.ErrnoError(22);\r\n    }\r\n    FS.truncate(stream.node, len);\r\n  },\r\n  utime: function (path, atime, mtime) {\r\n    var lookup = FS.lookupPath(path, { follow: true });\r\n    var node = lookup.node;\r\n    node.node_ops.setattr(node, {\r\n      timestamp: Math.max(atime, mtime),\r\n    });\r\n  },\r\n  open: function (path, flags, mode, fd_start, fd_end) {\r\n    if (path === \"\") {\r\n      throw new FS.ErrnoError(2);\r\n    }\r\n    flags = typeof flags === \"string\" ? FS.modeStringToFlags(flags) : flags;\r\n    mode = typeof mode === \"undefined\" ? 438 /* 0666 */ : mode;\r\n    if (flags & 64) {\r\n      mode = (mode & 4095) | 32768;\r\n    } else {\r\n      mode = 0;\r\n    }\r\n    var node;\r\n    if (typeof path === \"object\") {\r\n      node = path;\r\n    } else {\r\n      path = PATH.normalize(path);\r\n      try {\r\n        var lookup = FS.lookupPath(path, {\r\n          follow: !(flags & 131072),\r\n        });\r\n        node = lookup.node;\r\n      } catch (e) {\r\n        // ignore\r\n      }\r\n    }\r\n    // perhaps we need to create the node\r\n    var created = false;\r\n    if (flags & 64) {\r\n      if (node) {\r\n        // if O_CREAT and O_EXCL are set, error out if the node already exists\r\n        if (flags & 128) {\r\n          throw new FS.ErrnoError(17);\r\n        }\r\n      } else {\r\n        // node doesn't exist, try to create it\r\n        node = FS.mknod(path, mode, 0);\r\n        created = true;\r\n      }\r\n    }\r\n    if (!node) {\r\n      throw new FS.ErrnoError(2);\r\n    }\r\n    // can't truncate a device\r\n    if (FS.isChrdev(node.mode)) {\r\n      flags &= ~512;\r\n    }\r\n    // if asked only for a directory, then this must be one\r\n    if (flags & 65536 && !FS.isDir(node.mode)) {\r\n      throw new FS.ErrnoError(20);\r\n    }\r\n    // check permissions, if this is not a file we just created now (it is ok to\r\n    // create and write to a file with read-only permissions; it is read-only\r\n    // for later use)\r\n    if (!created) {\r\n      var err = FS.mayOpen(node, flags);\r\n      if (err) {\r\n        throw new FS.ErrnoError(err);\r\n      }\r\n    }\r\n    // do truncation if necessary\r\n    if (flags & 512) {\r\n      FS.truncate(node, 0);\r\n    }\r\n    // we've already handled these, don't pass down to the underlying vfs\r\n    flags &= ~(128 | 512);\r\n\r\n    // register the stream with the filesystem\r\n    var stream = FS.createStream(\r\n      {\r\n        node: node,\r\n        path: FS.getPath(node), // we want the absolute path to the node\r\n        flags: flags,\r\n        seekable: true,\r\n        position: 0,\r\n        stream_ops: node.stream_ops,\r\n        // used by the file family libc calls (fopen, fwrite, ferror, etc.)\r\n        ungotten: [],\r\n        error: false,\r\n      },\r\n      fd_start,\r\n      fd_end,\r\n    );\r\n    // call the new stream's open function\r\n    if (stream.stream_ops.open) {\r\n      stream.stream_ops.open(stream);\r\n    }\r\n    if (Module[\"logReadFiles\"] && !(flags & 1)) {\r\n      if (!FS.readFiles) FS.readFiles = {};\r\n      if (!(path in FS.readFiles)) {\r\n        FS.readFiles[path] = 1;\r\n        console.log(\"FS.trackingDelegate error on read file: \" + path);\r\n      }\r\n    }\r\n    try {\r\n      if (FS.trackingDelegate[\"onOpenFile\"]) {\r\n        var trackingFlags = 0;\r\n        if ((flags & 2097155) !== 1) {\r\n          trackingFlags |= FS.tracking.openFlags.READ;\r\n        }\r\n        if ((flags & 2097155) !== 0) {\r\n          trackingFlags |= FS.tracking.openFlags.WRITE;\r\n        }\r\n        FS.trackingDelegate[\"onOpenFile\"](path, trackingFlags);\r\n      }\r\n    } catch (e) {\r\n      console.log(\r\n        \"FS.trackingDelegate['onOpenFile']('\" +\r\n          path +\r\n          \"', flags) threw an exception: \" +\r\n          e.message,\r\n      );\r\n    }\r\n    return stream;\r\n  },\r\n  close: function (stream) {\r\n    if (FS.isClosed(stream)) {\r\n      throw new FS.ErrnoError(9);\r\n    }\r\n    if (stream.getdents) stream.getdents = null; // free readdir state\r\n    try {\r\n      if (stream.stream_ops.close) {\r\n        stream.stream_ops.close(stream);\r\n      }\r\n    } catch (e) {\r\n      throw e;\r\n    } finally {\r\n      FS.closeStream(stream.fd);\r\n    }\r\n    stream.fd = null;\r\n  },\r\n  isClosed: function (stream) {\r\n    return stream.fd === null;\r\n  },\r\n  llseek: function (stream, offset, whence) {\r\n    if (FS.isClosed(stream)) {\r\n      throw new FS.ErrnoError(9);\r\n    }\r\n    if (!stream.seekable || !stream.stream_ops.llseek) {\r\n      throw new FS.ErrnoError(29);\r\n    }\r\n    if (\r\n      whence != 0 /* SEEK_SET */ &&\r\n      whence != 1 /* SEEK_CUR */ &&\r\n      whence != 2 /* SEEK_END */\r\n    ) {\r\n      throw new FS.ErrnoError(22);\r\n    }\r\n    stream.position = stream.stream_ops.llseek(stream, offset, whence);\r\n    stream.ungotten = [];\r\n    return stream.position;\r\n  },\r\n  read: function (stream, buffer, offset, length, position) {\r\n    if (length < 0 || position < 0) {\r\n      throw new FS.ErrnoError(22);\r\n    }\r\n    if (FS.isClosed(stream)) {\r\n      throw new FS.ErrnoError(9);\r\n    }\r\n    if ((stream.flags & 2097155) === 1) {\r\n      throw new FS.ErrnoError(9);\r\n    }\r\n    if (FS.isDir(stream.node.mode)) {\r\n      throw new FS.ErrnoError(21);\r\n    }\r\n    if (!stream.stream_ops.read) {\r\n      throw new FS.ErrnoError(22);\r\n    }\r\n    var seeking = typeof position !== \"undefined\";\r\n    if (!seeking) {\r\n      position = stream.position;\r\n    } else if (!stream.seekable) {\r\n      throw new FS.ErrnoError(29);\r\n    }\r\n    var bytesRead = stream.stream_ops.read(\r\n      stream,\r\n      buffer,\r\n      offset,\r\n      length,\r\n      position,\r\n    );\r\n    if (!seeking) stream.position += bytesRead;\r\n    return bytesRead;\r\n  },\r\n  write: function (stream, buffer, offset, length, position, canOwn) {\r\n    if (length < 0 || position < 0) {\r\n      throw new FS.ErrnoError(22);\r\n    }\r\n    if (FS.isClosed(stream)) {\r\n      throw new FS.ErrnoError(9);\r\n    }\r\n    if ((stream.flags & 2097155) === 0) {\r\n      throw new FS.ErrnoError(9);\r\n    }\r\n    if (FS.isDir(stream.node.mode)) {\r\n      throw new FS.ErrnoError(21);\r\n    }\r\n    if (!stream.stream_ops.write) {\r\n      throw new FS.ErrnoError(22);\r\n    }\r\n    if (stream.flags & 1024) {\r\n      // seek to the end before writing in append mode\r\n      FS.llseek(stream, 0, 2);\r\n    }\r\n    var seeking = typeof position !== \"undefined\";\r\n    if (!seeking) {\r\n      position = stream.position;\r\n    } else if (!stream.seekable) {\r\n      throw new FS.ErrnoError(29);\r\n    }\r\n    var bytesWritten = stream.stream_ops.write(\r\n      stream,\r\n      buffer,\r\n      offset,\r\n      length,\r\n      position,\r\n      canOwn,\r\n    );\r\n    if (!seeking) stream.position += bytesWritten;\r\n    try {\r\n      if (stream.path && FS.trackingDelegate[\"onWriteToFile\"])\r\n        FS.trackingDelegate[\"onWriteToFile\"](stream.path);\r\n    } catch (e) {\r\n      console.log(\r\n        \"FS.trackingDelegate['onWriteToFile']('\" +\r\n          stream.path +\r\n          \"') threw an exception: \" +\r\n          e.message,\r\n      );\r\n    }\r\n    return bytesWritten;\r\n  },\r\n  allocate: function (stream, offset, length) {\r\n    if (FS.isClosed(stream)) {\r\n      throw new FS.ErrnoError(9);\r\n    }\r\n    if (offset < 0 || length <= 0) {\r\n      throw new FS.ErrnoError(22);\r\n    }\r\n    if ((stream.flags & 2097155) === 0) {\r\n      throw new FS.ErrnoError(9);\r\n    }\r\n    if (!FS.isFile(stream.node.mode) && !FS.isDir(stream.node.mode)) {\r\n      throw new FS.ErrnoError(19);\r\n    }\r\n    if (!stream.stream_ops.allocate) {\r\n      throw new FS.ErrnoError(95);\r\n    }\r\n    stream.stream_ops.allocate(stream, offset, length);\r\n  },\r\n  mmap: function (stream, buffer, offset, length, position, prot, flags) {\r\n    // TODO if PROT is PROT_WRITE, make sure we have write access\r\n    if ((stream.flags & 2097155) === 1) {\r\n      throw new FS.ErrnoError(13);\r\n    }\r\n    if (!stream.stream_ops.mmap) {\r\n      throw new FS.ErrnoError(19);\r\n    }\r\n    return stream.stream_ops.mmap(\r\n      stream,\r\n      buffer,\r\n      offset,\r\n      length,\r\n      position,\r\n      prot,\r\n      flags,\r\n    );\r\n  },\r\n  msync: function (stream, buffer, offset, length, mmapFlags) {\r\n    if (!stream || !stream.stream_ops.msync) {\r\n      return 0;\r\n    }\r\n    return stream.stream_ops.msync(stream, buffer, offset, length, mmapFlags);\r\n  },\r\n  munmap: function (stream) {\r\n    return 0;\r\n  },\r\n  ioctl: function (stream, cmd, arg) {\r\n    if (!stream.stream_ops.ioctl) {\r\n      throw new FS.ErrnoError(25);\r\n    }\r\n    return stream.stream_ops.ioctl(stream, cmd, arg);\r\n  },\r\n  readFile: function (path, opts) {\r\n    opts = opts || {};\r\n    opts.flags = opts.flags || \"r\";\r\n    opts.encoding = opts.encoding || \"binary\";\r\n    if (opts.encoding !== \"utf8\" && opts.encoding !== \"binary\") {\r\n      throw new Error('Invalid encoding type \"' + opts.encoding + '\"');\r\n    }\r\n    var ret;\r\n    var stream = FS.open(path, opts.flags);\r\n    var stat = FS.stat(path);\r\n    var length = stat.size;\r\n    var buf = new Uint8Array(length);\r\n    FS.read(stream, buf, 0, length, 0);\r\n    if (opts.encoding === \"utf8\") {\r\n      ret = UTF8ArrayToString(buf, 0);\r\n    } else if (opts.encoding === \"binary\") {\r\n      ret = buf;\r\n    }\r\n    FS.close(stream);\r\n    return ret;\r\n  },\r\n  writeFile: function (path, data, opts) {\r\n    opts = opts || {};\r\n    opts.flags = opts.flags || \"w\";\r\n    var stream = FS.open(path, opts.flags, opts.mode);\r\n    if (typeof data === \"string\") {\r\n      var buf = new Uint8Array(lengthBytesUTF8(data) + 1);\r\n      var actualNumBytes = stringToUTF8Array(data, buf, 0, buf.length);\r\n      FS.write(stream, buf, 0, actualNumBytes, undefined, opts.canOwn);\r\n    } else if (ArrayBuffer.isView(data)) {\r\n      FS.write(stream, data, 0, data.byteLength, undefined, opts.canOwn);\r\n    } else {\r\n      throw new Error(\"Unsupported data type\");\r\n    }\r\n    FS.close(stream);\r\n  },\r\n  cwd: function () {\r\n    return FS.currentPath;\r\n  },\r\n  chdir: function (path) {\r\n    var lookup = FS.lookupPath(path, { follow: true });\r\n    if (lookup.node === null) {\r\n      throw new FS.ErrnoError(2);\r\n    }\r\n    if (!FS.isDir(lookup.node.mode)) {\r\n      throw new FS.ErrnoError(20);\r\n    }\r\n    var err = FS.nodePermissions(lookup.node, \"x\");\r\n    if (err) {\r\n      throw new FS.ErrnoError(err);\r\n    }\r\n    FS.currentPath = lookup.path;\r\n  },\r\n  createDefaultDirectories: function () {\r\n    FS.mkdir(\"/tmp\");\r\n    FS.mkdir(\"/home\");\r\n    FS.mkdir(\"/home/web_user\");\r\n  },\r\n  createDefaultDevices: function () {\r\n    // create /dev\r\n    FS.mkdir(\"/dev\");\r\n    // setup /dev/null\r\n    FS.registerDevice(FS.makedev(1, 3), {\r\n      read: function () {\r\n        return 0;\r\n      },\r\n      write: function (stream, buffer, offset, length, pos) {\r\n        return length;\r\n      },\r\n    });\r\n    FS.mkdev(\"/dev/null\", FS.makedev(1, 3));\r\n    // setup /dev/tty and /dev/tty1\r\n    // stderr needs to print output using Module['printErr']\r\n    // so we register a second tty just for it.\r\n    TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);\r\n    TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);\r\n    FS.mkdev(\"/dev/tty\", FS.makedev(5, 0));\r\n    FS.mkdev(\"/dev/tty1\", FS.makedev(6, 0));\r\n    // setup /dev/[u]random\r\n    var random_device;\r\n    if (\r\n      typeof crypto === \"object\" &&\r\n      typeof crypto[\"getRandomValues\"] === \"function\"\r\n    ) {\r\n      // for modern web browsers\r\n      var randomBuffer = new Uint8Array(1);\r\n      random_device = function () {\r\n        crypto.getRandomValues(randomBuffer);\r\n        return randomBuffer[0];\r\n      };\r\n    } else if (ENVIRONMENT_IS_NODE) {\r\n      // for nodejs with or without crypto support included\r\n      try {\r\n        var crypto_module = require(\"crypto\");\r\n        // nodejs has crypto support\r\n        random_device = function () {\r\n          return crypto_module[\"randomBytes\"](1)[0];\r\n        };\r\n      } catch (e) {\r\n        // nodejs doesn't have crypto support so fallback to Math.random\r\n        random_device = function () {\r\n          return (Math.random() * 256) | 0;\r\n        };\r\n      }\r\n    } else {\r\n      // default for ES5 platforms\r\n      random_device = function () {\r\n        abort(\r\n          \"random_device\",\r\n        ); /*Math.random() is not safe for random number generation, so this fallback random_device implementation aborts... see emscripten-core/emscripten/pull/7096 */\r\n      };\r\n    }\r\n    FS.createDevice(\"/dev\", \"random\", random_device);\r\n    FS.createDevice(\"/dev\", \"urandom\", random_device);\r\n    // we're not going to emulate the actual shm device,\r\n    // just create the tmp dirs that reside in it commonly\r\n    FS.mkdir(\"/dev/shm\");\r\n    FS.mkdir(\"/dev/shm/tmp\");\r\n  },\r\n  createSpecialDirectories: function () {\r\n    // create /proc/self/fd which allows /proc/self/fd/6 => readlink gives the name of the stream for fd 6 (see test_unistd_ttyname)\r\n    FS.mkdir(\"/proc\");\r\n    FS.mkdir(\"/proc/self\");\r\n    FS.mkdir(\"/proc/self/fd\");\r\n    FS.mount(\r\n      {\r\n        mount: function () {\r\n          var node = FS.createNode(\r\n            \"/proc/self\",\r\n            \"fd\",\r\n            16384 | 511 /* 0777 */,\r\n            73,\r\n          );\r\n          node.node_ops = {\r\n            lookup: function (parent, name) {\r\n              var fd = +name;\r\n              var stream = FS.getStream(fd);\r\n              if (!stream) throw new FS.ErrnoError(9);\r\n              var ret = {\r\n                parent: null,\r\n                mount: { mountpoint: \"fake\" },\r\n                node_ops: {\r\n                  readlink: function () {\r\n                    return stream.path;\r\n                  },\r\n                },\r\n              };\r\n              ret.parent = ret; // make it look like a simple root node\r\n              return ret;\r\n            },\r\n          };\r\n          return node;\r\n        },\r\n      },\r\n      {},\r\n      \"/proc/self/fd\",\r\n    );\r\n  },\r\n  createStandardStreams: function () {\r\n    // TODO deprecate the old functionality of a single\r\n    // input / output callback and that utilizes FS.createDevice\r\n    // and instead require a unique set of stream ops\r\n\r\n    // by default, we symlink the standard streams to the\r\n    // default tty devices. however, if the standard streams\r\n    // have been overwritten we create a unique device for\r\n    // them instead.\r\n    if (Module[\"stdin\"]) {\r\n      FS.createDevice(\"/dev\", \"stdin\", Module[\"stdin\"]);\r\n    } else {\r\n      FS.symlink(\"/dev/tty\", \"/dev/stdin\");\r\n    }\r\n    if (Module[\"stdout\"]) {\r\n      FS.createDevice(\"/dev\", \"stdout\", null, Module[\"stdout\"]);\r\n    } else {\r\n      FS.symlink(\"/dev/tty\", \"/dev/stdout\");\r\n    }\r\n    if (Module[\"stderr\"]) {\r\n      FS.createDevice(\"/dev\", \"stderr\", null, Module[\"stderr\"]);\r\n    } else {\r\n      FS.symlink(\"/dev/tty1\", \"/dev/stderr\");\r\n    }\r\n\r\n    // open default streams for the stdin, stdout and stderr devices\r\n    var stdin = FS.open(\"/dev/stdin\", \"r\");\r\n    assert(stdin.fd === 0, \"invalid handle for stdin (\" + stdin.fd + \")\");\r\n\r\n    var stdout = FS.open(\"/dev/stdout\", \"w\");\r\n    assert(stdout.fd === 1, \"invalid handle for stdout (\" + stdout.fd + \")\");\r\n\r\n    var stderr = FS.open(\"/dev/stderr\", \"w\");\r\n    assert(stderr.fd === 2, \"invalid handle for stderr (\" + stderr.fd + \")\");\r\n  },\r\n  ensureErrnoError: function () {\r\n    if (FS.ErrnoError) return;\r\n    FS.ErrnoError = function ErrnoError(errno, node) {\r\n      this.node = node;\r\n      this.setErrno = function (errno) {\r\n        this.errno = errno;\r\n        for (var key in ERRNO_CODES) {\r\n          if (ERRNO_CODES[key] === errno) {\r\n            this.code = key;\r\n            break;\r\n          }\r\n        }\r\n      };\r\n      this.setErrno(errno);\r\n      this.message = ERRNO_MESSAGES[errno];\r\n      // Node.js compatibility: assigning on this.stack fails on Node 4 (but fixed on Node 8)\r\n      if (this.stack)\r\n        Object.defineProperty(this, \"stack\", {\r\n          value: new Error().stack,\r\n          writable: true,\r\n        });\r\n      if (this.stack) this.stack = demangleAll(this.stack);\r\n    };\r\n    FS.ErrnoError.prototype = new Error();\r\n    FS.ErrnoError.prototype.constructor = FS.ErrnoError;\r\n    // Some errors may happen quite a bit, to avoid overhead we reuse them (and suffer a lack of stack info)\r\n    [2].forEach(function (code) {\r\n      FS.genericErrors[code] = new FS.ErrnoError(code);\r\n      FS.genericErrors[code].stack = \"<generic error, no stack>\";\r\n    });\r\n  },\r\n  staticInit: function () {\r\n    FS.ensureErrnoError();\r\n\r\n    FS.nameTable = new Array(4096);\r\n\r\n    FS.mount(MEMFS, {}, \"/\");\r\n\r\n    FS.createDefaultDirectories();\r\n    FS.createDefaultDevices();\r\n    FS.createSpecialDirectories();\r\n\r\n    FS.filesystems = {\r\n      MEMFS: MEMFS,\r\n      IDBFS: IDBFS,\r\n      NODEFS: NODEFS,\r\n      WORKERFS: WORKERFS,\r\n    };\r\n  },\r\n  init: function (input, output, error) {\r\n    assert(\r\n      !FS.init.initialized,\r\n      \"FS.init was previously called. If you want to initialize later with custom parameters, remove any earlier calls (note that one is automatically added to the generated code)\",\r\n    );\r\n    FS.init.initialized = true;\r\n\r\n    FS.ensureErrnoError();\r\n\r\n    // Allow Module.stdin etc. to provide defaults, if none explicitly passed to us here\r\n    Module[\"stdin\"] = input || Module[\"stdin\"];\r\n    Module[\"stdout\"] = output || Module[\"stdout\"];\r\n    Module[\"stderr\"] = error || Module[\"stderr\"];\r\n\r\n    FS.createStandardStreams();\r\n  },\r\n  quit: function () {\r\n    FS.init.initialized = false;\r\n    // force-flush all streams, so we get musl std streams printed out\r\n    var fflush = Module[\"_fflush\"];\r\n    if (fflush) fflush(0);\r\n    // close all of our streams\r\n    for (var i = 0; i < FS.streams.length; i++) {\r\n      var stream = FS.streams[i];\r\n      if (!stream) {\r\n        continue;\r\n      }\r\n      FS.close(stream);\r\n    }\r\n  },\r\n  getMode: function (canRead, canWrite) {\r\n    var mode = 0;\r\n    if (canRead) mode |= 292 | 73;\r\n    if (canWrite) mode |= 146;\r\n    return mode;\r\n  },\r\n  joinPath: function (parts, forceRelative) {\r\n    var path = PATH.join.apply(null, parts);\r\n    if (forceRelative && path[0] == \"/\") path = path.substr(1);\r\n    return path;\r\n  },\r\n  absolutePath: function (relative, base) {\r\n    return PATH.resolve(base, relative);\r\n  },\r\n  standardizePath: function (path) {\r\n    return PATH.normalize(path);\r\n  },\r\n  findObject: function (path, dontResolveLastLink) {\r\n    var ret = FS.analyzePath(path, dontResolveLastLink);\r\n    if (ret.exists) {\r\n      return ret.object;\r\n    } else {\r\n      ___setErrNo(ret.error);\r\n      return null;\r\n    }\r\n  },\r\n  analyzePath: function (path, dontResolveLastLink) {\r\n    // operate from within the context of the symlink's target\r\n    try {\r\n      var lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });\r\n      path = lookup.path;\r\n    } catch (e) {}\r\n    var ret = {\r\n      isRoot: false,\r\n      exists: false,\r\n      error: 0,\r\n      name: null,\r\n      path: null,\r\n      object: null,\r\n      parentExists: false,\r\n      parentPath: null,\r\n      parentObject: null,\r\n    };\r\n    try {\r\n      var lookup = FS.lookupPath(path, { parent: true });\r\n      ret.parentExists = true;\r\n      ret.parentPath = lookup.path;\r\n      ret.parentObject = lookup.node;\r\n      ret.name = PATH.basename(path);\r\n      lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });\r\n      ret.exists = true;\r\n      ret.path = lookup.path;\r\n      ret.object = lookup.node;\r\n      ret.name = lookup.node.name;\r\n      ret.isRoot = lookup.path === \"/\";\r\n    } catch (e) {\r\n      ret.error = e.errno;\r\n    }\r\n    return ret;\r\n  },\r\n  createFolder: function (parent, name, canRead, canWrite) {\r\n    var path = PATH.join2(\r\n      typeof parent === \"string\" ? parent : FS.getPath(parent),\r\n      name,\r\n    );\r\n    var mode = FS.getMode(canRead, canWrite);\r\n    return FS.mkdir(path, mode);\r\n  },\r\n  createPath: function (parent, path, canRead, canWrite) {\r\n    parent = typeof parent === \"string\" ? parent : FS.getPath(parent);\r\n    var parts = path.split(\"/\").reverse();\r\n    while (parts.length) {\r\n      var part = parts.pop();\r\n      if (!part) continue;\r\n      var current = PATH.join2(parent, part);\r\n      try {\r\n        FS.mkdir(current);\r\n      } catch (e) {\r\n        // ignore EEXIST\r\n      }\r\n      parent = current;\r\n    }\r\n    return current;\r\n  },\r\n  createFile: function (parent, name, properties, canRead, canWrite) {\r\n    var path = PATH.join2(\r\n      typeof parent === \"string\" ? parent : FS.getPath(parent),\r\n      name,\r\n    );\r\n    var mode = FS.getMode(canRead, canWrite);\r\n    return FS.create(path, mode);\r\n  },\r\n  createDataFile: function (parent, name, data, canRead, canWrite, canOwn) {\r\n    var path = name\r\n      ? PATH.join2(\r\n          typeof parent === \"string\" ? parent : FS.getPath(parent),\r\n          name,\r\n        )\r\n      : parent;\r\n    var mode = FS.getMode(canRead, canWrite);\r\n    var node = FS.create(path, mode);\r\n    if (data) {\r\n      if (typeof data === \"string\") {\r\n        var arr = new Array(data.length);\r\n        for (var i = 0, len = data.length; i < len; ++i)\r\n          arr[i] = data.charCodeAt(i);\r\n        data = arr;\r\n      }\r\n      // make sure we can write to the file\r\n      FS.chmod(node, mode | 146);\r\n      var stream = FS.open(node, \"w\");\r\n      FS.write(stream, data, 0, data.length, 0, canOwn);\r\n      FS.close(stream);\r\n      FS.chmod(node, mode);\r\n    }\r\n    return node;\r\n  },\r\n  createDevice: function (parent, name, input, output) {\r\n    var path = PATH.join2(\r\n      typeof parent === \"string\" ? parent : FS.getPath(parent),\r\n      name,\r\n    );\r\n    var mode = FS.getMode(!!input, !!output);\r\n    if (!FS.createDevice.major) FS.createDevice.major = 64;\r\n    var dev = FS.makedev(FS.createDevice.major++, 0);\r\n    // Create a fake device that a set of stream ops to emulate\r\n    // the old behavior.\r\n    FS.registerDevice(dev, {\r\n      open: function (stream) {\r\n        stream.seekable = false;\r\n      },\r\n      close: function (stream) {\r\n        // flush any pending line data\r\n        if (output && output.buffer && output.buffer.length) {\r\n          output(10);\r\n        }\r\n      },\r\n      read: function (stream, buffer, offset, length, pos /* ignored */) {\r\n        var bytesRead = 0;\r\n        for (var i = 0; i < length; i++) {\r\n          var result;\r\n          try {\r\n            result = input();\r\n          } catch (e) {\r\n            throw new FS.ErrnoError(5);\r\n          }\r\n          if (result === undefined && bytesRead === 0) {\r\n            throw new FS.ErrnoError(11);\r\n          }\r\n          if (result === null || result === undefined) break;\r\n          bytesRead++;\r\n          buffer[offset + i] = result;\r\n        }\r\n        if (bytesRead) {\r\n          stream.node.timestamp = Date.now();\r\n        }\r\n        return bytesRead;\r\n      },\r\n      write: function (stream, buffer, offset, length, pos) {\r\n        for (var i = 0; i < length; i++) {\r\n          try {\r\n            output(buffer[offset + i]);\r\n          } catch (e) {\r\n            throw new FS.ErrnoError(5);\r\n          }\r\n        }\r\n        if (length) {\r\n          stream.node.timestamp = Date.now();\r\n        }\r\n        return i;\r\n      },\r\n    });\r\n    return FS.mkdev(path, mode, dev);\r\n  },\r\n  createLink: function (parent, name, target, canRead, canWrite) {\r\n    var path = PATH.join2(\r\n      typeof parent === \"string\" ? parent : FS.getPath(parent),\r\n      name,\r\n    );\r\n    return FS.symlink(target, path);\r\n  },\r\n  forceLoadFile: function (obj) {\r\n    if (obj.isDevice || obj.isFolder || obj.link || obj.contents) return true;\r\n    var success = true;\r\n    if (typeof XMLHttpRequest !== \"undefined\") {\r\n      throw new Error(\r\n        \"Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.\",\r\n      );\r\n    } else if (Module[\"read\"]) {\r\n      // Command-line.\r\n      try {\r\n        // WARNING: Can't read binary files in V8's d8 or tracemonkey's js, as\r\n        //          read() will try to parse UTF8.\r\n        obj.contents = intArrayFromString(Module[\"read\"](obj.url), true);\r\n        obj.usedBytes = obj.contents.length;\r\n      } catch (e) {\r\n        success = false;\r\n      }\r\n    } else {\r\n      throw new Error(\"Cannot load without read() or XMLHttpRequest.\");\r\n    }\r\n    if (!success) ___setErrNo(5);\r\n    return success;\r\n  },\r\n  createLazyFile: function (parent, name, url, canRead, canWrite) {\r\n    // Lazy chunked Uint8Array (implements get and length from Uint8Array). Actual getting is abstracted away for eventual reuse.\r\n    function LazyUint8Array() {\r\n      this.lengthKnown = false;\r\n      this.chunks = []; // Loaded chunks. Index is the chunk number\r\n    }\r\n\r\n    LazyUint8Array.prototype.get = function LazyUint8Array_get(idx) {\r\n      if (idx > this.length - 1 || idx < 0) {\r\n        return undefined;\r\n      }\r\n      var chunkOffset = idx % this.chunkSize;\r\n      var chunkNum = (idx / this.chunkSize) | 0;\r\n      return this.getter(chunkNum)[chunkOffset];\r\n    };\r\n    LazyUint8Array.prototype.setDataGetter =\r\n      function LazyUint8Array_setDataGetter(getter) {\r\n        this.getter = getter;\r\n      };\r\n    LazyUint8Array.prototype.cacheLength =\r\n      function LazyUint8Array_cacheLength() {\r\n        // Find length\r\n        var xhr = new XMLHttpRequest();\r\n        xhr.open(\"HEAD\", url, false);\r\n        xhr.send(null);\r\n        if (!((xhr.status >= 200 && xhr.status < 300) || xhr.status === 304))\r\n          throw new Error(\"Couldn't load \" + url + \". Status: \" + xhr.status);\r\n        var datalength = Number(xhr.getResponseHeader(\"Content-length\"));\r\n        var header;\r\n        var hasByteServing =\r\n          (header = xhr.getResponseHeader(\"Accept-Ranges\")) &&\r\n          header === \"bytes\";\r\n        var usesGzip =\r\n          (header = xhr.getResponseHeader(\"Content-Encoding\")) &&\r\n          header === \"gzip\";\r\n\r\n        var chunkSize = 1024 * 1024; // Chunk size in bytes\r\n\r\n        if (!hasByteServing) chunkSize = datalength;\r\n\r\n        // Function to get a range from the remote URL.\r\n        var doXHR = function (from, to) {\r\n          if (from > to)\r\n            throw new Error(\r\n              \"invalid range (\" + from + \", \" + to + \") or no bytes requested!\",\r\n            );\r\n          if (to > datalength - 1)\r\n            throw new Error(\r\n              \"only \" + datalength + \" bytes available! programmer error!\",\r\n            );\r\n\r\n          // TODO: Use mozResponseArrayBuffer, responseStream, etc. if available.\r\n          var xhr = new XMLHttpRequest();\r\n          xhr.open(\"GET\", url, false);\r\n          if (datalength !== chunkSize)\r\n            xhr.setRequestHeader(\"Range\", \"bytes=\" + from + \"-\" + to);\r\n\r\n          // Some hints to the browser that we want binary data.\r\n          if (typeof Uint8Array != \"undefined\")\r\n            xhr.responseType = \"arraybuffer\";\r\n          if (xhr.overrideMimeType) {\r\n            xhr.overrideMimeType(\"text/plain; charset=x-user-defined\");\r\n          }\r\n\r\n          xhr.send(null);\r\n          if (!((xhr.status >= 200 && xhr.status < 300) || xhr.status === 304))\r\n            throw new Error(\"Couldn't load \" + url + \". Status: \" + xhr.status);\r\n          if (xhr.response !== undefined) {\r\n            return new Uint8Array(xhr.response || []);\r\n          } else {\r\n            return intArrayFromString(xhr.responseText || \"\", true);\r\n          }\r\n        };\r\n        var lazyArray = this;\r\n        lazyArray.setDataGetter(function (chunkNum) {\r\n          var start = chunkNum * chunkSize;\r\n          var end = (chunkNum + 1) * chunkSize - 1; // including this byte\r\n          end = Math.min(end, datalength - 1); // if datalength-1 is selected, this is the last block\r\n          if (typeof lazyArray.chunks[chunkNum] === \"undefined\") {\r\n            lazyArray.chunks[chunkNum] = doXHR(start, end);\r\n          }\r\n          if (typeof lazyArray.chunks[chunkNum] === \"undefined\")\r\n            throw new Error(\"doXHR failed!\");\r\n          return lazyArray.chunks[chunkNum];\r\n        });\r\n\r\n        if (usesGzip || !datalength) {\r\n          // if the server uses gzip or doesn't supply the length, we have to download the whole file to get the (uncompressed) length\r\n          chunkSize = datalength = 1; // this will force getter(0)/doXHR do download the whole file\r\n          datalength = this.getter(0).length;\r\n          chunkSize = datalength;\r\n          console.log(\r\n            \"LazyFiles on gzip forces download of the whole file when length is accessed\",\r\n          );\r\n        }\r\n\r\n        this._length = datalength;\r\n        this._chunkSize = chunkSize;\r\n        this.lengthKnown = true;\r\n      };\r\n    if (typeof XMLHttpRequest !== \"undefined\") {\r\n      if (!ENVIRONMENT_IS_WORKER)\r\n        throw \"Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc\";\r\n      var lazyArray = new LazyUint8Array();\r\n      Object.defineProperties(lazyArray, {\r\n        length: {\r\n          get: function () {\r\n            if (!this.lengthKnown) {\r\n              this.cacheLength();\r\n            }\r\n            return this._length;\r\n          },\r\n        },\r\n        chunkSize: {\r\n          get: function () {\r\n            if (!this.lengthKnown) {\r\n              this.cacheLength();\r\n            }\r\n            return this._chunkSize;\r\n          },\r\n        },\r\n      });\r\n\r\n      var properties = { isDevice: false, contents: lazyArray };\r\n    } else {\r\n      var properties = { isDevice: false, url: url };\r\n    }\r\n\r\n    var node = FS.createFile(parent, name, properties, canRead, canWrite);\r\n    // This is a total hack, but I want to get this lazy file code out of the\r\n    // core of MEMFS. If we want to keep this lazy file concept I feel it should\r\n    // be its own thin LAZYFS proxying calls to MEMFS.\r\n    if (properties.contents) {\r\n      node.contents = properties.contents;\r\n    } else if (properties.url) {\r\n      node.contents = null;\r\n      node.url = properties.url;\r\n    }\r\n    // Add a function that defers querying the file size until it is asked the first time.\r\n    Object.defineProperties(node, {\r\n      usedBytes: {\r\n        get: function () {\r\n          return this.contents.length;\r\n        },\r\n      },\r\n    });\r\n    // override each stream op with one that tries to force load the lazy file first\r\n    var stream_ops = {};\r\n    var keys = Object.keys(node.stream_ops);\r\n    keys.forEach(function (key) {\r\n      var fn = node.stream_ops[key];\r\n      stream_ops[key] = function forceLoadLazyFile() {\r\n        if (!FS.forceLoadFile(node)) {\r\n          throw new FS.ErrnoError(5);\r\n        }\r\n        return fn.apply(null, arguments);\r\n      };\r\n    });\r\n    // use a custom read function\r\n    stream_ops.read = function stream_ops_read(\r\n      stream,\r\n      buffer,\r\n      offset,\r\n      length,\r\n      position,\r\n    ) {\r\n      if (!FS.forceLoadFile(node)) {\r\n        throw new FS.ErrnoError(5);\r\n      }\r\n      var contents = stream.node.contents;\r\n      if (position >= contents.length) return 0;\r\n      var size = Math.min(contents.length - position, length);\r\n      assert(size >= 0);\r\n      if (contents.slice) {\r\n        // normal array\r\n        for (var i = 0; i < size; i++) {\r\n          buffer[offset + i] = contents[position + i];\r\n        }\r\n      } else {\r\n        for (var i = 0; i < size; i++) {\r\n          // LazyUint8Array from sync binary XHR\r\n          buffer[offset + i] = contents.get(position + i);\r\n        }\r\n      }\r\n      return size;\r\n    };\r\n    node.stream_ops = stream_ops;\r\n    return node;\r\n  },\r\n  createPreloadedFile: function (\r\n    parent,\r\n    name,\r\n    url,\r\n    canRead,\r\n    canWrite,\r\n    onload,\r\n    onerror,\r\n    dontCreateFile,\r\n    canOwn,\r\n    preFinish,\r\n  ) {\r\n    Browser.init(); // XXX perhaps this method should move onto Browser?\r\n    // TODO we should allow people to just pass in a complete filename instead\r\n    // of parent and name being that we just join them anyways\r\n    var fullname = name ? PATH.resolve(PATH.join2(parent, name)) : parent;\r\n    var dep = getUniqueRunDependency(\"cp \" + fullname); // might have several active requests for the same fullname\r\n    function processData(byteArray) {\r\n      function finish(byteArray) {\r\n        if (preFinish) preFinish();\r\n        if (!dontCreateFile) {\r\n          FS.createDataFile(parent, name, byteArray, canRead, canWrite, canOwn);\r\n        }\r\n        if (onload) onload();\r\n        removeRunDependency(dep);\r\n      }\r\n\r\n      var handled = false;\r\n      Module[\"preloadPlugins\"].forEach(function (plugin) {\r\n        if (handled) return;\r\n        if (plugin[\"canHandle\"](fullname)) {\r\n          plugin[\"handle\"](byteArray, fullname, finish, function () {\r\n            if (onerror) onerror();\r\n            removeRunDependency(dep);\r\n          });\r\n          handled = true;\r\n        }\r\n      });\r\n      if (!handled) finish(byteArray);\r\n    }\r\n\r\n    addRunDependency(dep);\r\n    if (typeof url == \"string\") {\r\n      Browser.asyncLoad(\r\n        url,\r\n        function (byteArray) {\r\n          processData(byteArray);\r\n        },\r\n        onerror,\r\n      );\r\n    } else {\r\n      processData(url);\r\n    }\r\n  },\r\n  indexedDB: function () {\r\n    return (\r\n      window.indexedDB ||\r\n      window.mozIndexedDB ||\r\n      window.webkitIndexedDB ||\r\n      window.msIndexedDB\r\n    );\r\n  },\r\n  DB_NAME: function () {\r\n    return \"EM_FS_\" + window.location.pathname;\r\n  },\r\n  DB_VERSION: 20,\r\n  DB_STORE_NAME: \"FILE_DATA\",\r\n  saveFilesToDB: function (paths, onload, onerror) {\r\n    onload = onload || function () {};\r\n    onerror = onerror || function () {};\r\n    var indexedDB = FS.indexedDB();\r\n    try {\r\n      var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);\r\n    } catch (e) {\r\n      return onerror(e);\r\n    }\r\n    openRequest.onupgradeneeded = function openRequest_onupgradeneeded() {\r\n      console.log(\"creating db\");\r\n      var db = openRequest.result;\r\n      db.createObjectStore(FS.DB_STORE_NAME);\r\n    };\r\n    openRequest.onsuccess = function openRequest_onsuccess() {\r\n      var db = openRequest.result;\r\n      var transaction = db.transaction([FS.DB_STORE_NAME], \"readwrite\");\r\n      var files = transaction.objectStore(FS.DB_STORE_NAME);\r\n      var ok = 0,\r\n        fail = 0,\r\n        total = paths.length;\r\n\r\n      function finish() {\r\n        if (fail == 0) onload();\r\n        else onerror();\r\n      }\r\n\r\n      paths.forEach(function (path) {\r\n        var putRequest = files.put(FS.analyzePath(path).object.contents, path);\r\n        putRequest.onsuccess = function putRequest_onsuccess() {\r\n          ok++;\r\n          if (ok + fail == total) finish();\r\n        };\r\n        putRequest.onerror = function putRequest_onerror() {\r\n          fail++;\r\n          if (ok + fail == total) finish();\r\n        };\r\n      });\r\n      transaction.onerror = onerror;\r\n    };\r\n    openRequest.onerror = onerror;\r\n  },\r\n  loadFilesFromDB: function (paths, onload, onerror) {\r\n    onload = onload || function () {};\r\n    onerror = onerror || function () {};\r\n    var indexedDB = FS.indexedDB();\r\n    try {\r\n      var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);\r\n    } catch (e) {\r\n      return onerror(e);\r\n    }\r\n    openRequest.onupgradeneeded = onerror; // no database to load from\r\n    openRequest.onsuccess = function openRequest_onsuccess() {\r\n      var db = openRequest.result;\r\n      try {\r\n        var transaction = db.transaction([FS.DB_STORE_NAME], \"readonly\");\r\n      } catch (e) {\r\n        onerror(e);\r\n        return;\r\n      }\r\n      var files = transaction.objectStore(FS.DB_STORE_NAME);\r\n      var ok = 0,\r\n        fail = 0,\r\n        total = paths.length;\r\n\r\n      function finish() {\r\n        if (fail == 0) onload();\r\n        else onerror();\r\n      }\r\n\r\n      paths.forEach(function (path) {\r\n        var getRequest = files.get(path);\r\n        getRequest.onsuccess = function getRequest_onsuccess() {\r\n          if (FS.analyzePath(path).exists) {\r\n            FS.unlink(path);\r\n          }\r\n          FS.createDataFile(\r\n            PATH.dirname(path),\r\n            PATH.basename(path),\r\n            getRequest.result,\r\n            true,\r\n            true,\r\n            true,\r\n          );\r\n          ok++;\r\n          if (ok + fail == total) finish();\r\n        };\r\n        getRequest.onerror = function getRequest_onerror() {\r\n          fail++;\r\n          if (ok + fail == total) finish();\r\n        };\r\n      });\r\n      transaction.onerror = onerror;\r\n    };\r\n    openRequest.onerror = onerror;\r\n  },\r\n};\r\nwindow.FS = FS;\r\nvar SYSCALLS = {\r\n  DEFAULT_POLLMASK: 5,\r\n  mappings: {},\r\n  umask: 511,\r\n  calculateAt: function (dirfd, path) {\r\n    if (path[0] !== \"/\") {\r\n      // relative path\r\n      var dir;\r\n      if (dirfd === -100) {\r\n        dir = FS.cwd();\r\n      } else {\r\n        var dirstream = FS.getStream(dirfd);\r\n        if (!dirstream) throw new FS.ErrnoError(ERRNO_CODES.EBADF);\r\n        dir = dirstream.path;\r\n      }\r\n      path = PATH.join2(dir, path);\r\n    }\r\n    return path;\r\n  },\r\n  doStat: function (func, path, buf) {\r\n    try {\r\n      var stat = func(path);\r\n    } catch (e) {\r\n      if (\r\n        e &&\r\n        e.node &&\r\n        PATH.normalize(path) !== PATH.normalize(FS.getPath(e.node))\r\n      ) {\r\n        // an error occurred while trying to look up the path; we should just report ENOTDIR\r\n        return -ERRNO_CODES.ENOTDIR;\r\n      }\r\n      throw e;\r\n    }\r\n    HEAP32[buf >> 2] = stat.dev;\r\n    HEAP32[(buf + 4) >> 2] = 0;\r\n    HEAP32[(buf + 8) >> 2] = stat.ino;\r\n    HEAP32[(buf + 12) >> 2] = stat.mode;\r\n    HEAP32[(buf + 16) >> 2] = stat.nlink;\r\n    HEAP32[(buf + 20) >> 2] = stat.uid;\r\n    HEAP32[(buf + 24) >> 2] = stat.gid;\r\n    HEAP32[(buf + 28) >> 2] = stat.rdev;\r\n    HEAP32[(buf + 32) >> 2] = 0;\r\n    HEAP32[(buf + 36) >> 2] = stat.size;\r\n    HEAP32[(buf + 40) >> 2] = 4096;\r\n    HEAP32[(buf + 44) >> 2] = stat.blocks;\r\n    HEAP32[(buf + 48) >> 2] = (stat.atime.getTime() / 1000) | 0;\r\n    HEAP32[(buf + 52) >> 2] = 0;\r\n    HEAP32[(buf + 56) >> 2] = (stat.mtime.getTime() / 1000) | 0;\r\n    HEAP32[(buf + 60) >> 2] = 0;\r\n    HEAP32[(buf + 64) >> 2] = (stat.ctime.getTime() / 1000) | 0;\r\n    HEAP32[(buf + 68) >> 2] = 0;\r\n    HEAP32[(buf + 72) >> 2] = stat.ino;\r\n    return 0;\r\n  },\r\n  doMsync: function (addr, stream, len, flags) {\r\n    var buffer = new Uint8Array(HEAPU8.subarray(addr, addr + len));\r\n    FS.msync(stream, buffer, 0, len, flags);\r\n  },\r\n  doMkdir: function (path, mode) {\r\n    // remove a trailing slash, if one - /a/b/ has basename of '', but\r\n    // we want to create b in the context of this function\r\n    path = PATH.normalize(path);\r\n    if (path[path.length - 1] === \"/\") path = path.substr(0, path.length - 1);\r\n    FS.mkdir(path, mode, 0);\r\n    return 0;\r\n  },\r\n  doMknod: function (path, mode, dev) {\r\n    // we don't want this in the JS API as it uses mknod to create all nodes.\r\n    switch (mode & 61440) {\r\n      case 32768:\r\n      case 8192:\r\n      case 24576:\r\n      case 4096:\r\n      case 49152:\r\n        break;\r\n      default:\r\n        return -ERRNO_CODES.EINVAL;\r\n    }\r\n    FS.mknod(path, mode, dev);\r\n    return 0;\r\n  },\r\n  doReadlink: function (path, buf, bufsize) {\r\n    if (bufsize <= 0) return -ERRNO_CODES.EINVAL;\r\n    var ret = FS.readlink(path);\r\n\r\n    var len = Math.min(bufsize, lengthBytesUTF8(ret));\r\n    var endChar = HEAP8[buf + len];\r\n    stringToUTF8(ret, buf, bufsize + 1);\r\n    // readlink is one of the rare functions that write out a C string, but does never append a null to the output buffer(!)\r\n    // stringToUTF8() always appends a null byte, so restore the character under the null byte after the write.\r\n    HEAP8[buf + len] = endChar;\r\n\r\n    return len;\r\n  },\r\n  doAccess: function (path, amode) {\r\n    if (amode & ~7) {\r\n      // need a valid mode\r\n      return -ERRNO_CODES.EINVAL;\r\n    }\r\n    var node;\r\n    var lookup = FS.lookupPath(path, { follow: true });\r\n    node = lookup.node;\r\n    var perms = \"\";\r\n    if (amode & 4) perms += \"r\";\r\n    if (amode & 2) perms += \"w\";\r\n    if (amode & 1) perms += \"x\";\r\n    if (\r\n      perms /* otherwise, they've just passed F_OK */ &&\r\n      FS.nodePermissions(node, perms)\r\n    ) {\r\n      return -ERRNO_CODES.EACCES;\r\n    }\r\n    return 0;\r\n  },\r\n  doDup: function (path, flags, suggestFD) {\r\n    var suggest = FS.getStream(suggestFD);\r\n    if (suggest) FS.close(suggest);\r\n    return FS.open(path, flags, 0, suggestFD, suggestFD).fd;\r\n  },\r\n  doReadv: function (stream, iov, iovcnt, offset) {\r\n    var ret = 0;\r\n    for (var i = 0; i < iovcnt; i++) {\r\n      var ptr = HEAP32[(iov + i * 8) >> 2];\r\n      var len = HEAP32[(iov + (i * 8 + 4)) >> 2];\r\n      var curr = FS.read(stream, HEAP8, ptr, len, offset);\r\n      if (curr < 0) return -1;\r\n      ret += curr;\r\n      if (curr < len) break; // nothing more to read\r\n    }\r\n    return ret;\r\n  },\r\n  doWritev: function (stream, iov, iovcnt, offset) {\r\n    var ret = 0;\r\n    for (var i = 0; i < iovcnt; i++) {\r\n      var ptr = HEAP32[(iov + i * 8) >> 2];\r\n      var len = HEAP32[(iov + (i * 8 + 4)) >> 2];\r\n      var curr = FS.write(stream, HEAP8, ptr, len, offset);\r\n      if (curr < 0) return -1;\r\n      ret += curr;\r\n    }\r\n    return ret;\r\n  },\r\n  varargs: 0,\r\n  get: function (varargs) {\r\n    SYSCALLS.varargs += 4;\r\n    var ret = HEAP32[(SYSCALLS.varargs - 4) >> 2];\r\n    return ret;\r\n  },\r\n  getStr: function () {\r\n    var ret = UTF8ToString(SYSCALLS.get());\r\n    return ret;\r\n  },\r\n  getStreamFromFD: function () {\r\n    var stream = FS.getStream(SYSCALLS.get());\r\n    if (!stream) throw new FS.ErrnoError(ERRNO_CODES.EBADF);\r\n    return stream;\r\n  },\r\n  getSocketFromFD: function () {\r\n    var socket = SOCKFS.getSocket(SYSCALLS.get());\r\n    if (!socket) throw new FS.ErrnoError(ERRNO_CODES.EBADF);\r\n    return socket;\r\n  },\r\n  getSocketAddress: function (allowNull) {\r\n    var addrp = SYSCALLS.get(),\r\n      addrlen = SYSCALLS.get();\r\n    if (allowNull && addrp === 0) return null;\r\n    var info = __read_sockaddr(addrp, addrlen);\r\n    if (info.errno) throw new FS.ErrnoError(info.errno);\r\n    info.addr = DNS.lookup_addr(info.addr) || info.addr;\r\n    return info;\r\n  },\r\n  get64: function () {\r\n    var low = SYSCALLS.get(),\r\n      high = SYSCALLS.get();\r\n    if (low >= 0) assert(high === 0);\r\n    else assert(high === -1);\r\n    return low;\r\n  },\r\n  getZero: function () {\r\n    assert(SYSCALLS.get() === 0);\r\n  },\r\n};\r\n\r\nfunction ___syscall10(which, varargs) {\r\n  SYSCALLS.varargs = varargs;\r\n  try {\r\n    // unlink\r\n    var path = SYSCALLS.getStr();\r\n    FS.unlink(path);\r\n    return 0;\r\n  } catch (e) {\r\n    if (typeof FS === \"undefined\" || !(e instanceof FS.ErrnoError)) abort(e);\r\n    return -e.errno;\r\n  }\r\n}\r\n\r\nfunction ___syscall114(which, varargs) {\r\n  SYSCALLS.varargs = varargs;\r\n  try {\r\n    // wait4\r\n    abort(\"cannot wait on child processes\");\r\n  } catch (e) {\r\n    if (typeof FS === \"undefined\" || !(e instanceof FS.ErrnoError)) abort(e);\r\n    return -e.errno;\r\n  }\r\n}\r\n\r\nfunction ___syscall140(which, varargs) {\r\n  SYSCALLS.varargs = varargs;\r\n  try {\r\n    // llseek\r\n    var stream = SYSCALLS.getStreamFromFD(),\r\n      offset_high = SYSCALLS.get(),\r\n      offset_low = SYSCALLS.get(),\r\n      result = SYSCALLS.get(),\r\n      whence = SYSCALLS.get();\r\n    // NOTE: offset_high is unused - Emscripten's off_t is 32-bit\r\n    var offset = offset_low;\r\n    FS.llseek(stream, offset, whence);\r\n    HEAP32[result >> 2] = stream.position;\r\n    if (stream.getdents && offset === 0 && whence === 0) stream.getdents = null; // reset readdir state\r\n    return 0;\r\n  } catch (e) {\r\n    if (typeof FS === \"undefined\" || !(e instanceof FS.ErrnoError)) abort(e);\r\n    return -e.errno;\r\n  }\r\n}\r\n\r\nfunction ___syscall145(which, varargs) {\r\n  SYSCALLS.varargs = varargs;\r\n  try {\r\n    // readv\r\n    var stream = SYSCALLS.getStreamFromFD(),\r\n      iov = SYSCALLS.get(),\r\n      iovcnt = SYSCALLS.get();\r\n    return SYSCALLS.doReadv(stream, iov, iovcnt);\r\n  } catch (e) {\r\n    if (typeof FS === \"undefined\" || !(e instanceof FS.ErrnoError)) abort(e);\r\n    return -e.errno;\r\n  }\r\n}\r\n\r\nfunction ___syscall146(which, varargs) {\r\n  SYSCALLS.varargs = varargs;\r\n  try {\r\n    // writev\r\n    var stream = SYSCALLS.getStreamFromFD(),\r\n      iov = SYSCALLS.get(),\r\n      iovcnt = SYSCALLS.get();\r\n    return SYSCALLS.doWritev(stream, iov, iovcnt);\r\n  } catch (e) {\r\n    if (typeof FS === \"undefined\" || !(e instanceof FS.ErrnoError)) abort(e);\r\n    return -e.errno;\r\n  }\r\n}\r\n\r\nfunction ___syscall180(which, varargs) {\r\n  SYSCALLS.varargs = varargs;\r\n  try {\r\n    // pread64\r\n    var stream = SYSCALLS.getStreamFromFD(),\r\n      buf = SYSCALLS.get(),\r\n      count = SYSCALLS.get(),\r\n      zero = SYSCALLS.getZero(),\r\n      offset = SYSCALLS.get64();\r\n    return FS.read(stream, HEAP8, buf, count, offset);\r\n  } catch (e) {\r\n    if (typeof FS === \"undefined\" || !(e instanceof FS.ErrnoError)) abort(e);\r\n    return -e.errno;\r\n  }\r\n}\r\n\r\nfunction ___syscall181(which, varargs) {\r\n  SYSCALLS.varargs = varargs;\r\n  try {\r\n    // pwrite64\r\n    var stream = SYSCALLS.getStreamFromFD(),\r\n      buf = SYSCALLS.get(),\r\n      count = SYSCALLS.get(),\r\n      zero = SYSCALLS.getZero(),\r\n      offset = SYSCALLS.get64();\r\n    return FS.write(stream, HEAP8, buf, count, offset);\r\n  } catch (e) {\r\n    if (typeof FS === \"undefined\" || !(e instanceof FS.ErrnoError)) abort(e);\r\n    return -e.errno;\r\n  }\r\n}\r\n\r\nfunction ___syscall195(which, varargs) {\r\n  SYSCALLS.varargs = varargs;\r\n  try {\r\n    // SYS_stat64\r\n    var path = SYSCALLS.getStr(),\r\n      buf = SYSCALLS.get();\r\n    return SYSCALLS.doStat(FS.stat, path, buf);\r\n  } catch (e) {\r\n    if (typeof FS === \"undefined\" || !(e instanceof FS.ErrnoError)) abort(e);\r\n    return -e.errno;\r\n  }\r\n}\r\n\r\nfunction ___syscall197(which, varargs) {\r\n  SYSCALLS.varargs = varargs;\r\n  try {\r\n    // SYS_fstat64\r\n    var stream = SYSCALLS.getStreamFromFD(),\r\n      buf = SYSCALLS.get();\r\n    return SYSCALLS.doStat(FS.stat, stream.path, buf);\r\n  } catch (e) {\r\n    if (typeof FS === \"undefined\" || !(e instanceof FS.ErrnoError)) abort(e);\r\n    return -e.errno;\r\n  }\r\n}\r\n\r\nfunction ___syscall220(which, varargs) {\r\n  SYSCALLS.varargs = varargs;\r\n  try {\r\n    // SYS_getdents64\r\n    var stream = SYSCALLS.getStreamFromFD(),\r\n      dirp = SYSCALLS.get(),\r\n      count = SYSCALLS.get();\r\n    if (!stream.getdents) {\r\n      stream.getdents = FS.readdir(stream.path);\r\n    }\r\n    var pos = 0;\r\n    while (stream.getdents.length > 0 && pos + 268 <= count) {\r\n      var id;\r\n      var type;\r\n      var name = stream.getdents.pop();\r\n      if (name[0] === \".\") {\r\n        id = 1;\r\n        type = 4; // DT_DIR\r\n      } else {\r\n        var child = FS.lookupNode(stream.node, name);\r\n        id = child.id;\r\n        type = FS.isChrdev(child.mode)\r\n          ? 2 // DT_CHR, character device.\r\n          : FS.isDir(child.mode)\r\n            ? 4 // DT_DIR, directory.\r\n            : FS.isLink(child.mode)\r\n              ? 10 // DT_LNK, symbolic link.\r\n              : 8; // DT_REG, regular file.\r\n      }\r\n      HEAP32[(dirp + pos) >> 2] = id;\r\n      HEAP32[(dirp + pos + 4) >> 2] = stream.position;\r\n      HEAP16[(dirp + pos + 8) >> 1] = 268;\r\n      HEAP8[(dirp + pos + 10) >> 0] = type;\r\n      stringToUTF8(name, dirp + pos + 11, 256);\r\n      pos += 268;\r\n    }\r\n    return pos;\r\n  } catch (e) {\r\n    if (typeof FS === \"undefined\" || !(e instanceof FS.ErrnoError)) abort(e);\r\n    return -e.errno;\r\n  }\r\n}\r\n\r\nfunction ___syscall221(which, varargs) {\r\n  SYSCALLS.varargs = varargs;\r\n  try {\r\n    // fcntl64\r\n    var stream = SYSCALLS.getStreamFromFD(),\r\n      cmd = SYSCALLS.get();\r\n    switch (cmd) {\r\n      case 0: {\r\n        var arg = SYSCALLS.get();\r\n        if (arg < 0) {\r\n          return -ERRNO_CODES.EINVAL;\r\n        }\r\n        var newStream;\r\n        newStream = FS.open(stream.path, stream.flags, 0, arg);\r\n        return newStream.fd;\r\n      }\r\n      case 1:\r\n      case 2:\r\n        return 0; // FD_CLOEXEC makes no sense for a single process.\r\n      case 3:\r\n        return stream.flags;\r\n      case 4: {\r\n        var arg = SYSCALLS.get();\r\n        stream.flags |= arg;\r\n        return 0;\r\n      }\r\n      case 12: /* case 12: Currently in musl F_GETLK64 has same value as F_GETLK, so omitted to avoid duplicate case blocks. If that changes, uncomment this */\r\n      {\r\n        var arg = SYSCALLS.get();\r\n        var offset = 0;\r\n        // We're always unlocked.\r\n        HEAP16[(arg + offset) >> 1] = 2;\r\n        return 0;\r\n      }\r\n      case 13:\r\n      case 14:\r\n        /* case 13: Currently in musl F_SETLK64 has same value as F_SETLK, so omitted to avoid duplicate case blocks. If that changes, uncomment this */\r\n        /* case 14: Currently in musl F_SETLKW64 has same value as F_SETLKW, so omitted to avoid duplicate case blocks. If that changes, uncomment this */\r\n\r\n        return 0; // Pretend that the locking is successful.\r\n      case 16:\r\n      case 8:\r\n        return -ERRNO_CODES.EINVAL; // These are for sockets. We don't have them fully implemented yet.\r\n      case 9:\r\n        // musl trusts getown return values, due to a bug where they must be, as they overlap with errors. just return -1 here, so fnctl() returns that, and we set errno ourselves.\r\n        ___setErrNo(ERRNO_CODES.EINVAL);\r\n        return -1;\r\n      default: {\r\n        return -ERRNO_CODES.EINVAL;\r\n      }\r\n    }\r\n  } catch (e) {\r\n    if (typeof FS === \"undefined\" || !(e instanceof FS.ErrnoError)) abort(e);\r\n    return -e.errno;\r\n  }\r\n}\r\n\r\nfunction ___syscall3(which, varargs) {\r\n  SYSCALLS.varargs = varargs;\r\n  try {\r\n    // read\r\n    var stream = SYSCALLS.getStreamFromFD(),\r\n      buf = SYSCALLS.get(),\r\n      count = SYSCALLS.get();\r\n    return FS.read(stream, HEAP8, buf, count);\r\n  } catch (e) {\r\n    if (typeof FS === \"undefined\" || !(e instanceof FS.ErrnoError)) abort(e);\r\n    return -e.errno;\r\n  }\r\n}\r\n\r\nfunction ___syscall330(which, varargs) {\r\n  SYSCALLS.varargs = varargs;\r\n  try {\r\n    // dup3\r\n    var old = SYSCALLS.getStreamFromFD(),\r\n      suggestFD = SYSCALLS.get(),\r\n      flags = SYSCALLS.get();\r\n    assert(!flags);\r\n    if (old.fd === suggestFD) return -ERRNO_CODES.EINVAL;\r\n    return SYSCALLS.doDup(old.path, old.flags, suggestFD);\r\n  } catch (e) {\r\n    if (typeof FS === \"undefined\" || !(e instanceof FS.ErrnoError)) abort(e);\r\n    return -e.errno;\r\n  }\r\n}\r\n\r\nfunction ___syscall38(which, varargs) {\r\n  SYSCALLS.varargs = varargs;\r\n  try {\r\n    // rename\r\n    var old_path = SYSCALLS.getStr(),\r\n      new_path = SYSCALLS.getStr();\r\n    FS.rename(old_path, new_path);\r\n    return 0;\r\n  } catch (e) {\r\n    if (typeof FS === \"undefined\" || !(e instanceof FS.ErrnoError)) abort(e);\r\n    return -e.errno;\r\n  }\r\n}\r\n\r\nfunction ___syscall40(which, varargs) {\r\n  SYSCALLS.varargs = varargs;\r\n  try {\r\n    // rmdir\r\n    var path = SYSCALLS.getStr();\r\n    FS.rmdir(path);\r\n    return 0;\r\n  } catch (e) {\r\n    if (typeof FS === \"undefined\" || !(e instanceof FS.ErrnoError)) abort(e);\r\n    return -e.errno;\r\n  }\r\n}\r\n\r\nfunction ___syscall41(which, varargs) {\r\n  SYSCALLS.varargs = varargs;\r\n  try {\r\n    // dup\r\n    var old = SYSCALLS.getStreamFromFD();\r\n    return FS.open(old.path, old.flags, 0).fd;\r\n  } catch (e) {\r\n    if (typeof FS === \"undefined\" || !(e instanceof FS.ErrnoError)) abort(e);\r\n    return -e.errno;\r\n  }\r\n}\r\n\r\nfunction ___syscall5(which, varargs) {\r\n  SYSCALLS.varargs = varargs;\r\n  try {\r\n    // open\r\n    var pathname = SYSCALLS.getStr(),\r\n      flags = SYSCALLS.get(),\r\n      mode = SYSCALLS.get(); // optional TODO\r\n    var stream = FS.open(pathname, flags, mode);\r\n    return stream.fd;\r\n  } catch (e) {\r\n    if (typeof FS === \"undefined\" || !(e instanceof FS.ErrnoError)) abort(e);\r\n    return -e.errno;\r\n  }\r\n}\r\n\r\nfunction ___syscall54(which, varargs) {\r\n  SYSCALLS.varargs = varargs;\r\n  try {\r\n    // ioctl\r\n    var stream = SYSCALLS.getStreamFromFD(),\r\n      op = SYSCALLS.get();\r\n    switch (op) {\r\n      case 21509:\r\n      case 21505: {\r\n        if (!stream.tty) return -ERRNO_CODES.ENOTTY;\r\n        return 0;\r\n      }\r\n      case 21510:\r\n      case 21511:\r\n      case 21512:\r\n      case 21506:\r\n      case 21507:\r\n      case 21508: {\r\n        if (!stream.tty) return -ERRNO_CODES.ENOTTY;\r\n        return 0; // no-op, not actually adjusting terminal settings\r\n      }\r\n      case 21519: {\r\n        if (!stream.tty) return -ERRNO_CODES.ENOTTY;\r\n        var argp = SYSCALLS.get();\r\n        HEAP32[argp >> 2] = 0;\r\n        return 0;\r\n      }\r\n      case 21520: {\r\n        if (!stream.tty) return -ERRNO_CODES.ENOTTY;\r\n        return -ERRNO_CODES.EINVAL; // not supported\r\n      }\r\n      case 21531: {\r\n        var argp = SYSCALLS.get();\r\n        return FS.ioctl(stream, op, argp);\r\n      }\r\n      case 21523: {\r\n        // TODO: in theory we should write to the winsize struct that gets\r\n        // passed in, but for now musl doesn't read anything on it\r\n        if (!stream.tty) return -ERRNO_CODES.ENOTTY;\r\n        return 0;\r\n      }\r\n      case 21524: {\r\n        // TODO: technically, this ioctl call should change the window size.\r\n        // but, since emscripten doesn't have any concept of a terminal window\r\n        // yet, we'll just silently throw it away as we do TIOCGWINSZ\r\n        if (!stream.tty) return -ERRNO_CODES.ENOTTY;\r\n        return 0;\r\n      }\r\n      default:\r\n        abort(\"bad ioctl syscall \" + op);\r\n    }\r\n  } catch (e) {\r\n    if (typeof FS === \"undefined\" || !(e instanceof FS.ErrnoError)) abort(e);\r\n    return -e.errno;\r\n  }\r\n}\r\n\r\nfunction ___syscall6(which, varargs) {\r\n  SYSCALLS.varargs = varargs;\r\n  try {\r\n    // close\r\n    var stream = SYSCALLS.getStreamFromFD();\r\n    FS.close(stream);\r\n    return 0;\r\n  } catch (e) {\r\n    if (typeof FS === \"undefined\" || !(e instanceof FS.ErrnoError)) abort(e);\r\n    return -e.errno;\r\n  }\r\n}\r\n\r\nfunction ___syscall63(which, varargs) {\r\n  SYSCALLS.varargs = varargs;\r\n  try {\r\n    // dup2\r\n    var old = SYSCALLS.getStreamFromFD(),\r\n      suggestFD = SYSCALLS.get();\r\n    if (old.fd === suggestFD) return suggestFD;\r\n    return SYSCALLS.doDup(old.path, old.flags, suggestFD);\r\n  } catch (e) {\r\n    if (typeof FS === \"undefined\" || !(e instanceof FS.ErrnoError)) abort(e);\r\n    return -e.errno;\r\n  }\r\n}\r\n\r\nfunction ___syscall91(which, varargs) {\r\n  SYSCALLS.varargs = varargs;\r\n  try {\r\n    // munmap\r\n    var addr = SYSCALLS.get(),\r\n      len = SYSCALLS.get();\r\n    // TODO: support unmmap'ing parts of allocations\r\n    var info = SYSCALLS.mappings[addr];\r\n    if (!info) return 0;\r\n    if (len === info.len) {\r\n      var stream = FS.getStream(info.fd);\r\n      SYSCALLS.doMsync(addr, stream, len, info.flags);\r\n      FS.munmap(stream);\r\n      SYSCALLS.mappings[addr] = null;\r\n      if (info.allocated) {\r\n        _free(info.malloc);\r\n      }\r\n    }\r\n    return 0;\r\n  } catch (e) {\r\n    if (typeof FS === \"undefined\" || !(e instanceof FS.ErrnoError)) abort(e);\r\n    return -e.errno;\r\n  }\r\n}\r\n\r\nfunction ___unlock() {}\r\n\r\nfunction _difftime(time1, time0) {\r\n  return time1 - time0;\r\n}\r\n\r\nfunction _emscripten_get_heap_size() {\r\n  return TOTAL_MEMORY;\r\n}\r\n\r\nfunction _longjmp(env, value) {\r\n  _setThrew(env, value || 1);\r\n  throw \"longjmp\";\r\n}\r\n\r\nfunction _emscripten_longjmp(env, value) {\r\n  _longjmp(env, value);\r\n}\r\n\r\nfunction abortOnCannotGrowMemory(requestedSize) {\r\n  abort(\r\n    \"Cannot enlarge memory arrays to size \" +\r\n      requestedSize +\r\n      \" bytes. Either (1) compile with  -s TOTAL_MEMORY=X  with X higher than the current value \" +\r\n      TOTAL_MEMORY +\r\n      \", (2) compile with  -s ALLOW_MEMORY_GROWTH=1  which allows increasing the size at runtime, or (3) if you want malloc to return NULL (0) instead of this abort, compile with  -s ABORTING_MALLOC=0 \",\r\n  );\r\n}\r\n\r\nfunction emscripten_realloc_buffer(size) {\r\n  var PAGE_MULTIPLE = 65536;\r\n  size = alignUp(size, PAGE_MULTIPLE); // round up to wasm page size\r\n  var old = Module[\"buffer\"];\r\n  var oldSize = old.byteLength;\r\n  // native wasm support\r\n  try {\r\n    var result = wasmMemory.grow((size - oldSize) / 65536); // .grow() takes a delta compared to the previous size\r\n    if (result !== (-1 | 0)) {\r\n      // success in native wasm memory growth, get the buffer from the memory\r\n      return (Module[\"buffer\"] = wasmMemory.buffer);\r\n    } else {\r\n      return null;\r\n    }\r\n  } catch (e) {\r\n    console.error(\r\n      \"emscripten_realloc_buffer: Attempted to grow from \" +\r\n        oldSize +\r\n        \" bytes to \" +\r\n        size +\r\n        \" bytes, but got error: \" +\r\n        e,\r\n    );\r\n    return null;\r\n  }\r\n}\r\n\r\nfunction _emscripten_resize_heap(requestedSize) {\r\n  var oldSize = _emscripten_get_heap_size();\r\n  // TOTAL_MEMORY is the current size of the actual array, and DYNAMICTOP is the new top.\r\n  assert(requestedSize > oldSize); // This function should only ever be called after the ceiling of the dynamic heap has already been bumped to exceed the current total size of the asm.js heap.\r\n\r\n  var PAGE_MULTIPLE = 65536;\r\n  var LIMIT = 2147483648 - PAGE_MULTIPLE; // We can do one page short of 2GB as theoretical maximum.\r\n\r\n  if (requestedSize > LIMIT) {\r\n    err(\r\n      \"Cannot enlarge memory, asked to go up to \" +\r\n        requestedSize +\r\n        \" bytes, but the limit is \" +\r\n        LIMIT +\r\n        \" bytes!\",\r\n    );\r\n    return false;\r\n  }\r\n\r\n  var MIN_TOTAL_MEMORY = 16777216;\r\n  var newSize = Math.max(oldSize, MIN_TOTAL_MEMORY); // So the loop below will not be infinite, and minimum asm.js memory size is 16MB.\r\n\r\n  while (newSize < requestedSize) {\r\n    // Keep incrementing the heap size as long as it's less than what is requested.\r\n    if (newSize <= 536870912) {\r\n      newSize = alignUp(2 * newSize, PAGE_MULTIPLE); // Simple heuristic: double until 1GB...\r\n    } else {\r\n      // ..., but after that, add smaller increments towards 2GB, which we cannot reach\r\n      newSize = Math.min(\r\n        alignUp((3 * newSize + 2147483648) / 4, PAGE_MULTIPLE),\r\n        LIMIT,\r\n      );\r\n      if (newSize === oldSize) {\r\n        warnOnce(\r\n          \"Cannot ask for more memory since we reached the practical limit in browsers (which is just below 2GB), so the request would have failed. Requesting only \" +\r\n            TOTAL_MEMORY,\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  var start = Date.now();\r\n\r\n  var replacement = emscripten_realloc_buffer(newSize);\r\n  if (!replacement || replacement.byteLength != newSize) {\r\n    err(\r\n      \"Failed to grow the heap from \" +\r\n        oldSize +\r\n        \" bytes to \" +\r\n        newSize +\r\n        \" bytes, not enough memory!\",\r\n    );\r\n    if (replacement) {\r\n      err(\r\n        \"Expected to get back a buffer of size \" +\r\n          newSize +\r\n          \" bytes, but instead got back a buffer of size \" +\r\n          replacement.byteLength,\r\n      );\r\n    }\r\n    return false;\r\n  }\r\n\r\n  // everything worked\r\n  updateGlobalBuffer(replacement);\r\n  updateGlobalBufferViews();\r\n\r\n  TOTAL_MEMORY = newSize;\r\n  HEAPU32[DYNAMICTOP_PTR >> 2] = requestedSize;\r\n\r\n  return true;\r\n}\r\n\r\nfunction _exit(status) {\r\n  // void _exit(int status);\r\n  // http://pubs.opengroup.org/onlinepubs/000095399/functions/exit.html\r\n  exit(status);\r\n}\r\n\r\nfunction _getenv(name) {\r\n  // char *getenv(const char *name);\r\n  // http://pubs.opengroup.org/onlinepubs/009695399/functions/getenv.html\r\n  if (name === 0) return 0;\r\n  name = UTF8ToString(name);\r\n  if (!ENV.hasOwnProperty(name)) return 0;\r\n\r\n  if (_getenv.ret) _free(_getenv.ret);\r\n  _getenv.ret = allocateUTF8(ENV[name]);\r\n  return _getenv.ret;\r\n}\r\n\r\nfunction _gettimeofday(ptr) {\r\n  var now = Date.now();\r\n  HEAP32[ptr >> 2] = (now / 1000) | 0; // seconds\r\n  HEAP32[(ptr + 4) >> 2] = ((now % 1000) * 1000) | 0; // microseconds\r\n  return 0;\r\n}\r\n\r\nvar ___tm_current = 10348784;\r\n\r\nvar ___tm_timezone = (stringToUTF8(\"GMT\", 10348832, 4), 10348832);\r\n\r\nfunction _gmtime_r(time, tmPtr) {\r\n  var date = new Date(HEAP32[time >> 2] * 1000);\r\n  HEAP32[tmPtr >> 2] = date.getUTCSeconds();\r\n  HEAP32[(tmPtr + 4) >> 2] = date.getUTCMinutes();\r\n  HEAP32[(tmPtr + 8) >> 2] = date.getUTCHours();\r\n  HEAP32[(tmPtr + 12) >> 2] = date.getUTCDate();\r\n  HEAP32[(tmPtr + 16) >> 2] = date.getUTCMonth();\r\n  HEAP32[(tmPtr + 20) >> 2] = date.getUTCFullYear() - 1900;\r\n  HEAP32[(tmPtr + 24) >> 2] = date.getUTCDay();\r\n  HEAP32[(tmPtr + 36) >> 2] = 0;\r\n  HEAP32[(tmPtr + 32) >> 2] = 0;\r\n  var start = Date.UTC(date.getUTCFullYear(), 0, 1, 0, 0, 0, 0);\r\n  var yday = ((date.getTime() - start) / (1000 * 60 * 60 * 24)) | 0;\r\n  HEAP32[(tmPtr + 28) >> 2] = yday;\r\n  HEAP32[(tmPtr + 40) >> 2] = ___tm_timezone;\r\n\r\n  return tmPtr;\r\n}\r\n\r\nfunction _gmtime(time) {\r\n  return _gmtime_r(time, ___tm_current);\r\n}\r\n\r\nfunction _llvm_bswap_i64(l, h) {\r\n  var retl = _llvm_bswap_i32(h) >>> 0;\r\n  var reth = _llvm_bswap_i32(l) >>> 0;\r\n  return (setTempRet0(reth), retl) | 0;\r\n}\r\n\r\nfunction _tzset() {\r\n  // TODO: Use (malleable) environment variables instead of system settings.\r\n  if (_tzset.called) return;\r\n  _tzset.called = true;\r\n\r\n  // timezone is specified as seconds west of UTC (\"The external variable\r\n  // `timezone` shall be set to the difference, in seconds, between\r\n  // Coordinated Universal Time (UTC) and local standard time.\"), the same\r\n  // as returned by getTimezoneOffset().\r\n  // See http://pubs.opengroup.org/onlinepubs/009695399/functions/tzset.html\r\n  HEAP32[__get_timezone() >> 2] = new Date().getTimezoneOffset() * 60;\r\n\r\n  var winter = new Date(2000, 0, 1);\r\n  var summer = new Date(2000, 6, 1);\r\n  HEAP32[__get_daylight() >> 2] = Number(\r\n    winter.getTimezoneOffset() != summer.getTimezoneOffset(),\r\n  );\r\n\r\n  function extractZone(date) {\r\n    var match = date.toTimeString().match(/\\(([A-Za-z ]+)\\)$/);\r\n    return match ? match[1] : \"GMT\";\r\n  }\r\n  var winterName = extractZone(winter);\r\n  var summerName = extractZone(summer);\r\n  var winterNamePtr = allocate(\r\n    intArrayFromString(winterName),\r\n    \"i8\",\r\n    ALLOC_NORMAL,\r\n  );\r\n  var summerNamePtr = allocate(\r\n    intArrayFromString(summerName),\r\n    \"i8\",\r\n    ALLOC_NORMAL,\r\n  );\r\n  if (summer.getTimezoneOffset() < winter.getTimezoneOffset()) {\r\n    // Northern hemisphere\r\n    HEAP32[__get_tzname() >> 2] = winterNamePtr;\r\n    HEAP32[(__get_tzname() + 4) >> 2] = summerNamePtr;\r\n  } else {\r\n    HEAP32[__get_tzname() >> 2] = summerNamePtr;\r\n    HEAP32[(__get_tzname() + 4) >> 2] = winterNamePtr;\r\n  }\r\n}\r\n\r\nfunction _localtime_r(time, tmPtr) {\r\n  _tzset();\r\n  var date = new Date(HEAP32[time >> 2] * 1000);\r\n  HEAP32[tmPtr >> 2] = date.getSeconds();\r\n  HEAP32[(tmPtr + 4) >> 2] = date.getMinutes();\r\n  HEAP32[(tmPtr + 8) >> 2] = date.getHours();\r\n  HEAP32[(tmPtr + 12) >> 2] = date.getDate();\r\n  HEAP32[(tmPtr + 16) >> 2] = date.getMonth();\r\n  HEAP32[(tmPtr + 20) >> 2] = date.getFullYear() - 1900;\r\n  HEAP32[(tmPtr + 24) >> 2] = date.getDay();\r\n\r\n  var start = new Date(date.getFullYear(), 0, 1);\r\n  var yday = ((date.getTime() - start.getTime()) / (1000 * 60 * 60 * 24)) | 0;\r\n  HEAP32[(tmPtr + 28) >> 2] = yday;\r\n  HEAP32[(tmPtr + 36) >> 2] = -(date.getTimezoneOffset() * 60);\r\n\r\n  // Attention: DST is in December in South, and some regions don't have DST at all.\r\n  var summerOffset = new Date(2000, 6, 1).getTimezoneOffset();\r\n  var winterOffset = start.getTimezoneOffset();\r\n  var dst =\r\n    (summerOffset != winterOffset &&\r\n      date.getTimezoneOffset() == Math.min(winterOffset, summerOffset)) | 0;\r\n  HEAP32[(tmPtr + 32) >> 2] = dst;\r\n\r\n  var zonePtr = HEAP32[(__get_tzname() + (dst ? 4 : 0)) >> 2];\r\n  HEAP32[(tmPtr + 40) >> 2] = zonePtr;\r\n\r\n  return tmPtr;\r\n}\r\n\r\nfunction _localtime(time) {\r\n  return _localtime_r(time, ___tm_current);\r\n}\r\n\r\nfunction _emscripten_memcpy_big(dest, src, num) {\r\n  HEAPU8.set(HEAPU8.subarray(src, src + num), dest);\r\n}\r\n\r\nvar _Int8Array = undefined;\r\n\r\nvar _Int32Array = undefined;\r\n\r\nfunction _mktime(tmPtr) {\r\n  _tzset();\r\n  var date = new Date(\r\n    HEAP32[(tmPtr + 20) >> 2] + 1900,\r\n    HEAP32[(tmPtr + 16) >> 2],\r\n    HEAP32[(tmPtr + 12) >> 2],\r\n    HEAP32[(tmPtr + 8) >> 2],\r\n    HEAP32[(tmPtr + 4) >> 2],\r\n    HEAP32[tmPtr >> 2],\r\n    0,\r\n  );\r\n\r\n  // There's an ambiguous hour when the time goes back; the tm_isdst field is\r\n  // used to disambiguate it.  Date() basically guesses, so we fix it up if it\r\n  // guessed wrong, or fill in tm_isdst with the guess if it's -1.\r\n  var dst = HEAP32[(tmPtr + 32) >> 2];\r\n  var guessedOffset = date.getTimezoneOffset();\r\n  var start = new Date(date.getFullYear(), 0, 1);\r\n  var summerOffset = new Date(2000, 6, 1).getTimezoneOffset();\r\n  var winterOffset = start.getTimezoneOffset();\r\n  var dstOffset = Math.min(winterOffset, summerOffset); // DST is in December in South\r\n  if (dst < 0) {\r\n    // Attention: some regions don't have DST at all.\r\n    HEAP32[(tmPtr + 32) >> 2] = Number(\r\n      summerOffset != winterOffset && dstOffset == guessedOffset,\r\n    );\r\n  } else if (dst > 0 != (dstOffset == guessedOffset)) {\r\n    var nonDstOffset = Math.max(winterOffset, summerOffset);\r\n    var trueOffset = dst > 0 ? dstOffset : nonDstOffset;\r\n    // Don't try setMinutes(date.getMinutes() + ...) -- it's messed up.\r\n    date.setTime(date.getTime() + (trueOffset - guessedOffset) * 60000);\r\n  }\r\n\r\n  HEAP32[(tmPtr + 24) >> 2] = date.getDay();\r\n  var yday = ((date.getTime() - start.getTime()) / (1000 * 60 * 60 * 24)) | 0;\r\n  HEAP32[(tmPtr + 28) >> 2] = yday;\r\n\r\n  return (date.getTime() / 1000) | 0;\r\n}\r\n\r\nfunction _pthread_mutex_destroy() {}\r\n\r\nfunction _pthread_mutex_init() {}\r\n\r\nvar _Math_floor = undefined;\r\n\r\nvar _Math_ceil = undefined;\r\n\r\nfunction _time(ptr) {\r\n  var ret = (Date.now() / 1000) | 0;\r\n  if (ptr) {\r\n    HEAP32[ptr >> 2] = ret;\r\n  }\r\n  return ret;\r\n}\r\n\r\nfunction _times(buffer) {\r\n  // clock_t times(struct tms *buffer);\r\n  // http://pubs.opengroup.org/onlinepubs/009695399/functions/times.html\r\n  // NOTE: This is fake, since we can't calculate real CPU time usage in JS.\r\n  if (buffer !== 0) {\r\n    _memset(buffer, 0, 16);\r\n  }\r\n  return 0;\r\n}\r\n\r\nif (ENVIRONMENT_IS_NODE) {\r\n  _emscripten_get_now = function _emscripten_get_now_actual() {\r\n    var t = process[\"hrtime\"]();\r\n    return t[0] * 1e3 + t[1] / 1e6;\r\n  };\r\n} else if (typeof dateNow !== \"undefined\") {\r\n  _emscripten_get_now = dateNow;\r\n} else if (\r\n  typeof self === \"object\" &&\r\n  self[\"performance\"] &&\r\n  typeof self[\"performance\"][\"now\"] === \"function\"\r\n) {\r\n  _emscripten_get_now = function () {\r\n    return self[\"performance\"][\"now\"]();\r\n  };\r\n} else if (\r\n  typeof performance === \"object\" &&\r\n  typeof performance[\"now\"] === \"function\"\r\n) {\r\n  _emscripten_get_now = function () {\r\n    return performance[\"now\"]();\r\n  };\r\n} else {\r\n  _emscripten_get_now = Date.now;\r\n}\r\nFS.staticInit();\r\n__ATINIT__.unshift(function () {\r\n  if (!Module[\"noFSInit\"] && !FS.init.initialized) FS.init();\r\n});\r\n__ATMAIN__.push(function () {\r\n  FS.ignorePermissions = false;\r\n});\r\n__ATEXIT__.push(function () {\r\n  FS.quit();\r\n});\r\n__ATINIT__.unshift(function () {\r\n  TTY.init();\r\n});\r\n__ATEXIT__.push(function () {\r\n  TTY.shutdown();\r\n});\r\nif (ENVIRONMENT_IS_NODE) {\r\n  var fs = require(\"fs\");\r\n  var NODEJS_PATH = require(\"path\");\r\n  NODEFS.staticInit();\r\n}\r\nvar ASSERTIONS = true;\r\n\r\n// Copyright 2017 The Emscripten Authors.  All rights reserved.\r\n// Emscripten is available under two separate licenses, the MIT license and the\r\n// University of Illinois/NCSA Open Source License.  Both these licenses can be\r\n// found in the LICENSE file.\r\n\r\n/** @type {function(string, boolean=, number=)} */\r\nfunction intArrayFromString(stringy, dontAddNull, length) {\r\n  var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1;\r\n  var u8array = new Array(len);\r\n  var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);\r\n  if (dontAddNull) u8array.length = numBytesWritten;\r\n  return u8array;\r\n}\r\n\r\nfunction intArrayToString(array) {\r\n  var ret = [];\r\n  for (var i = 0; i < array.length; i++) {\r\n    var chr = array[i];\r\n    if (chr > 0xff) {\r\n      if (ASSERTIONS) {\r\n        assert(\r\n          false,\r\n          \"Character code \" +\r\n            chr +\r\n            \" (\" +\r\n            String.fromCharCode(chr) +\r\n            \")  at offset \" +\r\n            i +\r\n            \" not in 0x00-0xFF.\",\r\n        );\r\n      }\r\n      chr &= 0xff;\r\n    }\r\n    ret.push(String.fromCharCode(chr));\r\n  }\r\n  return ret.join(\"\");\r\n}\r\n\r\n// ASM_LIBRARY EXTERN PRIMITIVES: Int8Array,Int32Array,Math_floor,Math_ceil\r\n\r\nfunction nullFunc_dd(x) {\r\n  err(\r\n    \"Invalid function pointer called with signature 'dd'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\",\r\n  );\r\n  err(\"Build with ASSERTIONS=2 for more info.\");\r\n  abort(x);\r\n}\r\n\r\nfunction nullFunc_ddd(x) {\r\n  err(\r\n    \"Invalid function pointer called with signature 'ddd'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\",\r\n  );\r\n  err(\"Build with ASSERTIONS=2 for more info.\");\r\n  abort(x);\r\n}\r\n\r\nfunction nullFunc_diiid(x) {\r\n  err(\r\n    \"Invalid function pointer called with signature 'diiid'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\",\r\n  );\r\n  err(\"Build with ASSERTIONS=2 for more info.\");\r\n  abort(x);\r\n}\r\n\r\nfunction nullFunc_fdd(x) {\r\n  err(\r\n    \"Invalid function pointer called with signature 'fdd'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\",\r\n  );\r\n  err(\"Build with ASSERTIONS=2 for more info.\");\r\n  abort(x);\r\n}\r\n\r\nfunction nullFunc_fdi(x) {\r\n  err(\r\n    \"Invalid function pointer called with signature 'fdi'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\",\r\n  );\r\n  err(\"Build with ASSERTIONS=2 for more info.\");\r\n  abort(x);\r\n}\r\n\r\nfunction nullFunc_fdii(x) {\r\n  err(\r\n    \"Invalid function pointer called with signature 'fdii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\",\r\n  );\r\n  err(\"Build with ASSERTIONS=2 for more info.\");\r\n  abort(x);\r\n}\r\n\r\nfunction nullFunc_fiii(x) {\r\n  err(\r\n    \"Invalid function pointer called with signature 'fiii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\",\r\n  );\r\n  err(\"Build with ASSERTIONS=2 for more info.\");\r\n  abort(x);\r\n}\r\n\r\nfunction nullFunc_i(x) {\r\n  err(\r\n    \"Invalid function pointer called with signature 'i'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\",\r\n  );\r\n  err(\"Build with ASSERTIONS=2 for more info.\");\r\n  abort(x);\r\n}\r\n\r\nfunction nullFunc_id(x) {\r\n  err(\r\n    \"Invalid function pointer called with signature 'id'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\",\r\n  );\r\n  err(\"Build with ASSERTIONS=2 for more info.\");\r\n  abort(x);\r\n}\r\n\r\nfunction nullFunc_idii(x) {\r\n  err(\r\n    \"Invalid function pointer called with signature 'idii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\",\r\n  );\r\n  err(\"Build with ASSERTIONS=2 for more info.\");\r\n  abort(x);\r\n}\r\n\r\nfunction nullFunc_ii(x) {\r\n  err(\r\n    \"Invalid function pointer called with signature 'ii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\",\r\n  );\r\n  err(\"Build with ASSERTIONS=2 for more info.\");\r\n  abort(x);\r\n}\r\n\r\nfunction nullFunc_iid(x) {\r\n  err(\r\n    \"Invalid function pointer called with signature 'iid'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\",\r\n  );\r\n  err(\"Build with ASSERTIONS=2 for more info.\");\r\n  abort(x);\r\n}\r\n\r\nfunction nullFunc_iiddddddddi(x) {\r\n  err(\r\n    \"Invalid function pointer called with signature 'iiddddddddi'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\",\r\n  );\r\n  err(\"Build with ASSERTIONS=2 for more info.\");\r\n  abort(x);\r\n}\r\n\r\nfunction nullFunc_iiddddi(x) {\r\n  err(\r\n    \"Invalid function pointer called with signature 'iiddddi'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\",\r\n  );\r\n  err(\"Build with ASSERTIONS=2 for more info.\");\r\n  abort(x);\r\n}\r\n\r\nfunction nullFunc_iidi(x) {\r\n  err(\r\n    \"Invalid function pointer called with signature 'iidi'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\",\r\n  );\r\n  err(\"Build with ASSERTIONS=2 for more info.\");\r\n  abort(x);\r\n}\r\n\r\nfunction nullFunc_iidiii(x) {\r\n  err(\r\n    \"Invalid function pointer called with signature 'iidiii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\",\r\n  );\r\n  err(\"Build with ASSERTIONS=2 for more info.\");\r\n  abort(x);\r\n}\r\n\r\nfunction nullFunc_iii(x) {\r\n  err(\r\n    \"Invalid function pointer called with signature 'iii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\",\r\n  );\r\n  err(\"Build with ASSERTIONS=2 for more info.\");\r\n  abort(x);\r\n}\r\n\r\nfunction nullFunc_iiii(x) {\r\n  err(\r\n    \"Invalid function pointer called with signature 'iiii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\",\r\n  );\r\n  err(\"Build with ASSERTIONS=2 for more info.\");\r\n  abort(x);\r\n}\r\n\r\nfunction nullFunc_iiiid(x) {\r\n  err(\r\n    \"Invalid function pointer called with signature 'iiiid'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\",\r\n  );\r\n  err(\"Build with ASSERTIONS=2 for more info.\");\r\n  abort(x);\r\n}\r\n\r\nfunction nullFunc_iiiii(x) {\r\n  err(\r\n    \"Invalid function pointer called with signature 'iiiii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\",\r\n  );\r\n  err(\"Build with ASSERTIONS=2 for more info.\");\r\n  abort(x);\r\n}\r\n\r\nfunction nullFunc_iiiiii(x) {\r\n  err(\r\n    \"Invalid function pointer called with signature 'iiiiii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\",\r\n  );\r\n  err(\"Build with ASSERTIONS=2 for more info.\");\r\n  abort(x);\r\n}\r\n\r\nfunction nullFunc_iiiiiii(x) {\r\n  err(\r\n    \"Invalid function pointer called with signature 'iiiiiii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\",\r\n  );\r\n  err(\"Build with ASSERTIONS=2 for more info.\");\r\n  abort(x);\r\n}\r\n\r\nfunction nullFunc_iiiiiiii(x) {\r\n  err(\r\n    \"Invalid function pointer called with signature 'iiiiiiii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\",\r\n  );\r\n  err(\"Build with ASSERTIONS=2 for more info.\");\r\n  abort(x);\r\n}\r\n\r\nfunction nullFunc_iiiiiiiifi(x) {\r\n  err(\r\n    \"Invalid function pointer called with signature 'iiiiiiiifi'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\",\r\n  );\r\n  err(\"Build with ASSERTIONS=2 for more info.\");\r\n  abort(x);\r\n}\r\n\r\nfunction nullFunc_iiiiiiiii(x) {\r\n  err(\r\n    \"Invalid function pointer called with signature 'iiiiiiiii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\",\r\n  );\r\n  err(\"Build with ASSERTIONS=2 for more info.\");\r\n  abort(x);\r\n}\r\n\r\nfunction nullFunc_iiiiiiiiii(x) {\r\n  err(\r\n    \"Invalid function pointer called with signature 'iiiiiiiiii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\",\r\n  );\r\n  err(\"Build with ASSERTIONS=2 for more info.\");\r\n  abort(x);\r\n}\r\n\r\nfunction nullFunc_iiiiiiiiiii(x) {\r\n  err(\r\n    \"Invalid function pointer called with signature 'iiiiiiiiiii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\",\r\n  );\r\n  err(\"Build with ASSERTIONS=2 for more info.\");\r\n  abort(x);\r\n}\r\n\r\nfunction nullFunc_iiiiiiiiiiii(x) {\r\n  err(\r\n    \"Invalid function pointer called with signature 'iiiiiiiiiiii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\",\r\n  );\r\n  err(\"Build with ASSERTIONS=2 for more info.\");\r\n  abort(x);\r\n}\r\n\r\nfunction nullFunc_iiiiiiiiiiiii(x) {\r\n  err(\r\n    \"Invalid function pointer called with signature 'iiiiiiiiiiiii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\",\r\n  );\r\n  err(\"Build with ASSERTIONS=2 for more info.\");\r\n  abort(x);\r\n}\r\n\r\nfunction nullFunc_iiiiiiiiiiiiii(x) {\r\n  err(\r\n    \"Invalid function pointer called with signature 'iiiiiiiiiiiiii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\",\r\n  );\r\n  err(\"Build with ASSERTIONS=2 for more info.\");\r\n  abort(x);\r\n}\r\n\r\nfunction nullFunc_iiiiiiiiiiiiiii(x) {\r\n  err(\r\n    \"Invalid function pointer called with signature 'iiiiiiiiiiiiiii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\",\r\n  );\r\n  err(\"Build with ASSERTIONS=2 for more info.\");\r\n  abort(x);\r\n}\r\n\r\nfunction nullFunc_iiiiiiiiiiiiiiii(x) {\r\n  err(\r\n    \"Invalid function pointer called with signature 'iiiiiiiiiiiiiiii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\",\r\n  );\r\n  err(\"Build with ASSERTIONS=2 for more info.\");\r\n  abort(x);\r\n}\r\n\r\nfunction nullFunc_iiiiiiiiiiiiiiiii(x) {\r\n  err(\r\n    \"Invalid function pointer called with signature 'iiiiiiiiiiiiiiiii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\",\r\n  );\r\n  err(\"Build with ASSERTIONS=2 for more info.\");\r\n  abort(x);\r\n}\r\n\r\nfunction nullFunc_iiiiiiiiiiji(x) {\r\n  err(\r\n    \"Invalid function pointer called with signature 'iiiiiiiiiiji'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\",\r\n  );\r\n  err(\"Build with ASSERTIONS=2 for more info.\");\r\n  abort(x);\r\n}\r\n\r\nfunction nullFunc_iiiiiiiiiijj(x) {\r\n  err(\r\n    \"Invalid function pointer called with signature 'iiiiiiiiiijj'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\",\r\n  );\r\n  err(\"Build with ASSERTIONS=2 for more info.\");\r\n  abort(x);\r\n}\r\n\r\nfunction nullFunc_iiiiiiijjii(x) {\r\n  err(\r\n    \"Invalid function pointer called with signature 'iiiiiiijjii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\",\r\n  );\r\n  err(\"Build with ASSERTIONS=2 for more info.\");\r\n  abort(x);\r\n}\r\n\r\nfunction nullFunc_iiiiiij(x) {\r\n  err(\r\n    \"Invalid function pointer called with signature 'iiiiiij'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\",\r\n  );\r\n  err(\"Build with ASSERTIONS=2 for more info.\");\r\n  abort(x);\r\n}\r\n\r\nfunction nullFunc_iiiiiiji(x) {\r\n  err(\r\n    \"Invalid function pointer called with signature 'iiiiiiji'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\",\r\n  );\r\n  err(\"Build with ASSERTIONS=2 for more info.\");\r\n  abort(x);\r\n}\r\n\r\nfunction nullFunc_iiiiijiii(x) {\r\n  err(\r\n    \"Invalid function pointer called with signature 'iiiiijiii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\",\r\n  );\r\n  err(\"Build with ASSERTIONS=2 for more info.\");\r\n  abort(x);\r\n}\r\n\r\nfunction nullFunc_iiiijii(x) {\r\n  err(\r\n    \"Invalid function pointer called with signature 'iiiijii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\",\r\n  );\r\n  err(\"Build with ASSERTIONS=2 for more info.\");\r\n  abort(x);\r\n}\r\n\r\nfunction nullFunc_iij(x) {\r\n  err(\r\n    \"Invalid function pointer called with signature 'iij'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\",\r\n  );\r\n  err(\"Build with ASSERTIONS=2 for more info.\");\r\n  abort(x);\r\n}\r\n\r\nfunction nullFunc_iiji(x) {\r\n  err(\r\n    \"Invalid function pointer called with signature 'iiji'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\",\r\n  );\r\n  err(\"Build with ASSERTIONS=2 for more info.\");\r\n  abort(x);\r\n}\r\n\r\nfunction nullFunc_iijii(x) {\r\n  err(\r\n    \"Invalid function pointer called with signature 'iijii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\",\r\n  );\r\n  err(\"Build with ASSERTIONS=2 for more info.\");\r\n  abort(x);\r\n}\r\n\r\nfunction nullFunc_iijj(x) {\r\n  err(\r\n    \"Invalid function pointer called with signature 'iijj'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\",\r\n  );\r\n  err(\"Build with ASSERTIONS=2 for more info.\");\r\n  abort(x);\r\n}\r\n\r\nfunction nullFunc_iijjjjjj(x) {\r\n  err(\r\n    \"Invalid function pointer called with signature 'iijjjjjj'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\",\r\n  );\r\n  err(\"Build with ASSERTIONS=2 for more info.\");\r\n  abort(x);\r\n}\r\n\r\nfunction nullFunc_iji(x) {\r\n  err(\r\n    \"Invalid function pointer called with signature 'iji'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\",\r\n  );\r\n  err(\"Build with ASSERTIONS=2 for more info.\");\r\n  abort(x);\r\n}\r\n\r\nfunction nullFunc_ji(x) {\r\n  err(\r\n    \"Invalid function pointer called with signature 'ji'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\",\r\n  );\r\n  err(\"Build with ASSERTIONS=2 for more info.\");\r\n  abort(x);\r\n}\r\n\r\nfunction nullFunc_jii(x) {\r\n  err(\r\n    \"Invalid function pointer called with signature 'jii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\",\r\n  );\r\n  err(\"Build with ASSERTIONS=2 for more info.\");\r\n  abort(x);\r\n}\r\n\r\nfunction nullFunc_jiiiii(x) {\r\n  err(\r\n    \"Invalid function pointer called with signature 'jiiiii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\",\r\n  );\r\n  err(\"Build with ASSERTIONS=2 for more info.\");\r\n  abort(x);\r\n}\r\n\r\nfunction nullFunc_jiji(x) {\r\n  err(\r\n    \"Invalid function pointer called with signature 'jiji'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\",\r\n  );\r\n  err(\"Build with ASSERTIONS=2 for more info.\");\r\n  abort(x);\r\n}\r\n\r\nfunction nullFunc_jji(x) {\r\n  err(\r\n    \"Invalid function pointer called with signature 'jji'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\",\r\n  );\r\n  err(\"Build with ASSERTIONS=2 for more info.\");\r\n  abort(x);\r\n}\r\n\r\nfunction nullFunc_vi(x) {\r\n  err(\r\n    \"Invalid function pointer called with signature 'vi'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\",\r\n  );\r\n  err(\"Build with ASSERTIONS=2 for more info.\");\r\n  abort(x);\r\n}\r\n\r\nfunction nullFunc_vii(x) {\r\n  err(\r\n    \"Invalid function pointer called with signature 'vii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\",\r\n  );\r\n  err(\"Build with ASSERTIONS=2 for more info.\");\r\n  abort(x);\r\n}\r\n\r\nfunction nullFunc_viii(x) {\r\n  err(\r\n    \"Invalid function pointer called with signature 'viii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\",\r\n  );\r\n  err(\"Build with ASSERTIONS=2 for more info.\");\r\n  abort(x);\r\n}\r\n\r\nfunction nullFunc_viiii(x) {\r\n  err(\r\n    \"Invalid function pointer called with signature 'viiii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\",\r\n  );\r\n  err(\"Build with ASSERTIONS=2 for more info.\");\r\n  abort(x);\r\n}\r\n\r\nfunction nullFunc_viiiii(x) {\r\n  err(\r\n    \"Invalid function pointer called with signature 'viiiii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\",\r\n  );\r\n  err(\"Build with ASSERTIONS=2 for more info.\");\r\n  abort(x);\r\n}\r\n\r\nfunction nullFunc_viiiiii(x) {\r\n  err(\r\n    \"Invalid function pointer called with signature 'viiiiii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\",\r\n  );\r\n  err(\"Build with ASSERTIONS=2 for more info.\");\r\n  abort(x);\r\n}\r\n\r\nfunction nullFunc_viiiiiii(x) {\r\n  err(\r\n    \"Invalid function pointer called with signature 'viiiiiii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\",\r\n  );\r\n  err(\"Build with ASSERTIONS=2 for more info.\");\r\n  abort(x);\r\n}\r\n\r\nfunction nullFunc_viiiiiiii(x) {\r\n  err(\r\n    \"Invalid function pointer called with signature 'viiiiiiii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\",\r\n  );\r\n  err(\"Build with ASSERTIONS=2 for more info.\");\r\n  abort(x);\r\n}\r\n\r\nfunction nullFunc_viiiiiiiii(x) {\r\n  err(\r\n    \"Invalid function pointer called with signature 'viiiiiiiii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\",\r\n  );\r\n  err(\"Build with ASSERTIONS=2 for more info.\");\r\n  abort(x);\r\n}\r\n\r\nfunction nullFunc_viiiiiiiiiiiiiiiiiiiiiiiiiiiiiiijiiiiii(x) {\r\n  err(\r\n    \"Invalid function pointer called with signature 'viiiiiiiiiiiiiiiiiiiiiiiiiiiiiiijiiiiii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\",\r\n  );\r\n  err(\"Build with ASSERTIONS=2 for more info.\");\r\n  abort(x);\r\n}\r\n\r\nfunction nullFunc_viiiiiiiiiiiiiijiiiii(x) {\r\n  err(\r\n    \"Invalid function pointer called with signature 'viiiiiiiiiiiiiijiiiii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\",\r\n  );\r\n  err(\"Build with ASSERTIONS=2 for more info.\");\r\n  abort(x);\r\n}\r\n\r\nfunction nullFunc_viiiiiiiiijiiii(x) {\r\n  err(\r\n    \"Invalid function pointer called with signature 'viiiiiiiiijiiii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\",\r\n  );\r\n  err(\"Build with ASSERTIONS=2 for more info.\");\r\n  abort(x);\r\n}\r\n\r\nfunction nullFunc_vijii(x) {\r\n  err(\r\n    \"Invalid function pointer called with signature 'vijii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\",\r\n  );\r\n  err(\"Build with ASSERTIONS=2 for more info.\");\r\n  abort(x);\r\n}\r\n\r\nfunction invoke_ii(index, a1) {\r\n  var sp = stackSave();\r\n  try {\r\n    return dynCall_ii(index, a1);\r\n  } catch (e) {\r\n    stackRestore(sp);\r\n    if (e !== e + 0 && e !== \"longjmp\") throw e;\r\n    _setThrew(1, 0);\r\n  }\r\n}\r\n\r\nfunction invoke_iii(index, a1, a2) {\r\n  var sp = stackSave();\r\n  try {\r\n    return dynCall_iii(index, a1, a2);\r\n  } catch (e) {\r\n    stackRestore(sp);\r\n    if (e !== e + 0 && e !== \"longjmp\") throw e;\r\n    _setThrew(1, 0);\r\n  }\r\n}\r\n\r\nfunction invoke_iiii(index, a1, a2, a3) {\r\n  var sp = stackSave();\r\n  try {\r\n    return dynCall_iiii(index, a1, a2, a3);\r\n  } catch (e) {\r\n    stackRestore(sp);\r\n    if (e !== e + 0 && e !== \"longjmp\") throw e;\r\n    _setThrew(1, 0);\r\n  }\r\n}\r\n\r\nfunction invoke_iiiii(index, a1, a2, a3, a4) {\r\n  var sp = stackSave();\r\n  try {\r\n    return dynCall_iiiii(index, a1, a2, a3, a4);\r\n  } catch (e) {\r\n    stackRestore(sp);\r\n    if (e !== e + 0 && e !== \"longjmp\") throw e;\r\n    _setThrew(1, 0);\r\n  }\r\n}\r\n\r\nfunction invoke_vi(index, a1) {\r\n  var sp = stackSave();\r\n  try {\r\n    dynCall_vi(index, a1);\r\n  } catch (e) {\r\n    stackRestore(sp);\r\n    if (e !== e + 0 && e !== \"longjmp\") throw e;\r\n    _setThrew(1, 0);\r\n  }\r\n}\r\n\r\nfunction invoke_vii(index, a1, a2) {\r\n  var sp = stackSave();\r\n  try {\r\n    dynCall_vii(index, a1, a2);\r\n  } catch (e) {\r\n    stackRestore(sp);\r\n    if (e !== e + 0 && e !== \"longjmp\") throw e;\r\n    _setThrew(1, 0);\r\n  }\r\n}\r\n\r\nfunction invoke_viii(index, a1, a2, a3) {\r\n  var sp = stackSave();\r\n  try {\r\n    dynCall_viii(index, a1, a2, a3);\r\n  } catch (e) {\r\n    stackRestore(sp);\r\n    if (e !== e + 0 && e !== \"longjmp\") throw e;\r\n    _setThrew(1, 0);\r\n  }\r\n}\r\n\r\nfunction invoke_viiii(index, a1, a2, a3, a4) {\r\n  var sp = stackSave();\r\n  try {\r\n    dynCall_viiii(index, a1, a2, a3, a4);\r\n  } catch (e) {\r\n    stackRestore(sp);\r\n    if (e !== e + 0 && e !== \"longjmp\") throw e;\r\n    _setThrew(1, 0);\r\n  }\r\n}\r\n\r\nvar asmGlobalArg = {};\r\n\r\nvar asmLibraryArg = {\r\n  abort: abort,\r\n  setTempRet0: setTempRet0,\r\n  getTempRet0: getTempRet0,\r\n  abortStackOverflow: abortStackOverflow,\r\n  nullFunc_dd: nullFunc_dd,\r\n  nullFunc_ddd: nullFunc_ddd,\r\n  nullFunc_diiid: nullFunc_diiid,\r\n  nullFunc_fdd: nullFunc_fdd,\r\n  nullFunc_fdi: nullFunc_fdi,\r\n  nullFunc_fdii: nullFunc_fdii,\r\n  nullFunc_fiii: nullFunc_fiii,\r\n  nullFunc_i: nullFunc_i,\r\n  nullFunc_id: nullFunc_id,\r\n  nullFunc_idii: nullFunc_idii,\r\n  nullFunc_ii: nullFunc_ii,\r\n  nullFunc_iid: nullFunc_iid,\r\n  nullFunc_iiddddddddi: nullFunc_iiddddddddi,\r\n  nullFunc_iiddddi: nullFunc_iiddddi,\r\n  nullFunc_iidi: nullFunc_iidi,\r\n  nullFunc_iidiii: nullFunc_iidiii,\r\n  nullFunc_iii: nullFunc_iii,\r\n  nullFunc_iiii: nullFunc_iiii,\r\n  nullFunc_iiiid: nullFunc_iiiid,\r\n  nullFunc_iiiii: nullFunc_iiiii,\r\n  nullFunc_iiiiii: nullFunc_iiiiii,\r\n  nullFunc_iiiiiii: nullFunc_iiiiiii,\r\n  nullFunc_iiiiiiii: nullFunc_iiiiiiii,\r\n  nullFunc_iiiiiiiifi: nullFunc_iiiiiiiifi,\r\n  nullFunc_iiiiiiiii: nullFunc_iiiiiiiii,\r\n  nullFunc_iiiiiiiiii: nullFunc_iiiiiiiiii,\r\n  nullFunc_iiiiiiiiiii: nullFunc_iiiiiiiiiii,\r\n  nullFunc_iiiiiiiiiiii: nullFunc_iiiiiiiiiiii,\r\n  nullFunc_iiiiiiiiiiiii: nullFunc_iiiiiiiiiiiii,\r\n  nullFunc_iiiiiiiiiiiiii: nullFunc_iiiiiiiiiiiiii,\r\n  nullFunc_iiiiiiiiiiiiiii: nullFunc_iiiiiiiiiiiiiii,\r\n  nullFunc_iiiiiiiiiiiiiiii: nullFunc_iiiiiiiiiiiiiiii,\r\n  nullFunc_iiiiiiiiiiiiiiiii: nullFunc_iiiiiiiiiiiiiiiii,\r\n  nullFunc_iiiiiiiiiiji: nullFunc_iiiiiiiiiiji,\r\n  nullFunc_iiiiiiiiiijj: nullFunc_iiiiiiiiiijj,\r\n  nullFunc_iiiiiiijjii: nullFunc_iiiiiiijjii,\r\n  nullFunc_iiiiiij: nullFunc_iiiiiij,\r\n  nullFunc_iiiiiiji: nullFunc_iiiiiiji,\r\n  nullFunc_iiiiijiii: nullFunc_iiiiijiii,\r\n  nullFunc_iiiijii: nullFunc_iiiijii,\r\n  nullFunc_iij: nullFunc_iij,\r\n  nullFunc_iiji: nullFunc_iiji,\r\n  nullFunc_iijii: nullFunc_iijii,\r\n  nullFunc_iijj: nullFunc_iijj,\r\n  nullFunc_iijjjjjj: nullFunc_iijjjjjj,\r\n  nullFunc_iji: nullFunc_iji,\r\n  nullFunc_ji: nullFunc_ji,\r\n  nullFunc_jii: nullFunc_jii,\r\n  nullFunc_jiiiii: nullFunc_jiiiii,\r\n  nullFunc_jiji: nullFunc_jiji,\r\n  nullFunc_jji: nullFunc_jji,\r\n  nullFunc_vi: nullFunc_vi,\r\n  nullFunc_vii: nullFunc_vii,\r\n  nullFunc_viii: nullFunc_viii,\r\n  nullFunc_viiii: nullFunc_viiii,\r\n  nullFunc_viiiii: nullFunc_viiiii,\r\n  nullFunc_viiiiii: nullFunc_viiiiii,\r\n  nullFunc_viiiiiii: nullFunc_viiiiiii,\r\n  nullFunc_viiiiiiii: nullFunc_viiiiiiii,\r\n  nullFunc_viiiiiiiii: nullFunc_viiiiiiiii,\r\n  nullFunc_viiiiiiiiiiiiiiiiiiiiiiiiiiiiiiijiiiiii:\r\n    nullFunc_viiiiiiiiiiiiiiiiiiiiiiiiiiiiiiijiiiiii,\r\n  nullFunc_viiiiiiiiiiiiiijiiiii: nullFunc_viiiiiiiiiiiiiijiiiii,\r\n  nullFunc_viiiiiiiiijiiii: nullFunc_viiiiiiiiijiiii,\r\n  nullFunc_vijii: nullFunc_vijii,\r\n  invoke_ii: invoke_ii,\r\n  invoke_iii: invoke_iii,\r\n  invoke_iiii: invoke_iiii,\r\n  invoke_iiiii: invoke_iiiii,\r\n  invoke_vi: invoke_vi,\r\n  invoke_vii: invoke_vii,\r\n  invoke_viii: invoke_viii,\r\n  invoke_viiii: invoke_viiii,\r\n  ___assert_fail: ___assert_fail,\r\n  ___buildEnvironment: ___buildEnvironment,\r\n  ___clock_gettime: ___clock_gettime,\r\n  ___lock: ___lock,\r\n  ___map_file: ___map_file,\r\n  ___setErrNo: ___setErrNo,\r\n  ___syscall10: ___syscall10,\r\n  ___syscall114: ___syscall114,\r\n  ___syscall140: ___syscall140,\r\n  ___syscall145: ___syscall145,\r\n  ___syscall146: ___syscall146,\r\n  ___syscall180: ___syscall180,\r\n  ___syscall181: ___syscall181,\r\n  ___syscall195: ___syscall195,\r\n  ___syscall197: ___syscall197,\r\n  ___syscall220: ___syscall220,\r\n  ___syscall221: ___syscall221,\r\n  ___syscall3: ___syscall3,\r\n  ___syscall330: ___syscall330,\r\n  ___syscall38: ___syscall38,\r\n  ___syscall40: ___syscall40,\r\n  ___syscall41: ___syscall41,\r\n  ___syscall5: ___syscall5,\r\n  ___syscall54: ___syscall54,\r\n  ___syscall6: ___syscall6,\r\n  ___syscall63: ___syscall63,\r\n  ___syscall91: ___syscall91,\r\n  ___unlock: ___unlock,\r\n  _clock_gettime: _clock_gettime,\r\n  _difftime: _difftime,\r\n  _emscripten_get_heap_size: _emscripten_get_heap_size,\r\n  _emscripten_get_now: _emscripten_get_now,\r\n  _emscripten_get_now_is_monotonic: _emscripten_get_now_is_monotonic,\r\n  _emscripten_longjmp: _emscripten_longjmp,\r\n  _emscripten_memcpy_big: _emscripten_memcpy_big,\r\n  _emscripten_resize_heap: _emscripten_resize_heap,\r\n  _exit: _exit,\r\n  _getenv: _getenv,\r\n  _gettimeofday: _gettimeofday,\r\n  _gmtime: _gmtime,\r\n  _gmtime_r: _gmtime_r,\r\n  _llvm_bswap_i64: _llvm_bswap_i64,\r\n  _localtime: _localtime,\r\n  _localtime_r: _localtime_r,\r\n  _longjmp: _longjmp,\r\n  _mktime: _mktime,\r\n  _pthread_mutex_destroy: _pthread_mutex_destroy,\r\n  _pthread_mutex_init: _pthread_mutex_init,\r\n  _time: _time,\r\n  _times: _times,\r\n  _tzset: _tzset,\r\n  abortOnCannotGrowMemory: abortOnCannotGrowMemory,\r\n  emscripten_realloc_buffer: emscripten_realloc_buffer,\r\n  tempDoublePtr: tempDoublePtr,\r\n  DYNAMICTOP_PTR: DYNAMICTOP_PTR,\r\n};\r\n// EMSCRIPTEN_START_ASM\r\nvar asm = Module[\"asm\"](\r\n  // EMSCRIPTEN_END_ASM\r\n  asmGlobalArg,\r\n  asmLibraryArg,\r\n  buffer,\r\n);\r\n\r\nvar real____emscripten_environ_constructor =\r\n  asm[\"___emscripten_environ_constructor\"];\r\nasm[\"___emscripten_environ_constructor\"] = function () {\r\n  assert(\r\n    runtimeInitialized,\r\n    \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\",\r\n  );\r\n  assert(\r\n    !runtimeExited,\r\n    \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\",\r\n  );\r\n  return real____emscripten_environ_constructor.apply(null, arguments);\r\n};\r\n\r\nvar real____errno_location = asm[\"___errno_location\"];\r\nasm[\"___errno_location\"] = function () {\r\n  assert(\r\n    runtimeInitialized,\r\n    \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\",\r\n  );\r\n  assert(\r\n    !runtimeExited,\r\n    \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\",\r\n  );\r\n  return real____errno_location.apply(null, arguments);\r\n};\r\n\r\nvar real___get_daylight = asm[\"__get_daylight\"];\r\nasm[\"__get_daylight\"] = function () {\r\n  assert(\r\n    runtimeInitialized,\r\n    \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\",\r\n  );\r\n  assert(\r\n    !runtimeExited,\r\n    \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\",\r\n  );\r\n  return real___get_daylight.apply(null, arguments);\r\n};\r\n\r\nvar real___get_environ = asm[\"__get_environ\"];\r\nasm[\"__get_environ\"] = function () {\r\n  assert(\r\n    runtimeInitialized,\r\n    \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\",\r\n  );\r\n  assert(\r\n    !runtimeExited,\r\n    \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\",\r\n  );\r\n  return real___get_environ.apply(null, arguments);\r\n};\r\n\r\nvar real___get_timezone = asm[\"__get_timezone\"];\r\nasm[\"__get_timezone\"] = function () {\r\n  assert(\r\n    runtimeInitialized,\r\n    \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\",\r\n  );\r\n  assert(\r\n    !runtimeExited,\r\n    \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\",\r\n  );\r\n  return real___get_timezone.apply(null, arguments);\r\n};\r\n\r\nvar real___get_tzname = asm[\"__get_tzname\"];\r\nasm[\"__get_tzname\"] = function () {\r\n  assert(\r\n    runtimeInitialized,\r\n    \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\",\r\n  );\r\n  assert(\r\n    !runtimeExited,\r\n    \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\",\r\n  );\r\n  return real___get_tzname.apply(null, arguments);\r\n};\r\n\r\nvar real__fflush = asm[\"_fflush\"];\r\nasm[\"_fflush\"] = function () {\r\n  assert(\r\n    runtimeInitialized,\r\n    \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\",\r\n  );\r\n  assert(\r\n    !runtimeExited,\r\n    \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\",\r\n  );\r\n  return real__fflush.apply(null, arguments);\r\n};\r\n\r\nvar real__free = asm[\"_free\"];\r\nasm[\"_free\"] = function () {\r\n  assert(\r\n    runtimeInitialized,\r\n    \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\",\r\n  );\r\n  assert(\r\n    !runtimeExited,\r\n    \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\",\r\n  );\r\n  return real__free.apply(null, arguments);\r\n};\r\n\r\nvar real__llvm_bswap_i16 = asm[\"_llvm_bswap_i16\"];\r\nasm[\"_llvm_bswap_i16\"] = function () {\r\n  assert(\r\n    runtimeInitialized,\r\n    \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\",\r\n  );\r\n  assert(\r\n    !runtimeExited,\r\n    \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\",\r\n  );\r\n  return real__llvm_bswap_i16.apply(null, arguments);\r\n};\r\n\r\nvar real__llvm_bswap_i32 = asm[\"_llvm_bswap_i32\"];\r\nasm[\"_llvm_bswap_i32\"] = function () {\r\n  assert(\r\n    runtimeInitialized,\r\n    \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\",\r\n  );\r\n  assert(\r\n    !runtimeExited,\r\n    \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\",\r\n  );\r\n  return real__llvm_bswap_i32.apply(null, arguments);\r\n};\r\n\r\nvar real__main = asm[\"_main\"];\r\nasm[\"_main\"] = function () {\r\n  assert(\r\n    runtimeInitialized,\r\n    \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\",\r\n  );\r\n  assert(\r\n    !runtimeExited,\r\n    \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\",\r\n  );\r\n  return real__main.apply(null, arguments);\r\n};\r\n\r\nvar real__malloc = asm[\"_malloc\"];\r\nasm[\"_malloc\"] = function () {\r\n  assert(\r\n    runtimeInitialized,\r\n    \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\",\r\n  );\r\n  assert(\r\n    !runtimeExited,\r\n    \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\",\r\n  );\r\n  return real__malloc.apply(null, arguments);\r\n};\r\n\r\nvar real__memmove = asm[\"_memmove\"];\r\nasm[\"_memmove\"] = function () {\r\n  assert(\r\n    runtimeInitialized,\r\n    \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\",\r\n  );\r\n  assert(\r\n    !runtimeExited,\r\n    \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\",\r\n  );\r\n  return real__memmove.apply(null, arguments);\r\n};\r\n\r\nvar real__pthread_mutex_lock = asm[\"_pthread_mutex_lock\"];\r\nasm[\"_pthread_mutex_lock\"] = function () {\r\n  assert(\r\n    runtimeInitialized,\r\n    \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\",\r\n  );\r\n  assert(\r\n    !runtimeExited,\r\n    \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\",\r\n  );\r\n  return real__pthread_mutex_lock.apply(null, arguments);\r\n};\r\n\r\nvar real__pthread_mutex_unlock = asm[\"_pthread_mutex_unlock\"];\r\nasm[\"_pthread_mutex_unlock\"] = function () {\r\n  assert(\r\n    runtimeInitialized,\r\n    \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\",\r\n  );\r\n  assert(\r\n    !runtimeExited,\r\n    \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\",\r\n  );\r\n  return real__pthread_mutex_unlock.apply(null, arguments);\r\n};\r\n\r\nvar real__realloc = asm[\"_realloc\"];\r\nasm[\"_realloc\"] = function () {\r\n  assert(\r\n    runtimeInitialized,\r\n    \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\",\r\n  );\r\n  assert(\r\n    !runtimeExited,\r\n    \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\",\r\n  );\r\n  return real__realloc.apply(null, arguments);\r\n};\r\n\r\nvar real__rintf = asm[\"_rintf\"];\r\nasm[\"_rintf\"] = function () {\r\n  assert(\r\n    runtimeInitialized,\r\n    \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\",\r\n  );\r\n  assert(\r\n    !runtimeExited,\r\n    \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\",\r\n  );\r\n  return real__rintf.apply(null, arguments);\r\n};\r\n\r\nvar real__saveSetjmp = asm[\"_saveSetjmp\"];\r\nasm[\"_saveSetjmp\"] = function () {\r\n  assert(\r\n    runtimeInitialized,\r\n    \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\",\r\n  );\r\n  assert(\r\n    !runtimeExited,\r\n    \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\",\r\n  );\r\n  return real__saveSetjmp.apply(null, arguments);\r\n};\r\n\r\nvar real__sbrk = asm[\"_sbrk\"];\r\nasm[\"_sbrk\"] = function () {\r\n  assert(\r\n    runtimeInitialized,\r\n    \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\",\r\n  );\r\n  assert(\r\n    !runtimeExited,\r\n    \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\",\r\n  );\r\n  return real__sbrk.apply(null, arguments);\r\n};\r\n\r\nvar real__setThrew = asm[\"_setThrew\"];\r\nasm[\"_setThrew\"] = function () {\r\n  assert(\r\n    runtimeInitialized,\r\n    \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\",\r\n  );\r\n  assert(\r\n    !runtimeExited,\r\n    \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\",\r\n  );\r\n  return real__setThrew.apply(null, arguments);\r\n};\r\n\r\nvar real__testSetjmp = asm[\"_testSetjmp\"];\r\nasm[\"_testSetjmp\"] = function () {\r\n  assert(\r\n    runtimeInitialized,\r\n    \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\",\r\n  );\r\n  assert(\r\n    !runtimeExited,\r\n    \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\",\r\n  );\r\n  return real__testSetjmp.apply(null, arguments);\r\n};\r\n\r\nvar real_establishStackSpace = asm[\"establishStackSpace\"];\r\nasm[\"establishStackSpace\"] = function () {\r\n  assert(\r\n    runtimeInitialized,\r\n    \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\",\r\n  );\r\n  assert(\r\n    !runtimeExited,\r\n    \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\",\r\n  );\r\n  return real_establishStackSpace.apply(null, arguments);\r\n};\r\n\r\nvar real_stackAlloc = asm[\"stackAlloc\"];\r\nasm[\"stackAlloc\"] = function () {\r\n  assert(\r\n    runtimeInitialized,\r\n    \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\",\r\n  );\r\n  assert(\r\n    !runtimeExited,\r\n    \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\",\r\n  );\r\n  return real_stackAlloc.apply(null, arguments);\r\n};\r\n\r\nvar real_stackRestore = asm[\"stackRestore\"];\r\nasm[\"stackRestore\"] = function () {\r\n  assert(\r\n    runtimeInitialized,\r\n    \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\",\r\n  );\r\n  assert(\r\n    !runtimeExited,\r\n    \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\",\r\n  );\r\n  return real_stackRestore.apply(null, arguments);\r\n};\r\n\r\nvar real_stackSave = asm[\"stackSave\"];\r\nasm[\"stackSave\"] = function () {\r\n  assert(\r\n    runtimeInitialized,\r\n    \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\",\r\n  );\r\n  assert(\r\n    !runtimeExited,\r\n    \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\",\r\n  );\r\n  return real_stackSave.apply(null, arguments);\r\n};\r\nModule[\"asm\"] = asm;\r\nvar ___emscripten_environ_constructor = (Module[\r\n  \"___emscripten_environ_constructor\"\r\n] = function () {\r\n  assert(\r\n    runtimeInitialized,\r\n    \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\",\r\n  );\r\n  assert(\r\n    !runtimeExited,\r\n    \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\",\r\n  );\r\n  return Module[\"asm\"][\"___emscripten_environ_constructor\"].apply(\r\n    null,\r\n    arguments,\r\n  );\r\n});\r\nvar ___errno_location = (Module[\"___errno_location\"] = function () {\r\n  assert(\r\n    runtimeInitialized,\r\n    \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\",\r\n  );\r\n  assert(\r\n    !runtimeExited,\r\n    \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\",\r\n  );\r\n  return Module[\"asm\"][\"___errno_location\"].apply(null, arguments);\r\n});\r\nvar __get_daylight = (Module[\"__get_daylight\"] = function () {\r\n  assert(\r\n    runtimeInitialized,\r\n    \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\",\r\n  );\r\n  assert(\r\n    !runtimeExited,\r\n    \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\",\r\n  );\r\n  return Module[\"asm\"][\"__get_daylight\"].apply(null, arguments);\r\n});\r\nvar __get_environ = (Module[\"__get_environ\"] = function () {\r\n  assert(\r\n    runtimeInitialized,\r\n    \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\",\r\n  );\r\n  assert(\r\n    !runtimeExited,\r\n    \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\",\r\n  );\r\n  return Module[\"asm\"][\"__get_environ\"].apply(null, arguments);\r\n});\r\nvar __get_timezone = (Module[\"__get_timezone\"] = function () {\r\n  assert(\r\n    runtimeInitialized,\r\n    \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\",\r\n  );\r\n  assert(\r\n    !runtimeExited,\r\n    \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\",\r\n  );\r\n  return Module[\"asm\"][\"__get_timezone\"].apply(null, arguments);\r\n});\r\nvar __get_tzname = (Module[\"__get_tzname\"] = function () {\r\n  assert(\r\n    runtimeInitialized,\r\n    \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\",\r\n  );\r\n  assert(\r\n    !runtimeExited,\r\n    \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\",\r\n  );\r\n  return Module[\"asm\"][\"__get_tzname\"].apply(null, arguments);\r\n});\r\nvar _emscripten_replace_memory = (Module[\"_emscripten_replace_memory\"] =\r\n  function () {\r\n    assert(\r\n      runtimeInitialized,\r\n      \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\",\r\n    );\r\n    assert(\r\n      !runtimeExited,\r\n      \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\",\r\n    );\r\n    return Module[\"asm\"][\"_emscripten_replace_memory\"].apply(null, arguments);\r\n  });\r\nvar _fflush = (Module[\"_fflush\"] = function () {\r\n  assert(\r\n    runtimeInitialized,\r\n    \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\",\r\n  );\r\n  assert(\r\n    !runtimeExited,\r\n    \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\",\r\n  );\r\n  return Module[\"asm\"][\"_fflush\"].apply(null, arguments);\r\n});\r\nvar _free = (Module[\"_free\"] = function () {\r\n  assert(\r\n    runtimeInitialized,\r\n    \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\",\r\n  );\r\n  assert(\r\n    !runtimeExited,\r\n    \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\",\r\n  );\r\n  return Module[\"asm\"][\"_free\"].apply(null, arguments);\r\n});\r\nvar _llvm_bswap_i16 = (Module[\"_llvm_bswap_i16\"] = function () {\r\n  assert(\r\n    runtimeInitialized,\r\n    \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\",\r\n  );\r\n  assert(\r\n    !runtimeExited,\r\n    \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\",\r\n  );\r\n  return Module[\"asm\"][\"_llvm_bswap_i16\"].apply(null, arguments);\r\n});\r\nvar _llvm_bswap_i32 = (Module[\"_llvm_bswap_i32\"] = function () {\r\n  assert(\r\n    runtimeInitialized,\r\n    \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\",\r\n  );\r\n  assert(\r\n    !runtimeExited,\r\n    \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\",\r\n  );\r\n  return Module[\"asm\"][\"_llvm_bswap_i32\"].apply(null, arguments);\r\n});\r\nvar _main = (Module[\"_main\"] = function () {\r\n  assert(\r\n    runtimeInitialized,\r\n    \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\",\r\n  );\r\n  assert(\r\n    !runtimeExited,\r\n    \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\",\r\n  );\r\n  return Module[\"asm\"][\"_main\"].apply(null, arguments);\r\n});\r\nvar _malloc = (Module[\"_malloc\"] = function () {\r\n  assert(\r\n    runtimeInitialized,\r\n    \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\",\r\n  );\r\n  assert(\r\n    !runtimeExited,\r\n    \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\",\r\n  );\r\n  return Module[\"asm\"][\"_malloc\"].apply(null, arguments);\r\n});\r\nvar _memcpy = (Module[\"_memcpy\"] = function () {\r\n  assert(\r\n    runtimeInitialized,\r\n    \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\",\r\n  );\r\n  assert(\r\n    !runtimeExited,\r\n    \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\",\r\n  );\r\n  return Module[\"asm\"][\"_memcpy\"].apply(null, arguments);\r\n});\r\nvar _memmove = (Module[\"_memmove\"] = function () {\r\n  assert(\r\n    runtimeInitialized,\r\n    \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\",\r\n  );\r\n  assert(\r\n    !runtimeExited,\r\n    \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\",\r\n  );\r\n  return Module[\"asm\"][\"_memmove\"].apply(null, arguments);\r\n});\r\nvar _memset = (Module[\"_memset\"] = function () {\r\n  assert(\r\n    runtimeInitialized,\r\n    \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\",\r\n  );\r\n  assert(\r\n    !runtimeExited,\r\n    \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\",\r\n  );\r\n  return Module[\"asm\"][\"_memset\"].apply(null, arguments);\r\n});\r\nvar _pthread_mutex_lock = (Module[\"_pthread_mutex_lock\"] = function () {\r\n  assert(\r\n    runtimeInitialized,\r\n    \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\",\r\n  );\r\n  assert(\r\n    !runtimeExited,\r\n    \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\",\r\n  );\r\n  return Module[\"asm\"][\"_pthread_mutex_lock\"].apply(null, arguments);\r\n});\r\nvar _pthread_mutex_unlock = (Module[\"_pthread_mutex_unlock\"] = function () {\r\n  assert(\r\n    runtimeInitialized,\r\n    \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\",\r\n  );\r\n  assert(\r\n    !runtimeExited,\r\n    \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\",\r\n  );\r\n  return Module[\"asm\"][\"_pthread_mutex_unlock\"].apply(null, arguments);\r\n});\r\nvar _realloc = (Module[\"_realloc\"] = function () {\r\n  assert(\r\n    runtimeInitialized,\r\n    \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\",\r\n  );\r\n  assert(\r\n    !runtimeExited,\r\n    \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\",\r\n  );\r\n  return Module[\"asm\"][\"_realloc\"].apply(null, arguments);\r\n});\r\nvar _rintf = (Module[\"_rintf\"] = function () {\r\n  assert(\r\n    runtimeInitialized,\r\n    \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\",\r\n  );\r\n  assert(\r\n    !runtimeExited,\r\n    \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\",\r\n  );\r\n  return Module[\"asm\"][\"_rintf\"].apply(null, arguments);\r\n});\r\nvar _saveSetjmp = (Module[\"_saveSetjmp\"] = function () {\r\n  assert(\r\n    runtimeInitialized,\r\n    \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\",\r\n  );\r\n  assert(\r\n    !runtimeExited,\r\n    \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\",\r\n  );\r\n  return Module[\"asm\"][\"_saveSetjmp\"].apply(null, arguments);\r\n});\r\nvar _sbrk = (Module[\"_sbrk\"] = function () {\r\n  assert(\r\n    runtimeInitialized,\r\n    \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\",\r\n  );\r\n  assert(\r\n    !runtimeExited,\r\n    \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\",\r\n  );\r\n  return Module[\"asm\"][\"_sbrk\"].apply(null, arguments);\r\n});\r\nvar _setThrew = (Module[\"_setThrew\"] = function () {\r\n  assert(\r\n    runtimeInitialized,\r\n    \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\",\r\n  );\r\n  assert(\r\n    !runtimeExited,\r\n    \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\",\r\n  );\r\n  return Module[\"asm\"][\"_setThrew\"].apply(null, arguments);\r\n});\r\nvar _testSetjmp = (Module[\"_testSetjmp\"] = function () {\r\n  assert(\r\n    runtimeInitialized,\r\n    \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\",\r\n  );\r\n  assert(\r\n    !runtimeExited,\r\n    \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\",\r\n  );\r\n  return Module[\"asm\"][\"_testSetjmp\"].apply(null, arguments);\r\n});\r\nvar establishStackSpace = (Module[\"establishStackSpace\"] = function () {\r\n  assert(\r\n    runtimeInitialized,\r\n    \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\",\r\n  );\r\n  assert(\r\n    !runtimeExited,\r\n    \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\",\r\n  );\r\n  return Module[\"asm\"][\"establishStackSpace\"].apply(null, arguments);\r\n});\r\nvar stackAlloc = (Module[\"stackAlloc\"] = function () {\r\n  assert(\r\n    runtimeInitialized,\r\n    \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\",\r\n  );\r\n  assert(\r\n    !runtimeExited,\r\n    \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\",\r\n  );\r\n  return Module[\"asm\"][\"stackAlloc\"].apply(null, arguments);\r\n});\r\nvar stackRestore = (Module[\"stackRestore\"] = function () {\r\n  assert(\r\n    runtimeInitialized,\r\n    \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\",\r\n  );\r\n  assert(\r\n    !runtimeExited,\r\n    \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\",\r\n  );\r\n  return Module[\"asm\"][\"stackRestore\"].apply(null, arguments);\r\n});\r\nvar stackSave = (Module[\"stackSave\"] = function () {\r\n  assert(\r\n    runtimeInitialized,\r\n    \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\",\r\n  );\r\n  assert(\r\n    !runtimeExited,\r\n    \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\",\r\n  );\r\n  return Module[\"asm\"][\"stackSave\"].apply(null, arguments);\r\n});\r\nvar dynCall_dd = (Module[\"dynCall_dd\"] = function () {\r\n  assert(\r\n    runtimeInitialized,\r\n    \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\",\r\n  );\r\n  assert(\r\n    !runtimeExited,\r\n    \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\",\r\n  );\r\n  return Module[\"asm\"][\"dynCall_dd\"].apply(null, arguments);\r\n});\r\nvar dynCall_ddd = (Module[\"dynCall_ddd\"] = function () {\r\n  assert(\r\n    runtimeInitialized,\r\n    \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\",\r\n  );\r\n  assert(\r\n    !runtimeExited,\r\n    \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\",\r\n  );\r\n  return Module[\"asm\"][\"dynCall_ddd\"].apply(null, arguments);\r\n});\r\nvar dynCall_diiid = (Module[\"dynCall_diiid\"] = function () {\r\n  assert(\r\n    runtimeInitialized,\r\n    \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\",\r\n  );\r\n  assert(\r\n    !runtimeExited,\r\n    \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\",\r\n  );\r\n  return Module[\"asm\"][\"dynCall_diiid\"].apply(null, arguments);\r\n});\r\nvar dynCall_fdd = (Module[\"dynCall_fdd\"] = function () {\r\n  assert(\r\n    runtimeInitialized,\r\n    \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\",\r\n  );\r\n  assert(\r\n    !runtimeExited,\r\n    \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\",\r\n  );\r\n  return Module[\"asm\"][\"dynCall_fdd\"].apply(null, arguments);\r\n});\r\nvar dynCall_fdi = (Module[\"dynCall_fdi\"] = function () {\r\n  assert(\r\n    runtimeInitialized,\r\n    \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\",\r\n  );\r\n  assert(\r\n    !runtimeExited,\r\n    \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\",\r\n  );\r\n  return Module[\"asm\"][\"dynCall_fdi\"].apply(null, arguments);\r\n});\r\nvar dynCall_fdii = (Module[\"dynCall_fdii\"] = function () {\r\n  assert(\r\n    runtimeInitialized,\r\n    \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\",\r\n  );\r\n  assert(\r\n    !runtimeExited,\r\n    \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\",\r\n  );\r\n  return Module[\"asm\"][\"dynCall_fdii\"].apply(null, arguments);\r\n});\r\nvar dynCall_fiii = (Module[\"dynCall_fiii\"] = function () {\r\n  assert(\r\n    runtimeInitialized,\r\n    \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\",\r\n  );\r\n  assert(\r\n    !runtimeExited,\r\n    \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\",\r\n  );\r\n  return Module[\"asm\"][\"dynCall_fiii\"].apply(null, arguments);\r\n});\r\nvar dynCall_i = (Module[\"dynCall_i\"] = function () {\r\n  assert(\r\n    runtimeInitialized,\r\n    \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\",\r\n  );\r\n  assert(\r\n    !runtimeExited,\r\n    \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\",\r\n  );\r\n  return Module[\"asm\"][\"dynCall_i\"].apply(null, arguments);\r\n});\r\nvar dynCall_id = (Module[\"dynCall_id\"] = function () {\r\n  assert(\r\n    runtimeInitialized,\r\n    \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\",\r\n  );\r\n  assert(\r\n    !runtimeExited,\r\n    \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\",\r\n  );\r\n  return Module[\"asm\"][\"dynCall_id\"].apply(null, arguments);\r\n});\r\nvar dynCall_idii = (Module[\"dynCall_idii\"] = function () {\r\n  assert(\r\n    runtimeInitialized,\r\n    \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\",\r\n  );\r\n  assert(\r\n    !runtimeExited,\r\n    \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\",\r\n  );\r\n  return Module[\"asm\"][\"dynCall_idii\"].apply(null, arguments);\r\n});\r\nvar dynCall_ii = (Module[\"dynCall_ii\"] = function () {\r\n  assert(\r\n    runtimeInitialized,\r\n    \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\",\r\n  );\r\n  assert(\r\n    !runtimeExited,\r\n    \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\",\r\n  );\r\n  return Module[\"asm\"][\"dynCall_ii\"].apply(null, arguments);\r\n});\r\nvar dynCall_iid = (Module[\"dynCall_iid\"] = function () {\r\n  assert(\r\n    runtimeInitialized,\r\n    \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\",\r\n  );\r\n  assert(\r\n    !runtimeExited,\r\n    \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\",\r\n  );\r\n  return Module[\"asm\"][\"dynCall_iid\"].apply(null, arguments);\r\n});\r\nvar dynCall_iiddddddddi = (Module[\"dynCall_iiddddddddi\"] = function () {\r\n  assert(\r\n    runtimeInitialized,\r\n    \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\",\r\n  );\r\n  assert(\r\n    !runtimeExited,\r\n    \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\",\r\n  );\r\n  return Module[\"asm\"][\"dynCall_iiddddddddi\"].apply(null, arguments);\r\n});\r\nvar dynCall_iiddddi = (Module[\"dynCall_iiddddi\"] = function () {\r\n  assert(\r\n    runtimeInitialized,\r\n    \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\",\r\n  );\r\n  assert(\r\n    !runtimeExited,\r\n    \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\",\r\n  );\r\n  return Module[\"asm\"][\"dynCall_iiddddi\"].apply(null, arguments);\r\n});\r\nvar dynCall_iidi = (Module[\"dynCall_iidi\"] = function () {\r\n  assert(\r\n    runtimeInitialized,\r\n    \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\",\r\n  );\r\n  assert(\r\n    !runtimeExited,\r\n    \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\",\r\n  );\r\n  return Module[\"asm\"][\"dynCall_iidi\"].apply(null, arguments);\r\n});\r\nvar dynCall_iidiii = (Module[\"dynCall_iidiii\"] = function () {\r\n  assert(\r\n    runtimeInitialized,\r\n    \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\",\r\n  );\r\n  assert(\r\n    !runtimeExited,\r\n    \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\",\r\n  );\r\n  return Module[\"asm\"][\"dynCall_iidiii\"].apply(null, arguments);\r\n});\r\nvar dynCall_iii = (Module[\"dynCall_iii\"] = function () {\r\n  assert(\r\n    runtimeInitialized,\r\n    \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\",\r\n  );\r\n  assert(\r\n    !runtimeExited,\r\n    \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\",\r\n  );\r\n  return Module[\"asm\"][\"dynCall_iii\"].apply(null, arguments);\r\n});\r\nvar dynCall_iiii = (Module[\"dynCall_iiii\"] = function () {\r\n  assert(\r\n    runtimeInitialized,\r\n    \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\",\r\n  );\r\n  assert(\r\n    !runtimeExited,\r\n    \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\",\r\n  );\r\n  return Module[\"asm\"][\"dynCall_iiii\"].apply(null, arguments);\r\n});\r\nvar dynCall_iiiid = (Module[\"dynCall_iiiid\"] = function () {\r\n  assert(\r\n    runtimeInitialized,\r\n    \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\",\r\n  );\r\n  assert(\r\n    !runtimeExited,\r\n    \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\",\r\n  );\r\n  return Module[\"asm\"][\"dynCall_iiiid\"].apply(null, arguments);\r\n});\r\nvar dynCall_iiiii = (Module[\"dynCall_iiiii\"] = function () {\r\n  assert(\r\n    runtimeInitialized,\r\n    \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\",\r\n  );\r\n  assert(\r\n    !runtimeExited,\r\n    \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\",\r\n  );\r\n  return Module[\"asm\"][\"dynCall_iiiii\"].apply(null, arguments);\r\n});\r\nvar dynCall_iiiiii = (Module[\"dynCall_iiiiii\"] = function () {\r\n  assert(\r\n    runtimeInitialized,\r\n    \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\",\r\n  );\r\n  assert(\r\n    !runtimeExited,\r\n    \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\",\r\n  );\r\n  return Module[\"asm\"][\"dynCall_iiiiii\"].apply(null, arguments);\r\n});\r\nvar dynCall_iiiiiii = (Module[\"dynCall_iiiiiii\"] = function () {\r\n  assert(\r\n    runtimeInitialized,\r\n    \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\",\r\n  );\r\n  assert(\r\n    !runtimeExited,\r\n    \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\",\r\n  );\r\n  return Module[\"asm\"][\"dynCall_iiiiiii\"].apply(null, arguments);\r\n});\r\nvar dynCall_iiiiiiii = (Module[\"dynCall_iiiiiiii\"] = function () {\r\n  assert(\r\n    runtimeInitialized,\r\n    \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\",\r\n  );\r\n  assert(\r\n    !runtimeExited,\r\n    \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\",\r\n  );\r\n  return Module[\"asm\"][\"dynCall_iiiiiiii\"].apply(null, arguments);\r\n});\r\nvar dynCall_iiiiiiiifi = (Module[\"dynCall_iiiiiiiifi\"] = function () {\r\n  assert(\r\n    runtimeInitialized,\r\n    \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\",\r\n  );\r\n  assert(\r\n    !runtimeExited,\r\n    \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\",\r\n  );\r\n  return Module[\"asm\"][\"dynCall_iiiiiiiifi\"].apply(null, arguments);\r\n});\r\nvar dynCall_iiiiiiiii = (Module[\"dynCall_iiiiiiiii\"] = function () {\r\n  assert(\r\n    runtimeInitialized,\r\n    \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\",\r\n  );\r\n  assert(\r\n    !runtimeExited,\r\n    \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\",\r\n  );\r\n  return Module[\"asm\"][\"dynCall_iiiiiiiii\"].apply(null, arguments);\r\n});\r\nvar dynCall_iiiiiiiiii = (Module[\"dynCall_iiiiiiiiii\"] = function () {\r\n  assert(\r\n    runtimeInitialized,\r\n    \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\",\r\n  );\r\n  assert(\r\n    !runtimeExited,\r\n    \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\",\r\n  );\r\n  return Module[\"asm\"][\"dynCall_iiiiiiiiii\"].apply(null, arguments);\r\n});\r\nvar dynCall_iiiiiiiiiii = (Module[\"dynCall_iiiiiiiiiii\"] = function () {\r\n  assert(\r\n    runtimeInitialized,\r\n    \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\",\r\n  );\r\n  assert(\r\n    !runtimeExited,\r\n    \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\",\r\n  );\r\n  return Module[\"asm\"][\"dynCall_iiiiiiiiiii\"].apply(null, arguments);\r\n});\r\nvar dynCall_iiiiiiiiiiii = (Module[\"dynCall_iiiiiiiiiiii\"] = function () {\r\n  assert(\r\n    runtimeInitialized,\r\n    \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\",\r\n  );\r\n  assert(\r\n    !runtimeExited,\r\n    \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\",\r\n  );\r\n  return Module[\"asm\"][\"dynCall_iiiiiiiiiiii\"].apply(null, arguments);\r\n});\r\nvar dynCall_iiiiiiiiiiiii = (Module[\"dynCall_iiiiiiiiiiiii\"] = function () {\r\n  assert(\r\n    runtimeInitialized,\r\n    \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\",\r\n  );\r\n  assert(\r\n    !runtimeExited,\r\n    \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\",\r\n  );\r\n  return Module[\"asm\"][\"dynCall_iiiiiiiiiiiii\"].apply(null, arguments);\r\n});\r\nvar dynCall_iiiiiiiiiiiiii = (Module[\"dynCall_iiiiiiiiiiiiii\"] = function () {\r\n  assert(\r\n    runtimeInitialized,\r\n    \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\",\r\n  );\r\n  assert(\r\n    !runtimeExited,\r\n    \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\",\r\n  );\r\n  return Module[\"asm\"][\"dynCall_iiiiiiiiiiiiii\"].apply(null, arguments);\r\n});\r\nvar dynCall_iiiiiiiiiiiiiii = (Module[\"dynCall_iiiiiiiiiiiiiii\"] = function () {\r\n  assert(\r\n    runtimeInitialized,\r\n    \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\",\r\n  );\r\n  assert(\r\n    !runtimeExited,\r\n    \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\",\r\n  );\r\n  return Module[\"asm\"][\"dynCall_iiiiiiiiiiiiiii\"].apply(null, arguments);\r\n});\r\nvar dynCall_iiiiiiiiiiiiiiii = (Module[\"dynCall_iiiiiiiiiiiiiiii\"] =\r\n  function () {\r\n    assert(\r\n      runtimeInitialized,\r\n      \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\",\r\n    );\r\n    assert(\r\n      !runtimeExited,\r\n      \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\",\r\n    );\r\n    return Module[\"asm\"][\"dynCall_iiiiiiiiiiiiiiii\"].apply(null, arguments);\r\n  });\r\nvar dynCall_iiiiiiiiiiiiiiiii = (Module[\"dynCall_iiiiiiiiiiiiiiiii\"] =\r\n  function () {\r\n    assert(\r\n      runtimeInitialized,\r\n      \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\",\r\n    );\r\n    assert(\r\n      !runtimeExited,\r\n      \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\",\r\n    );\r\n    return Module[\"asm\"][\"dynCall_iiiiiiiiiiiiiiiii\"].apply(null, arguments);\r\n  });\r\nvar dynCall_iiiiiiiiiiji = (Module[\"dynCall_iiiiiiiiiiji\"] = function () {\r\n  assert(\r\n    runtimeInitialized,\r\n    \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\",\r\n  );\r\n  assert(\r\n    !runtimeExited,\r\n    \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\",\r\n  );\r\n  return Module[\"asm\"][\"dynCall_iiiiiiiiiiji\"].apply(null, arguments);\r\n});\r\nvar dynCall_iiiiiiiiiijj = (Module[\"dynCall_iiiiiiiiiijj\"] = function () {\r\n  assert(\r\n    runtimeInitialized,\r\n    \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\",\r\n  );\r\n  assert(\r\n    !runtimeExited,\r\n    \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\",\r\n  );\r\n  return Module[\"asm\"][\"dynCall_iiiiiiiiiijj\"].apply(null, arguments);\r\n});\r\nvar dynCall_iiiiiiijjii = (Module[\"dynCall_iiiiiiijjii\"] = function () {\r\n  assert(\r\n    runtimeInitialized,\r\n    \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\",\r\n  );\r\n  assert(\r\n    !runtimeExited,\r\n    \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\",\r\n  );\r\n  return Module[\"asm\"][\"dynCall_iiiiiiijjii\"].apply(null, arguments);\r\n});\r\nvar dynCall_iiiiiij = (Module[\"dynCall_iiiiiij\"] = function () {\r\n  assert(\r\n    runtimeInitialized,\r\n    \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\",\r\n  );\r\n  assert(\r\n    !runtimeExited,\r\n    \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\",\r\n  );\r\n  return Module[\"asm\"][\"dynCall_iiiiiij\"].apply(null, arguments);\r\n});\r\nvar dynCall_iiiiiiji = (Module[\"dynCall_iiiiiiji\"] = function () {\r\n  assert(\r\n    runtimeInitialized,\r\n    \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\",\r\n  );\r\n  assert(\r\n    !runtimeExited,\r\n    \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\",\r\n  );\r\n  return Module[\"asm\"][\"dynCall_iiiiiiji\"].apply(null, arguments);\r\n});\r\nvar dynCall_iiiiijiii = (Module[\"dynCall_iiiiijiii\"] = function () {\r\n  assert(\r\n    runtimeInitialized,\r\n    \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\",\r\n  );\r\n  assert(\r\n    !runtimeExited,\r\n    \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\",\r\n  );\r\n  return Module[\"asm\"][\"dynCall_iiiiijiii\"].apply(null, arguments);\r\n});\r\nvar dynCall_iiiijii = (Module[\"dynCall_iiiijii\"] = function () {\r\n  assert(\r\n    runtimeInitialized,\r\n    \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\",\r\n  );\r\n  assert(\r\n    !runtimeExited,\r\n    \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\",\r\n  );\r\n  return Module[\"asm\"][\"dynCall_iiiijii\"].apply(null, arguments);\r\n});\r\nvar dynCall_iij = (Module[\"dynCall_iij\"] = function () {\r\n  assert(\r\n    runtimeInitialized,\r\n    \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\",\r\n  );\r\n  assert(\r\n    !runtimeExited,\r\n    \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\",\r\n  );\r\n  return Module[\"asm\"][\"dynCall_iij\"].apply(null, arguments);\r\n});\r\nvar dynCall_iiji = (Module[\"dynCall_iiji\"] = function () {\r\n  assert(\r\n    runtimeInitialized,\r\n    \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\",\r\n  );\r\n  assert(\r\n    !runtimeExited,\r\n    \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\",\r\n  );\r\n  return Module[\"asm\"][\"dynCall_iiji\"].apply(null, arguments);\r\n});\r\nvar dynCall_iijii = (Module[\"dynCall_iijii\"] = function () {\r\n  assert(\r\n    runtimeInitialized,\r\n    \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\",\r\n  );\r\n  assert(\r\n    !runtimeExited,\r\n    \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\",\r\n  );\r\n  return Module[\"asm\"][\"dynCall_iijii\"].apply(null, arguments);\r\n});\r\nvar dynCall_iijj = (Module[\"dynCall_iijj\"] = function () {\r\n  assert(\r\n    runtimeInitialized,\r\n    \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\",\r\n  );\r\n  assert(\r\n    !runtimeExited,\r\n    \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\",\r\n  );\r\n  return Module[\"asm\"][\"dynCall_iijj\"].apply(null, arguments);\r\n});\r\nvar dynCall_iijjjjjj = (Module[\"dynCall_iijjjjjj\"] = function () {\r\n  assert(\r\n    runtimeInitialized,\r\n    \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\",\r\n  );\r\n  assert(\r\n    !runtimeExited,\r\n    \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\",\r\n  );\r\n  return Module[\"asm\"][\"dynCall_iijjjjjj\"].apply(null, arguments);\r\n});\r\nvar dynCall_iji = (Module[\"dynCall_iji\"] = function () {\r\n  assert(\r\n    runtimeInitialized,\r\n    \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\",\r\n  );\r\n  assert(\r\n    !runtimeExited,\r\n    \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\",\r\n  );\r\n  return Module[\"asm\"][\"dynCall_iji\"].apply(null, arguments);\r\n});\r\nvar dynCall_ji = (Module[\"dynCall_ji\"] = function () {\r\n  assert(\r\n    runtimeInitialized,\r\n    \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\",\r\n  );\r\n  assert(\r\n    !runtimeExited,\r\n    \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\",\r\n  );\r\n  return Module[\"asm\"][\"dynCall_ji\"].apply(null, arguments);\r\n});\r\nvar dynCall_jii = (Module[\"dynCall_jii\"] = function () {\r\n  assert(\r\n    runtimeInitialized,\r\n    \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\",\r\n  );\r\n  assert(\r\n    !runtimeExited,\r\n    \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\",\r\n  );\r\n  return Module[\"asm\"][\"dynCall_jii\"].apply(null, arguments);\r\n});\r\nvar dynCall_jiiiii = (Module[\"dynCall_jiiiii\"] = function () {\r\n  assert(\r\n    runtimeInitialized,\r\n    \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\",\r\n  );\r\n  assert(\r\n    !runtimeExited,\r\n    \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\",\r\n  );\r\n  return Module[\"asm\"][\"dynCall_jiiiii\"].apply(null, arguments);\r\n});\r\nvar dynCall_jiji = (Module[\"dynCall_jiji\"] = function () {\r\n  assert(\r\n    runtimeInitialized,\r\n    \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\",\r\n  );\r\n  assert(\r\n    !runtimeExited,\r\n    \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\",\r\n  );\r\n  return Module[\"asm\"][\"dynCall_jiji\"].apply(null, arguments);\r\n});\r\nvar dynCall_jji = (Module[\"dynCall_jji\"] = function () {\r\n  assert(\r\n    runtimeInitialized,\r\n    \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\",\r\n  );\r\n  assert(\r\n    !runtimeExited,\r\n    \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\",\r\n  );\r\n  return Module[\"asm\"][\"dynCall_jji\"].apply(null, arguments);\r\n});\r\nvar dynCall_vi = (Module[\"dynCall_vi\"] = function () {\r\n  assert(\r\n    runtimeInitialized,\r\n    \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\",\r\n  );\r\n  assert(\r\n    !runtimeExited,\r\n    \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\",\r\n  );\r\n  return Module[\"asm\"][\"dynCall_vi\"].apply(null, arguments);\r\n});\r\nvar dynCall_vii = (Module[\"dynCall_vii\"] = function () {\r\n  assert(\r\n    runtimeInitialized,\r\n    \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\",\r\n  );\r\n  assert(\r\n    !runtimeExited,\r\n    \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\",\r\n  );\r\n  return Module[\"asm\"][\"dynCall_vii\"].apply(null, arguments);\r\n});\r\nvar dynCall_viii = (Module[\"dynCall_viii\"] = function () {\r\n  assert(\r\n    runtimeInitialized,\r\n    \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\",\r\n  );\r\n  assert(\r\n    !runtimeExited,\r\n    \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\",\r\n  );\r\n  return Module[\"asm\"][\"dynCall_viii\"].apply(null, arguments);\r\n});\r\nvar dynCall_viiii = (Module[\"dynCall_viiii\"] = function () {\r\n  assert(\r\n    runtimeInitialized,\r\n    \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\",\r\n  );\r\n  assert(\r\n    !runtimeExited,\r\n    \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\",\r\n  );\r\n  return Module[\"asm\"][\"dynCall_viiii\"].apply(null, arguments);\r\n});\r\nvar dynCall_viiiii = (Module[\"dynCall_viiiii\"] = function () {\r\n  assert(\r\n    runtimeInitialized,\r\n    \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\",\r\n  );\r\n  assert(\r\n    !runtimeExited,\r\n    \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\",\r\n  );\r\n  return Module[\"asm\"][\"dynCall_viiiii\"].apply(null, arguments);\r\n});\r\nvar dynCall_viiiiii = (Module[\"dynCall_viiiiii\"] = function () {\r\n  assert(\r\n    runtimeInitialized,\r\n    \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\",\r\n  );\r\n  assert(\r\n    !runtimeExited,\r\n    \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\",\r\n  );\r\n  return Module[\"asm\"][\"dynCall_viiiiii\"].apply(null, arguments);\r\n});\r\nvar dynCall_viiiiiii = (Module[\"dynCall_viiiiiii\"] = function () {\r\n  assert(\r\n    runtimeInitialized,\r\n    \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\",\r\n  );\r\n  assert(\r\n    !runtimeExited,\r\n    \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\",\r\n  );\r\n  return Module[\"asm\"][\"dynCall_viiiiiii\"].apply(null, arguments);\r\n});\r\nvar dynCall_viiiiiiii = (Module[\"dynCall_viiiiiiii\"] = function () {\r\n  assert(\r\n    runtimeInitialized,\r\n    \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\",\r\n  );\r\n  assert(\r\n    !runtimeExited,\r\n    \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\",\r\n  );\r\n  return Module[\"asm\"][\"dynCall_viiiiiiii\"].apply(null, arguments);\r\n});\r\nvar dynCall_viiiiiiiii = (Module[\"dynCall_viiiiiiiii\"] = function () {\r\n  assert(\r\n    runtimeInitialized,\r\n    \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\",\r\n  );\r\n  assert(\r\n    !runtimeExited,\r\n    \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\",\r\n  );\r\n  return Module[\"asm\"][\"dynCall_viiiiiiiii\"].apply(null, arguments);\r\n});\r\nvar dynCall_viiiiiiiiiiiiiiiiiiiiiiiiiiiiiiijiiiiii = (Module[\r\n  \"dynCall_viiiiiiiiiiiiiiiiiiiiiiiiiiiiiiijiiiiii\"\r\n] = function () {\r\n  assert(\r\n    runtimeInitialized,\r\n    \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\",\r\n  );\r\n  assert(\r\n    !runtimeExited,\r\n    \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\",\r\n  );\r\n  return Module[\"asm\"][\"dynCall_viiiiiiiiiiiiiiiiiiiiiiiiiiiiiiijiiiiii\"].apply(\r\n    null,\r\n    arguments,\r\n  );\r\n});\r\nvar dynCall_viiiiiiiiiiiiiijiiiii = (Module[\"dynCall_viiiiiiiiiiiiiijiiiii\"] =\r\n  function () {\r\n    assert(\r\n      runtimeInitialized,\r\n      \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\",\r\n    );\r\n    assert(\r\n      !runtimeExited,\r\n      \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\",\r\n    );\r\n    return Module[\"asm\"][\"dynCall_viiiiiiiiiiiiiijiiiii\"].apply(\r\n      null,\r\n      arguments,\r\n    );\r\n  });\r\nvar dynCall_viiiiiiiiijiiii = (Module[\"dynCall_viiiiiiiiijiiii\"] = function () {\r\n  assert(\r\n    runtimeInitialized,\r\n    \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\",\r\n  );\r\n  assert(\r\n    !runtimeExited,\r\n    \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\",\r\n  );\r\n  return Module[\"asm\"][\"dynCall_viiiiiiiiijiiii\"].apply(null, arguments);\r\n});\r\nvar dynCall_vijii = (Module[\"dynCall_vijii\"] = function () {\r\n  assert(\r\n    runtimeInitialized,\r\n    \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\",\r\n  );\r\n  assert(\r\n    !runtimeExited,\r\n    \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\",\r\n  );\r\n  return Module[\"asm\"][\"dynCall_vijii\"].apply(null, arguments);\r\n});\r\n// === Auto-generated postamble setup entry stuff ===\r\n\r\nModule[\"asm\"] = asm;\r\n\r\nif (!Module[\"intArrayFromString\"])\r\n  Module[\"intArrayFromString\"] = function () {\r\n    abort(\r\n      \"'intArrayFromString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\",\r\n    );\r\n  };\r\nif (!Module[\"intArrayToString\"])\r\n  Module[\"intArrayToString\"] = function () {\r\n    abort(\r\n      \"'intArrayToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\",\r\n    );\r\n  };\r\nif (!Module[\"ccall\"])\r\n  Module[\"ccall\"] = function () {\r\n    abort(\r\n      \"'ccall' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\",\r\n    );\r\n  };\r\nif (!Module[\"cwrap\"])\r\n  Module[\"cwrap\"] = function () {\r\n    abort(\r\n      \"'cwrap' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\",\r\n    );\r\n  };\r\nif (!Module[\"setValue\"])\r\n  Module[\"setValue\"] = function () {\r\n    abort(\r\n      \"'setValue' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\",\r\n    );\r\n  };\r\nif (!Module[\"getValue\"])\r\n  Module[\"getValue\"] = function () {\r\n    abort(\r\n      \"'getValue' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\",\r\n    );\r\n  };\r\nif (!Module[\"allocate\"])\r\n  Module[\"allocate\"] = function () {\r\n    abort(\r\n      \"'allocate' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\",\r\n    );\r\n  };\r\nif (!Module[\"getMemory\"])\r\n  Module[\"getMemory\"] = function () {\r\n    abort(\r\n      \"'getMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\",\r\n    );\r\n  };\r\nif (!Module[\"AsciiToString\"])\r\n  Module[\"AsciiToString\"] = function () {\r\n    abort(\r\n      \"'AsciiToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\",\r\n    );\r\n  };\r\nif (!Module[\"stringToAscii\"])\r\n  Module[\"stringToAscii\"] = function () {\r\n    abort(\r\n      \"'stringToAscii' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\",\r\n    );\r\n  };\r\nif (!Module[\"UTF8ArrayToString\"])\r\n  Module[\"UTF8ArrayToString\"] = function () {\r\n    abort(\r\n      \"'UTF8ArrayToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\",\r\n    );\r\n  };\r\nif (!Module[\"UTF8ToString\"])\r\n  Module[\"UTF8ToString\"] = function () {\r\n    abort(\r\n      \"'UTF8ToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\",\r\n    );\r\n  };\r\nif (!Module[\"stringToUTF8Array\"])\r\n  Module[\"stringToUTF8Array\"] = function () {\r\n    abort(\r\n      \"'stringToUTF8Array' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\",\r\n    );\r\n  };\r\nif (!Module[\"stringToUTF8\"])\r\n  Module[\"stringToUTF8\"] = function () {\r\n    abort(\r\n      \"'stringToUTF8' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\",\r\n    );\r\n  };\r\nif (!Module[\"lengthBytesUTF8\"])\r\n  Module[\"lengthBytesUTF8\"] = function () {\r\n    abort(\r\n      \"'lengthBytesUTF8' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\",\r\n    );\r\n  };\r\nif (!Module[\"UTF16ToString\"])\r\n  Module[\"UTF16ToString\"] = function () {\r\n    abort(\r\n      \"'UTF16ToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\",\r\n    );\r\n  };\r\nif (!Module[\"stringToUTF16\"])\r\n  Module[\"stringToUTF16\"] = function () {\r\n    abort(\r\n      \"'stringToUTF16' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\",\r\n    );\r\n  };\r\nif (!Module[\"lengthBytesUTF16\"])\r\n  Module[\"lengthBytesUTF16\"] = function () {\r\n    abort(\r\n      \"'lengthBytesUTF16' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\",\r\n    );\r\n  };\r\nif (!Module[\"UTF32ToString\"])\r\n  Module[\"UTF32ToString\"] = function () {\r\n    abort(\r\n      \"'UTF32ToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\",\r\n    );\r\n  };\r\nif (!Module[\"stringToUTF32\"])\r\n  Module[\"stringToUTF32\"] = function () {\r\n    abort(\r\n      \"'stringToUTF32' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\",\r\n    );\r\n  };\r\nif (!Module[\"lengthBytesUTF32\"])\r\n  Module[\"lengthBytesUTF32\"] = function () {\r\n    abort(\r\n      \"'lengthBytesUTF32' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\",\r\n    );\r\n  };\r\nif (!Module[\"allocateUTF8\"])\r\n  Module[\"allocateUTF8\"] = function () {\r\n    abort(\r\n      \"'allocateUTF8' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\",\r\n    );\r\n  };\r\nif (!Module[\"stackTrace\"])\r\n  Module[\"stackTrace\"] = function () {\r\n    abort(\r\n      \"'stackTrace' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\",\r\n    );\r\n  };\r\nif (!Module[\"addOnPreRun\"])\r\n  Module[\"addOnPreRun\"] = function () {\r\n    abort(\r\n      \"'addOnPreRun' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\",\r\n    );\r\n  };\r\nif (!Module[\"addOnInit\"])\r\n  Module[\"addOnInit\"] = function () {\r\n    abort(\r\n      \"'addOnInit' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\",\r\n    );\r\n  };\r\nif (!Module[\"addOnPreMain\"])\r\n  Module[\"addOnPreMain\"] = function () {\r\n    abort(\r\n      \"'addOnPreMain' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\",\r\n    );\r\n  };\r\nif (!Module[\"addOnExit\"])\r\n  Module[\"addOnExit\"] = function () {\r\n    abort(\r\n      \"'addOnExit' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\",\r\n    );\r\n  };\r\nif (!Module[\"addOnPostRun\"])\r\n  Module[\"addOnPostRun\"] = function () {\r\n    abort(\r\n      \"'addOnPostRun' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\",\r\n    );\r\n  };\r\nif (!Module[\"writeStringToMemory\"])\r\n  Module[\"writeStringToMemory\"] = function () {\r\n    abort(\r\n      \"'writeStringToMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\",\r\n    );\r\n  };\r\nif (!Module[\"writeArrayToMemory\"])\r\n  Module[\"writeArrayToMemory\"] = function () {\r\n    abort(\r\n      \"'writeArrayToMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\",\r\n    );\r\n  };\r\nif (!Module[\"writeAsciiToMemory\"])\r\n  Module[\"writeAsciiToMemory\"] = function () {\r\n    abort(\r\n      \"'writeAsciiToMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\",\r\n    );\r\n  };\r\nif (!Module[\"addRunDependency\"])\r\n  Module[\"addRunDependency\"] = function () {\r\n    abort(\r\n      \"'addRunDependency' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\",\r\n    );\r\n  };\r\nif (!Module[\"removeRunDependency\"])\r\n  Module[\"removeRunDependency\"] = function () {\r\n    abort(\r\n      \"'removeRunDependency' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\",\r\n    );\r\n  };\r\nif (!Module[\"ENV\"])\r\n  Module[\"ENV\"] = function () {\r\n    abort(\r\n      \"'ENV' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\",\r\n    );\r\n  };\r\nif (!Module[\"FS\"])\r\n  Module[\"FS\"] = function () {\r\n    abort(\r\n      \"'FS' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\",\r\n    );\r\n  };\r\nif (!Module[\"FS_createFolder\"])\r\n  Module[\"FS_createFolder\"] = function () {\r\n    abort(\r\n      \"'FS_createFolder' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\",\r\n    );\r\n  };\r\nif (!Module[\"FS_createPath\"])\r\n  Module[\"FS_createPath\"] = function () {\r\n    abort(\r\n      \"'FS_createPath' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\",\r\n    );\r\n  };\r\nif (!Module[\"FS_createDataFile\"])\r\n  Module[\"FS_createDataFile\"] = function () {\r\n    abort(\r\n      \"'FS_createDataFile' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\",\r\n    );\r\n  };\r\nif (!Module[\"FS_createPreloadedFile\"])\r\n  Module[\"FS_createPreloadedFile\"] = function () {\r\n    abort(\r\n      \"'FS_createPreloadedFile' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\",\r\n    );\r\n  };\r\nif (!Module[\"FS_createLazyFile\"])\r\n  Module[\"FS_createLazyFile\"] = function () {\r\n    abort(\r\n      \"'FS_createLazyFile' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\",\r\n    );\r\n  };\r\nif (!Module[\"FS_createLink\"])\r\n  Module[\"FS_createLink\"] = function () {\r\n    abort(\r\n      \"'FS_createLink' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\",\r\n    );\r\n  };\r\nif (!Module[\"FS_createDevice\"])\r\n  Module[\"FS_createDevice\"] = function () {\r\n    abort(\r\n      \"'FS_createDevice' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\",\r\n    );\r\n  };\r\nif (!Module[\"FS_unlink\"])\r\n  Module[\"FS_unlink\"] = function () {\r\n    abort(\r\n      \"'FS_unlink' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\",\r\n    );\r\n  };\r\nif (!Module[\"GL\"])\r\n  Module[\"GL\"] = function () {\r\n    abort(\r\n      \"'GL' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\",\r\n    );\r\n  };\r\nif (!Module[\"dynamicAlloc\"])\r\n  Module[\"dynamicAlloc\"] = function () {\r\n    abort(\r\n      \"'dynamicAlloc' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\",\r\n    );\r\n  };\r\nif (!Module[\"warnOnce\"])\r\n  Module[\"warnOnce\"] = function () {\r\n    abort(\r\n      \"'warnOnce' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\",\r\n    );\r\n  };\r\nif (!Module[\"loadDynamicLibrary\"])\r\n  Module[\"loadDynamicLibrary\"] = function () {\r\n    abort(\r\n      \"'loadDynamicLibrary' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\",\r\n    );\r\n  };\r\nif (!Module[\"loadWebAssemblyModule\"])\r\n  Module[\"loadWebAssemblyModule\"] = function () {\r\n    abort(\r\n      \"'loadWebAssemblyModule' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\",\r\n    );\r\n  };\r\nif (!Module[\"getLEB\"])\r\n  Module[\"getLEB\"] = function () {\r\n    abort(\r\n      \"'getLEB' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\",\r\n    );\r\n  };\r\nif (!Module[\"getFunctionTables\"])\r\n  Module[\"getFunctionTables\"] = function () {\r\n    abort(\r\n      \"'getFunctionTables' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\",\r\n    );\r\n  };\r\nif (!Module[\"alignFunctionTables\"])\r\n  Module[\"alignFunctionTables\"] = function () {\r\n    abort(\r\n      \"'alignFunctionTables' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\",\r\n    );\r\n  };\r\nif (!Module[\"registerFunctions\"])\r\n  Module[\"registerFunctions\"] = function () {\r\n    abort(\r\n      \"'registerFunctions' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\",\r\n    );\r\n  };\r\nif (!Module[\"addFunction\"])\r\n  Module[\"addFunction\"] = function () {\r\n    abort(\r\n      \"'addFunction' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\",\r\n    );\r\n  };\r\nif (!Module[\"removeFunction\"])\r\n  Module[\"removeFunction\"] = function () {\r\n    abort(\r\n      \"'removeFunction' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\",\r\n    );\r\n  };\r\nif (!Module[\"getFuncWrapper\"])\r\n  Module[\"getFuncWrapper\"] = function () {\r\n    abort(\r\n      \"'getFuncWrapper' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\",\r\n    );\r\n  };\r\nif (!Module[\"prettyPrint\"])\r\n  Module[\"prettyPrint\"] = function () {\r\n    abort(\r\n      \"'prettyPrint' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\",\r\n    );\r\n  };\r\nif (!Module[\"makeBigInt\"])\r\n  Module[\"makeBigInt\"] = function () {\r\n    abort(\r\n      \"'makeBigInt' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\",\r\n    );\r\n  };\r\nif (!Module[\"dynCall\"])\r\n  Module[\"dynCall\"] = function () {\r\n    abort(\r\n      \"'dynCall' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\",\r\n    );\r\n  };\r\nif (!Module[\"getCompilerSetting\"])\r\n  Module[\"getCompilerSetting\"] = function () {\r\n    abort(\r\n      \"'getCompilerSetting' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\",\r\n    );\r\n  };\r\nif (!Module[\"stackSave\"])\r\n  Module[\"stackSave\"] = function () {\r\n    abort(\r\n      \"'stackSave' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\",\r\n    );\r\n  };\r\nif (!Module[\"stackRestore\"])\r\n  Module[\"stackRestore\"] = function () {\r\n    abort(\r\n      \"'stackRestore' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\",\r\n    );\r\n  };\r\nif (!Module[\"stackAlloc\"])\r\n  Module[\"stackAlloc\"] = function () {\r\n    abort(\r\n      \"'stackAlloc' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\",\r\n    );\r\n  };\r\nif (!Module[\"establishStackSpace\"])\r\n  Module[\"establishStackSpace\"] = function () {\r\n    abort(\r\n      \"'establishStackSpace' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\",\r\n    );\r\n  };\r\nif (!Module[\"print\"])\r\n  Module[\"print\"] = function () {\r\n    abort(\r\n      \"'print' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\",\r\n    );\r\n  };\r\nif (!Module[\"printErr\"])\r\n  Module[\"printErr\"] = function () {\r\n    abort(\r\n      \"'printErr' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\",\r\n    );\r\n  };\r\nif (!Module[\"getTempRet0\"])\r\n  Module[\"getTempRet0\"] = function () {\r\n    abort(\r\n      \"'getTempRet0' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\",\r\n    );\r\n  };\r\nif (!Module[\"setTempRet0\"])\r\n  Module[\"setTempRet0\"] = function () {\r\n    abort(\r\n      \"'setTempRet0' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\",\r\n    );\r\n  };\r\nif (!Module[\"Pointer_stringify\"])\r\n  Module[\"Pointer_stringify\"] = function () {\r\n    abort(\r\n      \"'Pointer_stringify' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\",\r\n    );\r\n  };\r\nif (!Module[\"ALLOC_NORMAL\"])\r\n  Object.defineProperty(Module, \"ALLOC_NORMAL\", {\r\n    get: function () {\r\n      abort(\r\n        \"'ALLOC_NORMAL' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\",\r\n      );\r\n    },\r\n  });\r\nif (!Module[\"ALLOC_STACK\"])\r\n  Object.defineProperty(Module, \"ALLOC_STACK\", {\r\n    get: function () {\r\n      abort(\r\n        \"'ALLOC_STACK' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\",\r\n      );\r\n    },\r\n  });\r\nif (!Module[\"ALLOC_DYNAMIC\"])\r\n  Object.defineProperty(Module, \"ALLOC_DYNAMIC\", {\r\n    get: function () {\r\n      abort(\r\n        \"'ALLOC_DYNAMIC' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\",\r\n      );\r\n    },\r\n  });\r\nif (!Module[\"ALLOC_NONE\"])\r\n  Object.defineProperty(Module, \"ALLOC_NONE\", {\r\n    get: function () {\r\n      abort(\r\n        \"'ALLOC_NONE' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\",\r\n      );\r\n    },\r\n  });\r\n\r\n/**\r\n * @constructor\r\n * @extends {Error}\r\n * @this {ExitStatus}\r\n */\r\nfunction ExitStatus(status) {\r\n  this.name = \"ExitStatus\";\r\n  this.message = \"Program terminated with exit(\" + status + \")\";\r\n  this.status = status;\r\n}\r\nExitStatus.prototype = new Error();\r\nExitStatus.prototype.constructor = ExitStatus;\r\n\r\nvar calledMain = false;\r\n\r\ndependenciesFulfilled = function runCaller() {\r\n  // If run has never been called, and we should call run (INVOKE_RUN is true, and Module.noInitialRun is not false)\r\n  if (!Module[\"calledRun\"]) run();\r\n  if (!Module[\"calledRun\"]) dependenciesFulfilled = runCaller; // try this again later, after new deps are fulfilled\r\n};\r\n\r\nModule[\"callMain\"] = function callMain(args) {\r\n  assert(\r\n    runDependencies == 0,\r\n    \"cannot call main when async dependencies remain! (listen on __ATMAIN__)\",\r\n  );\r\n  assert(\r\n    __ATPRERUN__.length == 0,\r\n    \"cannot call main when preRun functions remain to be called\",\r\n  );\r\n\r\n  args = args || [];\r\n\r\n  ensureInitRuntime();\r\n\r\n  var argc = args.length + 1;\r\n  var argv = stackAlloc((argc + 1) * 4);\r\n  HEAP32[argv >> 2] = allocateUTF8OnStack(Module[\"thisProgram\"]);\r\n  for (var i = 1; i < argc; i++) {\r\n    HEAP32[(argv >> 2) + i] = allocateUTF8OnStack(args[i - 1]);\r\n  }\r\n  HEAP32[(argv >> 2) + argc] = 0;\r\n\r\n  try {\r\n    var ret = Module[\"_main\"](argc, argv, 0);\r\n\r\n    // if we're not running an evented main loop, it's time to exit\r\n    exit(ret, /* implicit = */ true);\r\n  } catch (e) {\r\n    if (e instanceof ExitStatus) {\r\n      // exit() throws this once it's done to make sure execution\r\n      // has been stopped completely\r\n      return;\r\n    } else if (e == \"SimulateInfiniteLoop\") {\r\n      // running an evented main loop, don't immediately exit\r\n      Module[\"noExitRuntime\"] = true;\r\n      return;\r\n    } else {\r\n      var toLog = e;\r\n      if (e && typeof e === \"object\" && e.stack) {\r\n        toLog = [e, e.stack];\r\n      }\r\n      err(\"exception thrown: \" + toLog);\r\n      Module[\"quit\"](1, e);\r\n    }\r\n  } finally {\r\n    calledMain = true;\r\n  }\r\n};\r\n\r\n/** @type {function(Array=)} */\r\nfunction run(args) {\r\n  args = args || Module[\"arguments\"];\r\n\r\n  if (runDependencies > 0) {\r\n    return;\r\n  }\r\n\r\n  writeStackCookie();\r\n\r\n  preRun();\r\n\r\n  if (runDependencies > 0) return; // a preRun added a dependency, run will be called later\r\n  if (Module[\"calledRun\"]) return; // run may have just been called through dependencies being fulfilled just in this very frame\r\n\r\n  function doRun() {\r\n    if (Module[\"calledRun\"]) return; // run may have just been called while the async setStatus time below was happening\r\n    Module[\"calledRun\"] = true;\r\n\r\n    if (ABORT) return;\r\n\r\n    ensureInitRuntime();\r\n\r\n    preMain();\r\n\r\n    if (Module[\"onRuntimeInitialized\"]) Module[\"onRuntimeInitialized\"]();\r\n\r\n    if (Module[\"_main\"] && shouldRunNow) Module[\"callMain\"](args);\r\n\r\n    postRun();\r\n  }\r\n\r\n  if (Module[\"setStatus\"]) {\r\n    Module[\"setStatus\"](\"Running...\");\r\n    setTimeout(function () {\r\n      setTimeout(function () {\r\n        Module[\"setStatus\"](\"\");\r\n      }, 1);\r\n      doRun();\r\n    }, 1);\r\n  } else {\r\n    doRun();\r\n  }\r\n  checkStackCookie();\r\n}\r\n\r\nModule[\"run\"] = run;\r\n\r\nfunction exit(status, implicit) {\r\n  // if this is just main exit-ing implicitly, and the status is 0, then we\r\n  // don't need to do anything here and can just leave. if the status is\r\n  // non-zero, though, then we need to report it.\r\n  // (we may have warned about this earlier, if a situation justifies doing so)\r\n  if (implicit && Module[\"noExitRuntime\"] && status === 0) {\r\n    return;\r\n  }\r\n\r\n  if (Module[\"noExitRuntime\"]) {\r\n    // if exit() was called, we may warn the user if the runtime isn't actually being shut down\r\n    if (!implicit) {\r\n      err(\r\n        \"exit(\" +\r\n          status +\r\n          \") called, but noExitRuntime is set due to an async operation, so halting execution but not exiting the runtime or preventing further async execution (you can use emscripten_force_exit, if you want to force a true shutdown)\",\r\n      );\r\n    }\r\n  } else {\r\n    ABORT = true;\r\n    EXITSTATUS = status;\r\n\r\n    exitRuntime();\r\n\r\n    if (Module[\"onExit\"]) Module[\"onExit\"](status);\r\n  }\r\n\r\n  Module[\"quit\"](status, new ExitStatus(status));\r\n}\r\n\r\nvar abortDecorators = [];\r\n\r\nfunction abort(what) {\r\n  if (Module[\"onAbort\"]) {\r\n    Module[\"onAbort\"](what);\r\n  }\r\n\r\n  if (what !== undefined) {\r\n    out(what);\r\n    err(what);\r\n    what = JSON.stringify(what);\r\n  } else {\r\n    what = \"\";\r\n  }\r\n\r\n  ABORT = true;\r\n  EXITSTATUS = 1;\r\n\r\n  var extra = \"\";\r\n  var output = \"abort(\" + what + \") at \" + stackTrace() + extra;\r\n  if (abortDecorators) {\r\n    abortDecorators.forEach(function (decorator) {\r\n      output = decorator(output, what);\r\n    });\r\n  }\r\n  throw output;\r\n}\r\n\r\nModule[\"abort\"] = abort;\r\n\r\nif (Module[\"preInit\"]) {\r\n  if (typeof Module[\"preInit\"] == \"function\")\r\n    Module[\"preInit\"] = [Module[\"preInit\"]];\r\n  while (Module[\"preInit\"].length > 0) {\r\n    Module[\"preInit\"].pop()();\r\n  }\r\n}\r\n\r\n// shouldRunNow refers to calling main(), not run().\r\nvar shouldRunNow = true;\r\nif (Module[\"noInitialRun\"]) {\r\n  shouldRunNow = false;\r\n}\r\n\r\nrun();\r\n\r\n// {{MODULE_ADDITIONS}}\r\n"],"file":"assets/gs-BTUCgdlI.js"}